string[] zones;
timer maploadtimer;
string linear(string[] a)
{
string final;
for(uint i=0; i<a.length(); i++)
{
final+=(a[i]+"\r\n");
}
return final;
}
string[] delinear(string a)
{
return string_split(a, "\r\n", false);
}
bool in_map=false;
void load_map(string mdata)
{
speak("loading map...");
sound loading;
in_map=false;
p.destroy_all;
destroy_all_sources();
destroy_all_doors();
clear_map();
clear_zones();
zones.resize(0);
mapstring=mdata;
string[] ldata=delinear(mdata);
p.play_stationary("maploadstart.ogg",false);
loading.stream("maploading.ogg");
loading.play_looped();
maploadtimer.restart();
for(uint i=0; i<ldata.length(); i++)
{
netloop();
string[] parsed=string_split(ldata[i], ":", true);
if(parsed[0]=="mapname")
{
mapname=string_replace(ldata[i], "mapname:", "", false);
}
else if(parsed[0]=="tile")
{
int minx=stn(parsed[1]);
int maxx=stn(parsed[2]);
int miny=stn(parsed[3]);
int maxy=stn(parsed[4]);
int minz=stn(parsed[5]);
int maxz=stn(parsed[6]);
string ptype=parsed[7];
spawn_platform(minx,maxx,miny,maxy,minz,maxz,ptype);
}
else if(parsed[0]=="zone" and parsed.length>6)
{
int minx=stn(parsed[1]);
int maxx=stn(parsed[2]);
int miny=stn(parsed[3]);
int maxy=stn(parsed[4]);
int minz=stn(parsed[5]);
int maxz=stn(parsed[6]);
string zonedata=parsed[7];
spawn_zone(minx,maxx,miny,maxy,minz,maxz,zonedata);
if(parsed.length>7) zones.insert_last(string_replace(ldata[i], "zone:", "", true));
}
else if(parsed[0]=="door" and parsed.length()>=12)
{
int x=string_to_number(parsed[1]);
int y=string_to_number(parsed[2]);
int z=string_to_number(parsed[3]);
int fx=string_to_number(parsed[4]);
int fy=string_to_number(parsed[5]);
int fz=string_to_number(parsed[6]);
int speed=string_to_number(parsed[7]);
string snd1=parsed[8];
string snd2=parsed[9];
string snd3=parsed[10];
string snd4=parsed[11];
spawn_door(x, y, z, fx, fy,fz,speed,snd1,snd2,snd3,snd4);
}
else if(parsed[0]=="maxx")
{
max.x=string_to_number(parsed[1]);
}
else if(parsed[0]=="maxy")
{
max.y=string_to_number(parsed[1]);
}
else if(parsed[0]=="maxz")
{
max.z=string_to_number(parsed[1]);
}
else if(parsed[0]=="x")
{
me.x=string_to_number(parsed[1]);
}
else if(parsed[0]=="y")
{
me.y=string_to_number(parsed[1]);
}
else if(parsed[0]=="z")
{
me.z=string_to_number(parsed[1]);
}
else if(parsed[0]=="src" and parsed.length()>7)
{
int lx=string_to_number(parsed[1]);
int rx=string_to_number(parsed[2]);
int miny=string_to_number(parsed[3]);
int maxy=string_to_number(parsed[4]);
int minz=string_to_number(parsed[5]);
int maxz=string_to_number(parsed[6]);
int id=-1;
if(parsed.length>8) id=stn(parsed[8]);
spawn_source(lx, rx, miny, maxy, minz, maxz, parsed[7], false, id);
}
else if(parsed[0]=="amb" and parsed.length>7)
{
create_amb(stn(parsed[1]),stn(parsed[2]),stn(parsed[3]),stn(parsed[4]),stn(parsed[5]),stn(parsed[6]),parsed[7]);
}
}
loading.stop();
p.play_stationary("maploadend.ogg",false);
maploadtimer.pause();
in_map=true;
if(!SCRIPT_COMPILED and engexp)
{
file m;
m.open("map.dat", "wb");
m.write(export_map());
m.close();
m.open("zones.dat", "wb");
m.write(export_zones());
m.close();
}
}
void bforward()
{
double ox=me.x;
double oy=me.y;
me=move(me.x, me.y, me.z, facing, north);
if(round(me.x, 0)<0 or round(me.x, 0)>max.x or round(me.y, 0)<0 or round(me.y, 0)>max.y)
{
me.x=ox;
me.y+5;
return;
}
bcheckaround(ox, oy);
}
void bcheckaround(double ox, double oy)
{
mr.x=round(me.x, 0);
mr.y=round(me.y, 0);
if(string_contains(get_tile_at(mr.x, mr.y, me.z), "wall", 1)>-1)
{
//if(onwall==false)
{
//onwall=true;
p.play_stationary("bikecrash.ogg", false);
}
me.x=ox;
me.y=oy;
mr.x=round(ox,3);
mr.y=round(oy,3);
send_reliable(0, "bmove_to "+me.x+" "+me.y+" "+me.z, 0);
}
else
{
send_reliable(0, "bmove_to "+me.x+" "+me.y+" "+me.z, 0);
}
}
void playstep()
{
int x=me.x, y=me.y, z=me.z;
onwall=false;
p.play_stationary(get_tile_at(mr.x,mr.y,me.z)+"step"+random(1,5)+".ogg",false);
}
void cameramove(string dir)
{
if(dir==Up)
{
camera.z++;
playcamera();
}
if(dir==Down)
{
camera.z--;
playcamera();
}
if(dir==Forward)
{
double ox=camera.x;
double oy=camera.y;
camera=move(camera.x, camera.y, camera.z, facing, north);
if(round(camera.x, 0)<0 or round(camera.x, 0)>max.x or round(camera.y, 0)<0 or round(camera.y, 0)>max.y)
{
camera.x=ox;
camera.y=oy;
return;
}
playcamera();
}
if(dir==Backward)
{
double ox=camera.x;
double oy=camera.y;
camera=move(camera.x, camera.y, camera.z, facing, south);
if(round(camera.x, 0)<0 or round(camera.x, 0)>max.x or round(camera.y, 0)<0 or round(camera.y, 0)>max.y)
{
camera.x=ox;
camera.y=oy;
return;
}
playcamera();
}
if(dir==Left)
{
double ox=camera.x;
double oy=camera.y;
camera=move(camera.x, camera.y, camera.z, facing, west);
if(round(camera.x, 0)<0 or round(camera.x, 0)>max.x or round(camera.y, 0)<0 or round(camera.y, 0)>max.y)
{
camera.x=ox;
camera.y=oy;
return;
}
playcamera();
}
if(dir==Right)
{
double ox=camera.x;
double oy=camera.y;
camera=move(camera.x, camera.y, camera.z, facing, east);
if(round(camera.x, 0)<0 or round(camera.x, 0)>max.x or round(camera.y, 0)<0 or round(camera.y, 0)>max.y)
{
camera.x=ox;
camera.y=oy;
return;
}
playcamera();
}
}
void move(string dir)
{
if(dir==Up)
{
if(get_tile_at(mr.x, mr.y, me.z+1)!="")
{
me.z++;
checkup();
}
}
if(dir==Down)
{
if(get_tile_at(mr.x, mr.y, me.z-1)!="" and string_left(get_tile_at(mr.x,mr.y,me.z-1),4)!="wall")
{
me.z--;
checkdown();
}
}
if(dir==Forward)
{
double ox=me.x;
double oy=me.y;
me=move(me.x, me.y, me.z, facing, north);
if(round(me.x, 0)<0 or round(me.x, 0)>max.x or round(me.y, 0)<0 or round(me.y, 0)>max.y)
{
me.x=ox;
me.y=oy;
return;
}
checkaround(ox, oy);
}
if(dir==Backward)
{
double ox=me.x;
double oy=me.y;
me=move(me.x, me.y, me.z, facing, south);
if(round(me.x, 0)<0 or round(me.x, 0)>max.x or round(me.y, 0)<0 or round(me.y, 0)>max.y)
{
me.x=ox;
me.y=oy;
return;
}
checkaround(ox, oy);
}
if(dir==Left)
{
double ox=me.x;
double oy=me.y;
me=move(me.x, me.y, me.z, facing, west);
if(round(me.x, 0)<0 or round(me.x, 0)>max.x or round(me.y, 0)<0 or round(me.y, 0)>max.y)
{
me.x=ox;
me.y=oy;
return;
}
checkaround(ox, oy);
}
if(dir==Right)
{
double ox=me.x;
double oy=me.y;
me=move(me.x, me.y, me.z, facing, east);
if(round(me.x, 0)<0 or round(me.x, 0)>max.x or round(me.y, 0)<0 or round(me.y, 0)>max.y)
{
me.x=ox;
me.y=oy;
return;
}
checkaround(ox, oy);
}
//send_reliable(0,"movedir "+dir,0);
}
void checkaround(double ox, double oy)
{
mr.x=round(me.x, 0);
mr.y=round(me.y, 0);
if(string_contains(get_tile_at(mr.x, mr.y, me.z), "wall", 1)>-1)
{
if(onwall==false)
{
onwall=true;
p.play_stationary(get_tile_at(mr.x, mr.y, me.z)+".ogg", false);
send_reliable(0, "xplay "+get_tile_at(mr.x,mr.y,me.z), 0);
}
me.x=ox;
me.y=oy;
mr.x=round(ox,3);
mr.y=round(oy,3);
send_reliable(0, "move_to "+me.x+" "+me.y+" "+me.z, 0);
}
else
{
playstep();
send_reliable(0, "move_to "+me.x+" "+me.y+" "+me.z, 0);
}
}
void checkup()
{
if(string_contains(get_tile_at(mr.x, mr.y, me.z), "wall", 1)>-1)
{
if(onwall==false)
{
onwall=true;
p.play_stationary(get_tile_at(mr.x, mr.y, me.z)+".ogg", false);
send_reliable(0, "xplay "+get_tile_at(mr.x,mr.y,me.z), 0);
}
bounceback(Up);
}
else
{
playstep();
send_reliable(0, "move_to "+me.x+" "+me.y+" "+me.z, 0);
}
}
void checkdown()
{
if(string_contains(get_tile_at(mr.x, mr.y, me.z), "wall", 1)>-1 and onwall==false)
{
if(onwall==false)
{
onwall=true;
p.play_stationary(get_tile_at(mr.x, mr.y, me.z)+".ogg", false);
send_reliable(0, "xplay "+get_tile_at(mr.x,mr.y,me.z), 0);
}
bounceback(Down);
}
else
{
playstep();
send_reliable(0, "move_to "+me.x+" "+me.y+" "+me.z, 0);
}
}
void bounceback(int d)
{
if(d==Up)
{
me.z--;
}
else if(d==Down)
{
me.z++;
}
}
string gct()
{
return get_tile_at(round(camera.x,0), round(camera.y,0), camera.z);
}
int get_zone_index(string z)
{
int r=-1;
for(uint i=0; i<zones.length(); i++)
{
string[] parsed=string_split(zones[i],":",true);
if(parsed.length()>5)
{
if(parsed[6]==z)
{
r=i;
}
}
}
return r;
}
class binput
{
string[] indata;
string[] innames;
binput(string[] names, string[] input)
{
indata=input;
innames=names;
}
int num(string val)
{
int ix=innames.find(val);
if(ix>-1) return stn(indata[ix]);
return -1;
}
string str(string val)
{
int ix=innames.find(val);
if(ix>-1) return indata[ix];
return "";
}
}
binput@ builder_input(string spec)
{
if(spec=="") return null;
string[] items=delinear(spec);
string[] names,vals;
for(uint i=0; i<items.length; i++)
{
string[] p=string_split(items[i],"=",false);
names.insert_last(p[0]);
string tmp=v.input(p[1]);
if(tmp=="")
{
speak("canceled");
return null;
}
vals.insert_last(tmp);
}
binput res(names,vals);
return res;
}