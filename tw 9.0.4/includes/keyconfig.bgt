dictionary keynames;

// Constants for auxiliary commands:
const int KC_MOUSE1=-2, KC_MOUSE2=-3, KC_MOUSE3=-4, KC_MOUSE4=-5, KC_MOUSE5=-6, KC_MOUSE6=-7, KC_MOUSE7=-8, KC_MOUSE8=-9, KC_MOUSE9=-10;


class keyconfig {
	int[] keys;
	bool[] flags;
	string[] names;
	keyconfig() {
		init_keynames();
	}
	keyconfig(int size) {
		init_keynames();
		this.keys.resize(size);
		this.names.resize(size);
		this.flags.resize(size);
	}
	keyconfig(string txt) {
		init_keynames();
		this.load(txt);
	}
	
	int getKey(int k) {
		return this.keys.find(k);
	}
	int press(int k) {
		int index=this.keys.find(k);
		if(index>=0) {
			if(this.flags[index]) return -1;
			else {
				this.flags[index]=true;
				return index;
			}
		}
		return index;
	}
	int release(int k) {
		int index=this.keys.find(k);
		if(index<0) return index;
		else if(this.flags[index]) {
			this.flags[index]=false;
			return index;
		}
		else return -1;
	}
	
	bool key_down(int index) {
		return (index>=0 and index<this.flags.length() and this.flags[index]);
	}
	bool key_up(int index) {
		return !this.key_down(index);
	}
	int getKey(string name) {
		return this.names.find(name);
	}
	
	bool load(string txt) {
		string[] lines=string_split(string_replace(txt, "\r", "\n", true), "\n", true);
		uint index=0;
		while(index<lines.length() and !string_is_digits(lines[index])) {index++;}
		if(index>=lines.length()) {
			alert("Error in keyconfig.load", "Number of elements was not found.");
			return false;
		}
		uint l=string_to_number(lines[index]);
		this.names.resize(l);
		this.flags.resize(l);
		this.keys.resize(l);
		for(uint i=1; i<=l; i++) {
			if(index+i-1>=lines.length()) {
				alert("Error in keyconfig.load", "Index out of bounds. Total lines: " + lines.length() + ", expected entries: " + l + ", starting index: " + index + ", i:" + i + ".");
				return false;
			}
			string[] parts=string_split(lines[index+i-1], ":", true);
			if(parts.length()<2) continue;
			this.names[i-1]=parts[0];
			this.keys[i-1]=key_code(parts[1]);
			this.flags[i-1]=false;
		}
		return true;
	}
	string to_string(string header="") {
		uint l=this.keys.length();
		string ret=header + "\r\n" + l + "\r\n";
		for(uint i=0; i<l; i++) ret += this.names[i] + ":" + key_name(this.keys[i]) + "\r\n";
		return ret;
	}
	bool save(string filename, string header="") {
		file fout;
		fout.open(filename, "w");
		fout.write(this.to_string(header));
		fout.close();
		return true;
	}
	void update() {
		int k;
		for(uint i=0; i<this.keys.length(); i++) {
			k=this.keys[i];
			if(k<0) {
				if(k>=-10 and k<-1) {
					k=absolute(k+1); // Or is it +2?
					this.flags[i]=mouse_down(k);
				}
				else if(k==-1) continue;
			}// Mouse, etc.
			else if(key_pressed(k)) this.press(k);
			else if(key_released(k)) this.release(k);
			else if(key_down(k) and !this.flags[k]) this.press(k);
			else if(key_up(k) and this.flags[k]) this.release(k);
		}
	}
}


void init_keynames() {
	if(keynames.exists("A")) return;
	// Let's do this the somewhat easy way:
	int[] codes={KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN, KEY_SPACE, KEY_LCONTROL, KEY_RCONTROL, KEY_LMENU, KEY_RMENU, KEY_LSHIFT, KEY_RSHIFT, KEY_COMMA, KEY_PERIOD, KEY_SLASH, KEY_BACK, KEY_BACKSLASH, KEY_RETURN, KEY_A, KEY_B, KEY_C, KEY_D, KEY_E, KEY_F, KEY_G, KEY_H, KEY_I, KEY_J, KEY_K, KEY_L, KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T, KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y, KEY_Z, KEY_1, KEY_0, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_MINUS, KEY_ADD, KEY_NUMPAD0, KEY_NUMPAD1, KEY_NUMPAD2, KEY_NUMPAD3, KEY_NUMPAD4, KEY_NUMPAD5, KEY_NUMPAD6, KEY_NUMPAD7, KEY_NUMPAD8, KEY_NUMPAD9, KEY_HOME, KEY_PRIOR, KEY_NEXT, KEY_END, KEY_DELETE, KEY_LBRACKET, KEY_RBRACKET, KEY_TAB, KEY_EQUALS, KEY_MULTIPLY, KEY_DIVIDE, KEY_ESCAPE, KEY_SEMICOLON, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12, KC_MOUSE1, KC_MOUSE2, KC_MOUSE3, KC_MOUSE4, KC_MOUSE5, KC_MOUSE6, KC_MOUSE7, KC_MOUSE8, KC_MOUSE9};
	string[] descs={"left", "right", "up", "down", "space", "lctrl", "rcrtl", "lalt", "ralt", "lshift", "rshift", ",", ".", "/", "back", "\\", "enter", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "1", "0", "2", "3", "4", "5", "6", "7", "8", "9", "-", "+", "#0", "#1", "#2", "#3", "#4", "#5", "#6", "#7", "#8", "#9", "home", "pgup", "pgdn", "end", "del", "[", "]", "tab", "=", "*", "#/", "esc", ";", "f1", "f2", "f3", "f3", "F4", "f5", "F6", "F7", "f8", "F9", "f10", "f11", "f12", "MOUSE1", "MOUSE2", "MOUSE3", "MOUSE4", "MOUSE5", "MOUSE6", "MOUSE7", "MOUSE8", "MOUSE9"};
	string txt="Key mappings, for what it\'s worth:\r\n";
	for(uint i=0; i<codes.length(); i++) { txt += codes[i] + ", " + descs[i] + "\r\n";
		keynames.set(string_to_upper_case(descs[i]), codes[i]);
	}
	clipboard_copy_text(txt);
}

int key_code(string n) {
	int ret=-1;
	n=string_to_upper_case(n);
	if(keynames.exists(n)) keynames.get(n, ret);
	return ret;
}

string key_name(int k) {
	// this one is going to hurt.
	string[] keys=keynames.get_keys();
	for(uint i=0; i<keys.length(); i++) {
		int cur;
		keynames.get(keys[i], cur);
		if(cur==k) return keys[i];
	}
	return "";
}

keyconfig@ load_keyconfig(string filename) {
	if(!file_exists(filename)) {
		alert("Error in load_keyconfig", "The \'" + filename + "\' file could not be found. Check the spelling and try again.");
		return null;
	}
	file fin;
	fin.open(filename, "r");
	keyconfig ret(fin.read(0));
	fin.close();
	return ret;
}