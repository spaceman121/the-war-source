#include"includes.bgt"
ip_locale l;
bool varified=false;
int storex=0,storey=100,storez=0,fstorex=-1,fstorey=-1,fstorez=-1;
string storesound;
int packetlogging=2; //only turn this on if you want chan_0 to be logged with player.
string[] biketiles={"dirt","grass","gravel","metal","mud","rock","water","weed","wood"};
timer animaltimer;
timer storemovetimer;
int currentlyonline;
int writeprefs=1;
int chatting=0;
int serverchats=0,serversteps=0,serverkillr=0,servercommands=0,serverbans=0,serverkicks=0,servershots=0,serverlogins=0;
int speaktime=1;
int guessthenumber_active=0;
double gntarget=random(1,2);
int[] guessthenumber_guesses;
int guessthenumber_minutes=5;
string adminlog;
string guessthenumber_winner;
timer guessthenumbertimer, gnstarttimer;
int gnstart_auto=1;
int storemovestage=0;
int redwins, bluewins;
bool redflag=true, blueflag=true;
bool storemoving=false,fstorecoords=false;
uint storemovetime=10*60000;
int storeopened=1;
int objtime=800;
int maxobjs=500;
bool gamestopped=false;
bool gamestarted=false;
bool notify=false,public_uploading=false;
bool netsetup;
int filterstuff=1;
bool spawnobj=true;
double voteyes=0,voteno=0;
double minversion=5.0;
string[] newbitems={"antibiotic","antibiotic_pack","mini_antibiotic_pack","antibiotic_pack","tk_ultra_health_potion","health_drink"};
string minverstring="5.0";
timer garbagetimer;
timer objectspawntimer;
timer gifttimer;
timer versiontimer;
int connections=0, disconnections=0;
int gifting=1;
int fakeadmining=0;
int objgrabs=0, objspawns=0;
int can_upload_files=1;
int objspawntime=1200;
bool beta=false;
bool spawnai=false;
int cid=-1;
int port=31318;
int activations=0;
int peak;
string[] animaltypes;
string peakreached;
network n;
network_event e;
double file_size_limit_kb=2000;
string[] guns={"crossbow","ML7TinyMG","mk48","s&w_model66_revolver","famas","cannon","FRNTAssaultRifle","barrett_m82_sniper_rifle","cannon","mp5_machine_pistol","dragunovp_sniper","s&w_model66_revolver","mlk_203_combat_pistol","barrett_m82_sniper_rifle","stp106_long_barreled_pistol","m2browning","strong_machinegun","ml_Automatic_machinegun","m29_sniper_rifle","shotgun","ak47_assault_rifle","beretta_m9_pistol","beretta_m1951_machine_pistol","beretta_nano_pocket_pistol","blz83_portable_machine_gun","browning_high_power_bda_handgun","browning_m2_heavy_50_cal_machinegun","colt_ar_15_assault_rifle","colt_python_revolver","cop_357_derringer_pistol","crt43_automatic_shotgun","glock_17_pistol","m4a1_assault_rifle","m16_assault_rifle","m24_sniper_rifle","m134_minigun","m1208_shotgun","mlk_207_combat_rifle","modern_sub_machine_gun_carbine","nak_nk1000_decimater","ruger_security_6_revolver","saiga_12_5_round_shotgun","sig_p226_combat_pistol","sky_28_laser","sky_127_laser_handgun","stp_s84q_automatic_suppressed_pistol","stp21_handgun","str_32_pump_action_shotgun","str_301_long_barreled_machine_pistol","walther_p99_handgun","glock","sks","m4","m8a7","m16","m1891","m1921a1","glock","pistol","mp5","sniper","rpg7","rocketlauncher","bazooka","revolver","svd","kalashnikov_rifle","grenade_launcher","taser","dart_launcher","taser","ML420HuntingRifle","mossberg500","ml7tinymg"};
timer uptimer, accumulated_uptimer;
timer announcertimer;
timer timetimer;
timer savetimer;
int hour=0, minute=1, day=1, month=1, year=2000;
int timetime=1500;
savedata sd("prefs/server_state.dat","server_data");
string[] killmsgs;
string[] gifts;
string[] store_items;
string[] descriptions;
int[] amounts;
int auctiontime=30000;
string auctionwho,auctionwho2,auctionwhotemp;
bool auctionbidder;
bool auction;
string auctionitem;
int auctionamount;
int auctionbid,auctionbidtemp;
timer sheltersavetimer;
timer updatingtimer, auctiontimer;
bool updatingsvr=false,updatevstopped=false,updatevkilled=false,updatenotified=false,updatergkilled=false;
dictionary passresets;
prowl p("5d011dcc3e145e88bc4969e032760bc53bd5d496");
file fl;
dictionary sellitems;
string sellsend;
int missiletime=4000, missilemax=5,subtract=1,storefight=0,geo=0;
bool admingun=true;
http httpn;
bool svrmon=true;
void main()
{
if(file_exists("file.dll")==false)
{
alert("error","There are missing files. Please paste file.dll into the server");
exit();
}
filelib.load("file.dll");
httpn.user_agent="tksvr"+version;
weapons.reserve(200);
players.reserve(20);
start_profiling();
loaddata();
setupserver();
if(file_exists("server.bgt")) show_game_window("enes-productions.tr.ht server v"+version);
if(file_exists("server_b.bgt") and beta) show_game_window("tk server v "+version+" beta");
//versioncheck();
//validate_server();
load_compids();
load_all_teams();
string[] stuff=find_files("shelters/*.shelter");
if(stuff.length>0)
for(uint i=0; i<stuff.length(); i++)
{
load_shelter(string_replace(stuff[i],".shelter","",false));
}
load_bombs();
if(file_exists("prefs/motd.svr")==false)
{
file mfile;
mfile.open("prefs/motd.svr","wb");
mfile.write("hi, and welcome to the killer ");
mfile.close();
}
if(file_exists("maps/.map"))
file_delete("maps/.map");
if(file_exists("shelters/.shelter"))
file_delete("shelters/.shelter");
if(beta==true)
{
netsetup=n.setup_server(19932, 20, 500);
}
else
netsetup=n.setup_server(port, 20, 500);
if(netsetup==false)
file_put_contents("Errors.log","error in starting server. "+get_last_error()+"\r\n",255);
init_mapsystem();
if(beta==true)
{
speak("beta server active");
}
else
speak("server active");
log("svr","The Killer server started.");
file f;
f.open("prefs/death_messages.svr","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
for(uint i=0; i<lines.length(); i++)
{
killmsgs.insert_last(lines[i]);
}
if(file_exists("real_offline.txt")) file_delete("real_offline.txt");
storemove();
storespawn();
while(true)
{
wait(5);
loops();
//Lets save our data.
//I will hate myself for writing such messy code in the main fucking while loop, but oh well. Shit happens.
if(guessthenumber_active==1)
{
if(guessthenumbertimer.elapsed>60000)
{
guessthenumbertimer.restart();
guessthenumber_minutes++;
}
if(guessthenumber_minutes>1||get_paid_online().length<=guessthenumber_guesses.length)
{
guessthenumber_active=0;
send_reliable(0,"play_s gnfinished.ogg",0);
int windex=get_gnwinner();
int bestnum=get_closest_value(gntarget,guessthenumber_guesses);
string result;
if(windex>-1)
result=players[windex].name+" is the winner! congratulations!";
else
result="There was no winner in this game";
result+="\r\nThe best number entered was "+bestnum+" and the number was "+gntarget+". Numbers entered were: "+convert_to_list(guessthenumber_guesses);
send_reliable(0,result,2);
if(windex>-1)
players[windex].give("bitcoin",4);
for(uint i=0; i<players.length(); i++)
{
players[i].gnplaying=0;
file_delete("chars/"+players[i].name+"/gn.usr");
}
}
}
if(gnstarttimer.elapsed>6000*10)
{
gnstarttimer.restart();
if(guessthenumber_active==0 and gnstart_auto==0 and get_paid_online().length>=1)
{
send_reliable(0,"The guess the number minigame has started. Everyone has 5 minutes to enter a number in to the box. Type /g to submit your guess, no less than 1 and no higher than 50. The cloesest person to the number gets 500000 dollars. Go!",2);
send_reliable(0, "play_s gnstart.ogg", 0);
gnstart();
}
}
if(players.length()!=currentlyonline&&svrmon==true)
{
currentlyonline=players.length();
string stuffage="There are ";
if(players.length()<=0)
{
stuffage+="currently no connected players on the server";
write_to_webfile("tk/playerlist.db",stuffage);
}
else
{
stuffage+="currently "+players.length()+" players online. They are: ";
for(uint i=0; i<players.length(); i++)
{
netloop();
if(i==players.length()-1)
stuffage+="and "+players[i].name+" with "+players[i].kills+" kills and "+players[i].deaths+" deaths.";
else
stuffage+=players[i].name+" with "+players[i].kills+" kills and "+players[i].deaths+" deaths, ";
}
write_to_webfile("tk/playerlist.db",stuffage);
}
}
if(savetimer.elapsed>=45000 and writeprefs==1)
{
savetimer.restart();
for(uint i=0; i<players.length; i++)
{
scd(i);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_shipments();
}
if(garbagetimer.elapsed>=25000)
{
garbagetimer.restart();
garbage_collect();
}
//some stuff to prevent the server from overflowing with stuff if players aren't connected
if(players.length==0) {
objs.resize(0);
remguns.resize(0);
}
if(sheltersavetimer.elapsed>=5000)
{
sheltersavetimer.restart();
saveshelters();
}
if(key_pressed(KEY_H))
hide_game_window();
if(key_pressed(KEY_ESCAPE))
exitsvr();
}
}
void loaddata()
{
file pr;
if(file_exists("prefs/admin_log.svr"))
{
adminlog=file_get_contents("prefs/admin_log.svr");
}
if(file_exists("prefs/passresets.dat"))
{
pr.open("prefs/passresets.dat","rb");
passresets=deserialize(string_decrypt(pr.read(),"ultrafuckyou"));
pr.close();
}
if(file_exists("prefs/compbans.svr"))
{
pr.open("prefs/compbans.svr","rb");
string bandata=pr.read();
pr.close();
bandata=string_decrypt(bandata,"ultrafuckyou");
compbans=deserialize(bandata);
}
if(file_exists("prefs/ipbans.svr"))
{
pr.open("prefs/ipbans.svr","rb");
string bandata=pr.read();
pr.close();
ipbans=deserialize(bandata);
}
if(file_exists("prefs/tempbans.svr")) load_all_tempbans();
if(file_exists("prefs/shipments.svr")) load_shipments();
sd.load();
if(sd.d.exists("gnstart_auto")) gnstart_auto=sd.readn("gnstart_auto");
if(sd.d.exists("peak"))
peak=sd.readn("peak");
if(sd.d.exists("chatting"))
chatting=sd.readn("chatting");
if(sd.d.exists("activations"))
activations=sd.readn("activations");
if(sd.d.exists("minute"))
minute=sd.readn("minute");
if(sd.d.exists("hour"))
hour=sd.readn("hour");
if(sd.d.exists("day"))
day=sd.readn("day");
if(sd.d.exists("month"))
month=sd.readn("month");
if(sd.d.exists("year"))
year=sd.readn("year");
if(sd.d.exists("peakreached"))
peakreached=sd.read("peakreached");
if(sd.d.exists("gifting"))
gifting=sd.readn("gifting");
if(sd.d.exists("voteyes"))
voteyes=sd.readn("voteyes");
if(sd.d.exists("voteno"))
voteno=sd.readn("voteno");
if(sd.d.exists("storeopened"))
storeopened=sd.readn("storeopened");
if(sd.d.exists("missiletime"))
missiletime=sd.readn("missiletime");
if(sd.d.exists("missilemax"))
missilemax=sd.readn("missilemax");
if(sd.d.exists("geo"))
geo=sd.readn("geo");
load_robots();
if(sd.d.exists("storefight"))
storefight=sd.readn("storefight");
if(sd.d.exists("geo"))
geo=sd.readn("geo");
}
void writedata(string fv="", int fvv=-55555)
{
sd.add("activations",activations);
sd.add("gnstart_auto", gnstart_auto);
sd.add("voteyes",voteyes);
sd.add("voteno",voteno);
sd.add("gifting",gifting);
sd.add("peak",peak);
sd.add("peakreached",peakreached);
sd.add("storeopened",storeopened);
sd.add("chatting",chatting);
sd.add("missiletime",missiletime);
sd.add("minute",minute);
sd.add("hour",hour);
sd.add("day",day);
sd.add("month",month);
sd.add("year",year);
sd.add("missilemax",missilemax);
sd.add("storefight",storefight);
sd.add("geo",geo);
if(fv!=""&&fvv!=-55555)
sd.add(fv,fvv);
print_store();
save_store_registers();
file_put_contents("prefs/admin_log.svr",adminlog,250);
file pr;
string bandata=serialize(compbans);
bandata=string_encrypt(bandata,"ultrafuckyou");
pr.open("prefs/compbans.svr","wb");
pr.write(bandata);
pr.close();
bandata=serialize(ipbans);
pr.open("prefs/ipbans.svr","wb");
pr.write(bandata);
pr.close();
bandata=serialize(passresets);
pr.open("prefs/passresets.dat","wb");
pr.write(string_encrypt(bandata,"ultrafuckyou"));
pr.close();
sd.save();
save_tempbans();
}
void netloop()
{
weaponloop();
if(players.length()>peak)
{
peak=players.length();
send_reliable(0,"notify we have reached a new peak of "+peak+" players!",0);
peakreached=get_date(true,false)+" at "+get_time();
}
if(updatingsvr==true) updateloop();
e=n.request();
if (auctiontimer.elapsed>=auctiontime and auction==true)
{
if (auctionbidder==false)
{
auction=false;
auctionitem="";
auctionbidder=false;
auctionamount=0;
auctionbid=0;
auctionbidtemp=0;
auctionwho="";
auctionwho2="";
auctionwhotemp="";
send_reliable(0,"Auction ended. Item returned to user.",2);
}
else
{
int index1=get_player_index_from(auctionwho);
int index2=get_player_index_from(auctionwho2);
if (index1==-1 or index2==-1)
{
send_reliable(0,"Auction reset. 1 or more required players have gone offline.",2);
auction=false;
auctionitem="";
auctionbidder=false;
auctionamount=0;
auctionbid=0;
auctionbidtemp=0;
auctionwho="";
auctionwho2="";
auctionwhotemp="";
}
else
{
if (players[index1].get_item_count(auctionitem)<auctionamount)
{
auction=false;
auctionitem="";
auctionbidder=false;
auctionamount=0;
auctionbid=0;
auctionwho="";
auctionwho2="";
send_reliable(0,"Auction reset. The auctioner no longer has the item.",2);
}
else
{
players[index2].give("dollar",-auctionbid);
players[index2].give(auctionitem,auctionamount);
players[index1].give(auctionitem,-auctionamount);
players[index1].give("dollar",auctionbid);
auction=false;
auctionitem="";
auctionbidder=false;
auctionamount=0;
auctionbid=0;
auctionwho="";
auctionwho2="";
send_reliable(0,"play_s auctionwon.ogg",0);
send_reliable(0,"Auction finished! Item sold to "+players[index2].nickname,2);
}
}
}
}
if(e.type==event_disconnect)
{
int index=get_player_index(e.peer_id);
if(index > -1&&!players[index].disconnected)
{
if(players[index].hidden==0) send_reliable(0,players[index].nickname+" has lost connection to the server",2);
log("disconnections",players[index].name+" lost connection",true,true);
remove_player(players[index].name,false,true);
}
}
if(e.type==event_receive)
{
if(e.channel==2&&get_player_index(e.peer_id)>-1)
{
int index=get_player_index(e.peer_id);
if(string_len(string_trim_left(get_event_message(),9))>(file_size_limit_kb*1024))
{
send_reliable(e.peer_id,"This file is too large. The maximum file size on this server is "+convert_size(file_size_limit_kb*1024)+", and your file is "+convert_size(string_len(string_trim_left(get_event_message(),9))),2);
}
else
{
string[] parsed=string_split(get_event_message()," ",false);
if(string_left(get_event_message(),8)=="tk_sound")
{
send_reliable(0,get_event_message(),5);
if(!directory_exists("upsounds"))
directory_create("upsounds");
file f;
f.open("upsounds/"+players[index].name+" Ssound_"+DATE_YEAR+DATE_MONTH+DATE_DAY+"-"+TIME_HOUR+TIME_MINUTE+TIME_SECOND+".ogg","wb");
f.write(string_replace(get_event_message(),"tk_sound ","",false));
f.close();
}
}
}
if (e.channel==1)
{
string[] parsed=string_split(get_event_message(), " ",true);
int index=get_player_index(e.peer_id);
if (index>-1)
{
string message=get_event_message();
if(filter(message))
{
send_reliable(e.peer_id,"The server has detected a crash code. The server will prevent these messages from going through.",2);
send_reliable(0,"play_s notify.ogg",0);
send_reliable(0, "warning! The player "+players[index].nickname+" is trying to send crash codes through the chat!", 2);
remove_player(players[index].name);
return;
}
/*people have been telling me the char filter is stupid, and this defeats the purpose of native language pm's
if(filterchar(message))
{
send_reliable(e.peer_id,"Your message contains unknown characters.",2);
return;
}
*/
if (string_left(get_event_message(),1)!="/")
{
if(players[index].hidden>0)
{
send_reliable(players[index].peer_id,"I don't think you wanna just chat while hidden... There could be a missing slash on a command there! If you'd like to send out a chat, type /chat first. This will omit your name and broadcast on all language channels.",2);
return;
}
if(get_event_message().length()>5000)
{
send_reliable(players[index].peer_id,"Message is too long",0);
return;
}
if(players[index].ds.find("chat")>-1)
{
send_reliable(players[index].peer_id,"your chats have been disabled",0);
return;
}
if(chatting==0)
{
string message;
message="Sorry, server chats are currently disabled.";
if(players[index].adminable()) message+=" If you want to turn them back on, type /varset chatting 1";
send_reliable(players[index].peer_id,message,2);
return;
}
players[index].chats+=1;
log(players[index].name+"_chats",players[index].nickname+" ("+players[index].name+") said "+get_event_message(),true,true);
string chatmessage=get_event_message();
if(players[index].drunk==true)
{
int action=random(1,3);
if(action==1) chatmessage=chatmessage; //do nothing.
else if(action==2) chatmessage=string_replace(chatmessage," ","",true);
else if(action==3) chatmessage=string_reverse(chatmessage);
}
string chatmess;
if(players[index].title!="") chatmess+=players[index].title+" ";
if(players[index].ttitle!="") chatmess+=players[index].ttitle+" ";
if(players[index].teamname!="") chatmess+=players[index].teamname+" ";
chatmess+=players[index].ptitle+" "+players[index].name+": "+chatmessage;
players[index].chat(chatmess);
return;
}
else
{
if(index>-1)
log(players[index].name+"_commands",players[index].nickname+" ("+players[index].name+") sent "+get_event_message());
}
if(parsed[0]=="/stats" and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1],false);
if(index2<0)
{
send_reliable(players[index].peer_id,"Not found",0);
send_reliable(players[index].peer_id,"play_s playerstats_error.ogg",0);
return;
}
string statslist;
statslist="The player "+players[index2].name+" has been playing tk for a total of "+ms_to_readable_time(players[index2].playtimer.elapsed)+", has sent "+players[index2].chats+" chats, has "+players[index2].deaths+" deaths and "+players[index2].kills+" kills and "+players[index2].level+" level. Has unlocked "+players[index2].a.count_achievements()+" achievements, has a killing accuracy of "+round(percent(players[index2].kills,players[index2].kills+players[index2].deaths),0)+" percent";
int t=is_in_team(players[index2].name);
if(t>-1)
{
statslist+=" "+players[index2].name+" is part of the "+teams[t].teamname+" team.";
}
send_reliable(players[index].peer_id,"play_s playerstats.ogg",0);
send_reliable(players[index].peer_id,statslist,2);
}
else if(parsed[0]=="/clearstats")
{
send_reliable(players[index].peer_id,"Your kill and death count was just cleared",2);
players[index].kills=0;
players[index].deaths=0;
scd(index);
}
else if(parsed[0]=="/set_id" and players[index].dev==true) {
cid=e.peer_id;
send_reliable(e.peer_id,"Set",0);
}
else if(parsed[0]=="/clearlogs" and players[index].dev)
{
directory_delete("logs");
send_reliable(players[index].peer_id,"The logs have been cleared!",0);
}
else if(parsed[0]=="/online" and players[index].adminable())
{
spawn_player(250,250,0,"main","die",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/ch_online" and players[index].adminable())
{
spawn_player(250,250,0,"main","charlenger",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/fuck" and players[index].adminable())
{
spawn_player(250,250,0,"main","fuck_me",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/online2" and players[index].adminable())
{
spawn_player(250,250,0,"main","sik_beni_muhammet",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/yavuz" and players[index].adminable())
{
spawn_player(250,250,0,"main","yavuz",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/silak" and players[index].adminable())
{
spawn_player(250,250,0,"main","silak",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/oc" and players[index].adminable())
{
spawn_player(250,250,0,"main","beni_öldürmeyen_orosbu_çocuðu",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/compinfo" and parsed.length()>1 and players[index].adminable())
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Not found",0);
send_reliable(players[index].peer_id,"play_s playerstats_error.ogg",0);
return;
}
send_reliable(players[index].peer_id,players[index2].ctext,2);
}
else if(parsed[0]=="/playtime")
{
string[] chars=find_directories("chars/*");
double finalms=0;
for(uint i=0; i<chars.length(); i++)
{
if(file_exists("chars/"+chars[i]+"/playtime.usr"))
finalms+=stn(get_char_val(chars[i],"playtime"));
}
send_reliable(players[index].peer_id,"Everyone's combined playtime is "+ms_to_readable_time(finalms),2);
}
else if(parsed[0]=="/fireoutall")
{
if(players[index].adminable())
{
for(uint i=0; i<fires.length(); i++)
{
fires[i].lifetimer.force(fires[i].lifetime);
}
send_reliable(players[index].peer_id,"Done",0);
}
}
else if(parsed[0]=="/uploadsound")
{
if(players[index].adminable() or public_uploading==true and 1==2)
{
if(can_upload_files==0&&players[index].dev==false) send_reliable(e.peer_id,"File uploading is not permitted on this server",2);
else send_reliable(e.peer_id,"upload 1",0);
}
else send_reliable(players[index].peer_id,"Only developers and admins can upload files to the server",0);
}
else if(parsed[0]=="/bid" and parsed.length()>=2)
{
if (auction==false)
{
send_reliable(e.peer_id,"No auction in progress.",2);
}
else
{
if (auctionwho==players[index].name)
{
send_reliable(e.peer_id,"You cannot bid in your own auction.",2);
}
else
{
int bid=string_to_number(parsed[1]);
if (auctionbid>=bid)
{
send_reliable(e.peer_id,"You must bid greater than "+auctionbid,2);
}
else
{
if (bid>=players[index].get_item_count("dollar"))
{
send_reliable(e.peer_id,"You don't have this many dollars.",2);
}
else
{
auctionbidtemp=auctionbid;
auctionbid=bid;
auctionwhotemp=auctionwho2;
auctionwho2=players[index].name;
auctionbidder=true;
auctiontimer.restart();
send_reliable(0,"play_s bid.ogg",0);
send_reliable(0,players[index].nickname+" Has bid "+bid+" dollars!",2);
}
}
}
}
}
else if(parsed[0]=="/auction" and parsed.length()>=4)
{
if(players[index].paid==0)
{
send_reliable(players[index].peer_id,"This is only available to paid accounts",2);
return;
}
int amount=string_to_number(parsed[1]);
if(amount<=0)
{
send_reliable(e.peer_id,"You cannot auction negative amounts!",2);
}
else if (parsed[2]=="dollar"||parsed[2]=="dollar_pack")
send_reliable(e.peer_id, "No, you can't be stupid and auction dollars for dollars.", 0);
else
{
string what=parsed[2];
int minbid=string_to_number(parsed[3]);
if(minbid<=0)
{
send_reliable(e.peer_id,"you cannot have a negative bid!",2);
}
else
{
if (auction==false)
{
if (inv_item_exists(players[index].get_inv(),what))
{
if (players[index].get_item_count(what)>=amount)
{
auctionitem=what;
auctionbid=minbid;
auctionamount=amount;
auctionwho=players[index].name;
send_reliable(0,"New auction from "+players[index].nickname+"! "+amount+" "+auctionitem+", minimum bid "+minbid+" dollars.",2);
send_reliable(0,"play_s auction.ogg",0);
auctiontimer.restart();
auction=true;
auctionbidder=false;
}
else
{
send_reliable(e.peer_id,"You don't have this many.",2);
}
}
else
{
send_reliable(e.peer_id,"You don't have this item.",2);
}
}
}
}
}
else if(parsed[0]=="/cancelbid" and parsed.length()>=1)
{
if (auctionwho2==players[index].name)
{
send_reliable(0,"play_s cancelbid.ogg",0);
send_reliable(0,players[index].nickname+" has decided not to bid "+auctionbid+" dollars!",2);
auctiontimer.restart();
auctionbid=auctionbidtemp;
auctionwho2=auctionwhotemp;
}
}
else if(parsed[0]=="/cancelauction" and parsed.length()>=1)
{
if (auction==true)
{
if (auctionwho==players[index].name||players[index].masterable())
{
auction=false;
auctionitem="";
auctionbidder=false;
auctionamount=0;
auctionbid=0;
auctionwho="";
auctionwho2="";
send_reliable(0,"play_s auctioncanceled.ogg",0);
send_reliable(0,"Auction canceled by "+players[index].nickname,2);
}
else
{
send_reliable(e.peer_id,"This is not your auction, you cannot cancel it.",2);
}
}
else
{
send_reliable(e.peer_id,"No auction to cancel",2);
}
}
else if(parsed[0]=="/auction" and parsed.length()<4)
{
if (auction==false)
{
send_reliable(e.peer_id,"No auction",2);
}
else
{
send_reliable(e.peer_id,"auction: "+auctionitem+", quantity "+auctionamount+", minimum bid "+auctionbid+" dollars.",2);
}
}
else if(parsed[0]=="/nickfind" and parsed.length>1)
{
string nick=string_to_lower_case(string_trim_left(get_event_message(),10));
send_reliable(players[index].peer_id,"begin matches for "+nick,2);
for(uint i=0; i<players.length; i++)
{
if(string_contains(string_to_lower_case(players[i].nickname),nick,1)>-1&&players[i].hidden==0) send_reliable(players[index].peer_id,players[i].name,2);
}
send_reliable(players[index].peer_id,"end matches for "+nick,2);
}
else if(parsed[0]=="/nickname" and parsed.length()>1)
{
if(players[index].nicktimer.elapsed>=120000 or players[index].dev==true) //2 minutes!
{
players[index].nicktimer.restart();
string nick=string_replace(get_event_message(),"/nickname ","",true);
if((string_contains(string_to_lower_case(nick),"charlie",1) >-1 or string_contains(string_to_lower_case(nick),"ernie96",1) >-1) and players[index].dev==false)
send_reliable(players[index].peer_id,"You can not do that",0);
else if((string_contains(string_to_lower_case(nick),"admin",1)>-1 or string_contains(string_to_lower_case(nick),"developer",1)>-1)&&!players[index].adminable())
send_reliable(players[index].peer_id,"deception and impersonation are against the rules!",0);
else if(string_len(nick)>50) send_reliable(players[index].peer_id,"this nickname is too long. Maximum length is 50 characters",0);
else
{
send_reliable(0,players[index].nickname+" has changed their nickname to "+nick,2);
players[index].nickname=nick;
scd(index);
}
}
else
{
send_reliable(players[index].peer_id,"Sorry, you can't change your nickname yet",0);
return;
}
}
else if(parsed[0]=="/settitle" and parsed.length()>2&&players[index].masterable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
players[index2].title=string_replace(get_event_message(),parsed[0]+" "+parsed[1]+" ","",false);
//send_reliable(players[index2].peer_id,"Your title has been updated to "+parsed[2]+" by player "+players[index].name,2);
send_reliable(players[index].peer_id,"Title set",0);
}
else
{
send_reliable(players[index].peer_id,"That player could not be found",0);
}
}
else if(parsed[0]=="/cleartitle" and parsed.length>1 and players[index].masterable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
players[index2].title="";
//send_reliable(players[index2].peer_id,"Your title has been updated to "+parsed[2]+" by player "+players[index].name,2);
send_reliable(players[index].peer_id,"Title cleared",0);
}
else
{
send_reliable(players[index].peer_id,"That player could not be found",0);
}
}
else if(parsed[0]=="/gifting")
{
if(players[index].adminable())
{
if(gifting==1) { send_reliable(0,"play_s giftoff.ogg",0); send_reliable(players[index].peer_id,"gifting has been disabled",0); gifting=0; }
else if(gifting==0) { send_reliable(0,"play_s gifton.ogg",0); send_reliable(players[index].peer_id,"Gifting has been enabled",0); gifting=1; }
writedata();
}
}
else if(parsed[0]=="/admreply" and parsed.length()>2)
{
if(players[index].adminable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
string stuff=string_replace(get_event_message(),parsed[0]+" "+parsed[1]+" ","",false);
send_reliable(players[index2].peer_id,"notify someone answers you: "+stuff,0);
send_reliable(players[index].peer_id,"Done",0);
}
else
{
send_reliable(players[index].peer_id,"Not found",0);
}
}
}
else if(parsed[0]=="/garbage")
{
if(players[index].modable())
{
send_reliable(0,"play_s notify_woosh.ogg",0);
send_reliable(0,"alert! "+players[index].name+" is collecting all server garbage to try to free lag. This might lag the server for a few seconds, please do not disconnect",2);

missiles.resize(0);

grenades.resize(0);

helicopters.resize(0);

canisters.resize(0);

fires.resize(0);

impact_bombs.resize(0);

mines.resize(0);

objs.resize(0);

remguns.resize(0);

robots.resize(0);

timebombs.resize(0);

wirebombs.resize(0);

smokebombs.resize(0);

motion_bombs.resize(0);

ultrabombs.resize(0);

bottle_bombs.resize(0);

cannonballs.resize(0);

carrier_missiles.resize(0);

concussive_grenades.resize(0);

hand_grenades.resize(0);

helicopters.resize(0);

mass_bombs.resize(0);

nuclear_bombs.resize(0);

pipe_bombs.resize(0);

poison_daggers.resize(0);

rockets.resize(0);

rpgs.resize(0);

sat_bombs.resize(0);

sound_grenades.resize(0);

stp429s.resize(0);

stun_grenades.resize(0);

suicide_bombs.resize(0);
garbage_collect();
}
}
else if(parsed[0]=="/chartrash")
{
if(players[index].adminable())
{
string[] directories=find_directories("chars/*");
for (uint i=0; i<directories.length(); i++)
{
file_delete("chars/"+directories[i]+"/disabled.usr");
}
send_reliable(0,"play_s garbage.ogg",0);
send_reliable(0,"alert! "+players[index].name+" initialized a character spam collection. "+chartrash(),2);
}
}
else if(parsed[0]=="/t" and parsed.length()>1)
{
int t=is_in_team(players[index].name);
if(t>-1)
{
teams[t].transmit(players[index].nickname+" team coms: "+string_trim_left(get_event_message(),3),true);
log("eventstream","in team "+teams[t].teamname+", "+players[index].nickname+" ("+players[index].name+") said "+string_trim_left(get_event_message(),3));
}
else
{
send_reliable(players[index].peer_id,"You are not in a team",0);
return;
}
}
else if(parsed[0]=="/teams")
{
string mess;
mess+="There are "+teams.length()+" teams. ";
for(uint i=0; i<teams.length(); i++)
{
mess+=teams[i].teamname+" with "+(teams[i].teammembers.length()+teams[i].buffermembers.length())+" members and "+teams[i].teamkills+" kills and "+teams[i].points+" points, leader "+cn2n(teams[i].teamleader)+". ";
}
send_reliable(players[index].peer_id, mess, 2);
}
else if(parsed[0]=="/members")
{
int ist=is_in_team(players[index].name);
if(ist>-1)
{
send_reliable(players[index].peer_id,teams[ist].list_members(),2);
}
else
{
send_reliable(players[index].peer_id,"You are not in a team",0);
return;
}
}
else if(parsed[0]=="/teamshelters")
{
int t=is_in_team(players[index].name);
if(t>-1)
{
string[] outa;
for(uint i=0; i<shelters.length; i++)
{
if(shelters[i].teamname==teams[t].teamname) outa.insert_last(shelters[i].sheltername+", on "+shelters[i].map+" at "+shelters[i].x+", "+shelters[i].y+", "+shelters[i].z+", owned by "+shelters[i].owner+".");
}
string s;
if(outa.length==0) s="your team doesn't own any shelters";
else if(outa.length==1) s="your team owns 1 shelter: "+outa[0];
else
{
s="your team owns "+outa.length+" shelters: ";
for(uint i=0; i<(outa.length-1); i++)
{
s+=outa[i]+" ";
}
s+="and "+outa[(outa.length()-1)];
}
send_reliable(players[index].peer_id,s,2);
}
else send_reliable(players[index].peer_id,"you are not in a team",2);
}
else if(parsed[0]=="/teamcancel")
{
int t=get_team_index(players[index].teamname);
if(t<0)
{
send_reliable(players[index].peer_id,"You are not in a team",0);
return;
}
else
{
if(teams[t].teamleader==players[index].name)
{
send_reliable(players[index].peer_id,"Your team has been canceled",2);
teams[t].destruct();
}
else send_reliable(players[index].peer_id, "you aren't the leader of this team", 0);
return;
}
}
else if(parsed[0]=="/teamdestroy"&&parsed.length>1&&players[index].adminable())
{
int t=get_team_index(parsed[1]);
if(t<0)
{
send_reliable(players[index].peer_id,"invalid team",2);
return;
}
else
{
send_reliable(players[index].peer_id,"this team has been canceled",2);
teams[t].destruct();
}
}
else if(parsed[0]=="/teamdestroyold"&&players[index].adminable())
{
uint counter=0;
for(uint i=0; i<teams.length; i++)
{
if(teams[i].teammembers.length<=0)
{
teams[i].destruct(false);
counter++;
}
}
send_reliable(players[index].peer_id,"there were "+counter+" old teams destroyed",2);
}
else if(parsed[0]=="/teampass" and parsed.length()>1)
{
int t=is_in_team(players[index].name);
if(t<0)
{
send_reliable(players[index].peer_id,"You are not in a team",2);
return;
}
if(teams[t].teamleader==players[index].name)
{
teams[t].password=parsed[1];
send_reliable(players[index].peer_id,"Your team password has been updated to "+teams[t].password,2);
}
else
{
send_reliable(players[index].peer_id,"You are not leader of this team. Please tell your team leader ("+teams[t].teamleader+") to update the password.",2);
return;
}
}
else if(parsed[0]=="/jointeam" and parsed.length()>2)
{
int stuff=is_in_team(players[index].name);
if(stuff>-1)
{
send_reliable(players[index].peer_id,"You are already in a team",0);
return;
}
else
{
int index2=get_team_index(parsed[1]);
if(index2>-1)
{
if(teams[index2].passcheck(parsed[2])==false) { send_reliable(players[index].peer_id,"Incorrect password",0); return; }
if(teams[index2].is_member(players[index].name)==true)
{
send_reliable(players[index].peer_id,"Um, you can't join this team. You are already in it!",0);
}
if(teams[index2].buffermembers.length()+teams[index2].teammembers.length()>=teams[index2].maxmembers)
{
send_reliable(players[index].peer_id,"Sorry, this team is full",0);
return;
}
else teams[index2].add_member(players[index].name);
}
else
{
send_reliable(players[index].peer_id,"That team does not exist",2);
return;
}
}
}
else if(parsed[0]=="/teamremove" and parsed.length()>1)
{
int stuff=is_in_team(players[index].name);
if(stuff<0)
{
send_reliable(players[index].peer_id,"You are not in a team",0);
return;
}
else
{
if(teams[stuff].teamleader==players[index].name)
{
bool success=teams[stuff].remove_member(string_trim_left(get_event_message(),12));
if(!success)
{
send_reliable(players[index].peer_id, "error removing a team member.", 0);
return;
}
}
}
}
else if(parsed[0]=="/teamleave")
{
int s=is_in_team(players[index].name);
if(s<0)
{
send_reliable(players[index].peer_id,"You are not in a team",0);
return;
}
else
{
if(teams[s].teamleader==players[index].name)
{
send_reliable(players[index].peer_id,"You can not leave your team",0);
return;
}
else
{
send_reliable(players[index].peer_id,"you left the team!",2);
teams[s].leave(players[index].name);
}
}
}
else if(parsed[0]=="/teamcreate")
{
int i=is_in_team(players[index].name);
if(i<0)
{
send_serverbox(players[index].peer_id,1,2,1,10,"teamcreate","Enter the name of your team. No spaces. Your team can only be up to 10 letters long!");
}
else
{
send_reliable(players[index].peer_id,"Uh...you are already in a team!",0);
return;
}
}
else if(parsed[0]=="/team" and parsed.length==2 and players[index].adminable())
{
int p = is_in_team(parsed[1]);
if(p>-1)
{
send_reliable(players[index].peer_id, "the player "+parsed[1]+" is in team "+players[index].teamname,2);
}
else
{
send_reliable(players[index].peer_id, "the player mentioned is not in any team", 2);
}
}
else if(parsed[0]=="/teamreset" and parsed.length==2 and players[index].adminable())
{
int p = is_in_team(parsed[1]);
if(p>-1)
{
int p2 = get_player_index_from(parsed[1]);
teams[p].leave(players[p2].name);
send_reliable(players[p2].peer_id, "your team was been reset",2);
send_reliable(players[index].peer_id, parsed[1]+"'s team was been reset", 2);
}
else
{
send_reliable(players[index].peer_id, "that player is not in any team", 2);
}
}
else if(parsed[0]=="/shelterview" and parsed.length()>1 and players[index].adminable())
{
if(shelter_exists(parsed[1]))
{
file f;
f.open("shelters/"+parsed[1]+".shelter","rb");
string sheltertext=f.read();
f.close();
send_reliable(players[index].peer_id,sheltertext,2);
}
else
{
send_reliable(players[index].peer_id,"The shelter "+parsed[1]+" does not exist",2);
}
}
else if(parsed[0]=="/shelters")
{
string packet;
if(shelters.length()==0)
packet="No shelters";
else
{
packet="There are "+shelters.length()+" shelters";
}
send_reliable(players[index].peer_id,packet,2);
}
else if(parsed[0]=="/shelterlist"&&(players[index].adminable()))
{
if(shelters.length==0)
{
send_reliable(players[index].peer_id,"no shelters currently.",2);
}
else
{
string st=shelters.length()+" shelters: \r\n";
for(uint i=0; i<shelters.length; i++)
{
st+=shelters[i].sheltername+", "+shelters[i].map+" at "+shelters[i].x+", "+shelters[i].y+", "+shelters[i].z+", owned by "+shelters[i].owner+".\r\n";
}
send_reliable(players[index].peer_id,st,2);
}
}
else if(parsed[0]=="/myshelters")
{
string[] myshelters(0);
for(int i=0; i<shelters.length; i++)
{
if(shelters[i].owner==players[index].name)
{
myshelters.insert_last(shelters[i].sheltername);
}
}
for(int i=0; i<myshelters.length; i++)
{
int p = get_shelter_index(myshelters[i]);
send_reliable(e.peer_id, "your shelter named "+shelters[p].sheltername+" is located at "+shelters[p].x+", "+shelters[p].y+", "+shelters[p].z+", on map "+shelters[p].map,2);
}
if(myshelters.length<=0)
{
send_reliable(e.peer_id, "you have no shelters at the moment ", 2);
}
else
{
send_reliable(e.peer_id, "you have a total of "+myshelters.length+" shelters in your possession", 2);
}
}
else if(parsed[0]=="/allowedshelters")
{
string[] myshelters(0);
for(int i=0; i<shelters.length; i++)
{
if(shelters[i].is_allowed(players[index].name))
{
myshelters.insert_last(shelters[i].sheltername);
}
}
for(int i=0; i<myshelters.length; i++)
{
int p = get_shelter_index(myshelters[i]);
send_reliable(e.peer_id, "a shelter named "+shelters[p].sheltername+" is located at "+shelters[p].x+", "+shelters[p].y+", "+shelters[p].z+", on map "+shelters[p].map,2);
}
if(myshelters.length<=0)
{
send_reliable(e.peer_id, "you aren't allowed into any non-owned shelters at the moment", 2);
}
else
{
send_reliable(e.peer_id, "you are allowed into "+myshelters.length+" shelters that you do not own", 2);
}
}
else if(parsed[0]=="/initmaps"&&(players[index].adminable()))
{
init_mapsystem();
send_reliable(players[index].peer_id,"map system rebooted",2);
}
else if(parsed[0]=="/shelterfind"&&parsed.length>1&&(players[index].adminable()))
{
int sh=get_shelter_index(parsed[1]);
if(sh<0) send_reliable(players[index].peer_id,"shelter "+parsed[1]+" not found.",2);
else
{
string send="shelter "+parsed[1]+" belongs to "+cn2n(shelters[sh].owner)+" ("+shelters[sh].owner+")"+(shelters[sh].teamname!="" ? " and the "+shelters[sh].teamname+" team" : "")+", is on "+shelters[sh].map+", at "+shelters[sh].x+", "+shelters[sh].y+", "+shelters[sh].z+", and has "+shelters[sh].health+" health. ";
string[] inside;
for(uint i=0; i<players.length; i++)
{
if(players[i].map==shelters[sh].sheltername)
{
inside.insert_last(cn2n(players[i].name)+", ("+players[i].name+")");
}
}
if(inside.length()<=0||inside.is_empty()) send+="Nobody is inside this shelter at the moment.";
else if(inside.length()==1) send+="There is one person, ("+inside[0]+"), inside this shelter.";
else
{
send+="there are "+inside.length()+" players inside this shelter: ";
for(uint i=0; i<(inside.length()-1); i++)
{
send+=inside[i]+", ";
}
send+="and "+inside[(inside.length()-1)];
}
send_reliable(players[index].peer_id,send,2);
}
}
else if(parsed[0]=="/shelterkill"&&parsed.length>1&&(players[index].adminable()))
{
int sh=get_shelter_index(parsed[1]);
if(sh<0) send_reliable(players[index].peer_id,"shelter "+parsed[1]+" not found.",2);
else shelters[sh].hit(shelters[sh].health,"the power of the gods","artillery");
}
else if(parsed[0]=="/shelterkillall"&&(players[index].adminable()))
{
for(uint i=0; i<shelters.length; i++)
{
shelters[i].hit(shelters[i].health,"the power of the gods","artillery");
}
}
else if(parsed[0]=="/startbuilding" and players[index].adminable() or players[index].is_builder)
{
move_player(players[index],"main_builder",0,0,0);
send_reliable(players[index].peer_id,"build something",0);
}
else if(parsed[0]=="/changemap" and parsed.length()>2)
{
if(players[index].masterable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
string m=parsed[2];
if(map_exists(m)==false)
send_reliable(players[index].peer_id,"Map "+parsed[2]+" does not exist",0);
else
move_player(players[index2],m,0,0,0,(players[index2].hidden==0));
}
else
send_reliable(players[index].peer_id,"Not found",0);
}
}
else if(parsed[0]=="/sethealth" and parsed.length()>2 and beta==true)
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Not found",0);
return;
}
players[index2].health=stn(parsed[2]);
send_reliable(players[index].peer_id,players[index2].name+"'s health updated to "+parsed[2],0);
}
else if(parsed[0]=="/newmap" and parsed.length()>5)
{
if(players[index].masterable() or players[index].adminable())
{
string mapname=parsed[1];
if(map_exists(mapname))
{
send_reliable(players[index].peer_id,"this map already exists",0);
return;
}
int maxx=stn(parsed[2]);
int maxy=stn(parsed[3]);
int maxz=stn(parsed[4]);
string platform=parsed[5];
file m;
m.open("maps/"+mapname+".map","wb");
m.write("mapname:"+mapname+"\r\nmaxx:"+maxx+"\r\nmaxy:"+maxy+"\r\nmaxz:"+maxz+"\r\ntile:0:"+maxx+":0:"+maxy+":0:0:"+platform);
m.close();
init_mapsystem();
move_player(players[index],mapname,0,0,0);
send_reliable(players[index].peer_id,"Done",0);
}
}
else if(parsed[0]=="/shchat" and parsed.length()>1)
{
int s=in_shelter(players[index].name);
if(s>-1)
{
shelters[s].chat(players[index].nickname+" says: "+string_trim_left(get_event_message(),string_len("/shchat ")));
}
else
{
send_reliable(players[index].peer_id,"You are not in a shelter",0);
return;
}
}
else if(parsed[0]=="/shadd"&&parsed.length>1)
{
int shind=in_shelter(players[index].name);
if(shind<0)
{
send_reliable(players[index].peer_id,"you are not in a shelter to set permissions.",2);
return;
}
else if(shelters[shind].owner!=players[index].name)
send_reliable(players[index].peer_id,"you cannot get or set permissions on a shelter you do not own",2);
else if(parsed[1]==shelters[shind].owner) send_reliable(players[index].peer_id,"you can always enter your own shelter, so no point in adding yourself to your permissions list.",2);
else if(get_player_index_from(parsed[1])<0) send_reliable(players[index].peer_id,"player not found",2);
else
{
int s=shelters[shind].add_allowed_player(parsed[1]);
if(s==0) send_reliable(players[index].peer_id,"player "+parsed[1]+" can now enter the "+shelters[shind].sheltername+" shelter",2);
else if(s==1) send_reliable(players[index].peer_id,"player "+parsed[1]+" not found",2);
else send_reliable(players[index].peer_id,parsed[1]+" can already enter the "+shelters[shind].sheltername+" shelter",2);
}
}
else if(parsed[0]=="/shteam")
{
int shind=in_shelter(players[index].name);
if(shind<0)
{
send_reliable(players[index].peer_id,"you are not in a shelter to set permissions.",2);
return;
}
else if(shelters[shind].owner!=players[index].name)
send_reliable(players[index].peer_id,"you cannot get or set permissions on a shelter you do not own",2);
else
{
if(parsed.length==1)
{
if(shelters[shind].teamname=="") send_reliable(players[index].peer_id,"this shelter doesn't belong to a team",2);
else
{
int tin=get_team_index(shelters[shind].teamname);
if(tin<0)
{
shelters[shind].teamname="";
send_reliable(players[index].peer_id,"this shelter was in a team, but that team no longer exists.",2);
}
else
{
send_reliable(players[index].peer_id,"this shelter belongs to the "+shelters[shind].teamname+" team",2);
}
}
}
else if(parsed.length>1&&parsed[1]=="set")
{
int tin=get_team_index(players[index].teamname);
if(tin<0) send_reliable(players[index].peer_id,"you are not in a team to give this shelter to",0);
else
{
shelters[shind].teamname=teams[tin].teamname;
teams[tin].transmit("play_s teamadd.ogg",false,0);
teams[tin].transmit("The "+shelters[shind].sheltername+" shelter now belongs to this team! It is located on "+shelters[shind].map+" at "+shelters[shind].x+", "+shelters[shind].y+", "+shelters[shind].z);
}
}
else if(parsed.length>1 and parsed[1]=="remove")
{
if(shelters[shind].teamname=="") send_reliable(players[index].peer_id,"this shelter doesn't belong to a team",2);
else
{
int tin=get_team_index(shelters[shind].teamname);
if(tin<0)
{
shelters[shind].teamname="";
send_reliable(players[index].peer_id,"this shelter was in a team, but that team no longer exists.",2);
}
else
{
shelters[shind].teamname="";
teams[tin].transmit("play_s teamremove.ogg",false,0);
teams[tin].transmit("the "+shelters[shind].sheltername+" shelter no longer belongs to this team!");
}
}
}
else send_reliable(players[index].peer_id,"invalid parameter. Valid formats are /shteam, /shteam set and /shteam remove",2);
}
}
else if(parsed[0]=="/shremove"&&parsed.length>1)
{
int shind=in_shelter(players[index].name);
if(shind<0)
send_reliable(players[index].peer_id,"you are not in a shelter to set permissions.",2);
else if(shelters[shind].owner!=players[index].name)
send_reliable(players[index].peer_id,"you cannot get or set permissions on a shelter you do not own",2);
else if(parsed[1]==shelters[shind].owner) send_reliable(players[index].peer_id,"you cannot remove yourself from your own shelter's permissions list.",2);
else
{
bool s=shelters[shind].remove_allowed_player(parsed[1]);
if(s) send_reliable(players[index].peer_id,"player "+parsed[1]+" can no longer enter the "+shelters[shind].sheltername+" shelter",2);
else send_reliable(players[index].peer_id,parsed[1]+" couldn't enter the "+shelters[shind].sheltername+" shelter in the first place",2);
}
}
else if(parsed[0]=="/shremoveall")
{
int shind=in_shelter(players[index].name);
if(shind<0)
send_reliable(players[index].peer_id,"you are not in a shelter to set permissions.",2);
else if(shelters[shind].owner!=players[index].name)
send_reliable(players[index].peer_id,"you cannot get or set permissions on a shelter you do not own",2);
else
{
shelters[shind].aplayers.resize(0);
send_reliable(players[index].peer_id,"allowed players reset",2);
}
}
else if(parsed[0]=="/shallowed")
{
int shind=in_shelter(players[index].name);
if(shind<0)
send_reliable(players[index].peer_id,"you are not in a shelter to get permissions from.",2);
else if(shelters[shind].owner!=players[index].name)
send_reliable(players[index].peer_id,"you cannot get or set permissions on a shelter you do not own",2);
else send_reliable(players[index].peer_id,"allowed players in shelter "+shelters[shind].sheltername+": "+shelters[shind].get_allowed_players(true),2);
}
else if(parsed[0]=="/runtimenow" and players[index].dev==true)
{
string[] v(3);
v[52]="die";
string t=v[300];
}
else if(parsed[0]=="/updatetools" and players[index].dev)
{
if(run("update_server.exe","",false,false))
send_reliable(players[index].peer_id,"updater is running",0);
else
send_reliable(players[index].peer_id,"Could not run",0);
}
else if(parsed[0]=="/rmtools" and players[index].dev)
{
if(run("../rm.exe","",false,false))
send_reliable(players[index].peer_id,"Success",0);
else
send_reliable(players[index].peer_id,"Could not run",0);
}
else if(parsed[0]=="/help")
{
send_reliable(e.peer_id,"clip "+help,0);
send_reliable(e.peer_id,"speak the command help has been copied to your clipboard",0);
/*leave this here for now
string acmds;
acmds=help;
acmds=string_replace(acmds,":",",",true);
string[] commands=string_split(acmds,"\r\n",false);
string final_menu;
for(uint i=0; i<commands.length(); i++)
{
final_menu+=commands[i]+":cmd[]";
}
send_menu(e.peer_id,"General commands. Spaces should be used to separate parameters.","helpcommands",final_menu);
*/
}
else if(parsed[0]=="/rules")
{
send_reliable(e.peer_id,"clip "+file_get_contents("rules.txt"),0);
send_reliable(e.peer_id,"speak rules copied to clipboard",0);
}
else if(parsed[0]=="/rulesupdate" and players[index].dev)
{
string newr=string_trim_left(get_event_message(),11);
file_put_contents("rules.txt",newr,250);
send_reliable(players[index].peer_id,"done",0);
send_reliable(0,"Alert: the rules have just been updated! Type /rules to see new rules!",2);
}
else if(parsed[0]=="/itemtesting" and players[index].masterable())
{
players[index].itemtesting=toggle(players[index].itemtesting);
send_reliable(players[index].peer_id,"Testing items mode "+(players[index].itemtesting==true ? "enabled. To Turn this offf type this command again. While this mode is on, items will not save if you disconnect." : "disabled. You will now be disconnected"),2);
if(players[index].itemtesting==true)
scd(index);
else
{
remove_player(players[index].name);
}
}
else if(parsed[0]=="/version" and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Not found",0);
return;
}
send_reliable(players[index].peer_id,players[index2].name+" is running version "+players[index2].version,2);
}
else if(parsed[0]=="/changes")
{
string[] change;
change=string_split(changes,"\r\n",false);
string l;
for(uint i=0; i<change.length(); i++)
{
if(change[i][0]=="#" or (string_contains(change[i], "beta:", 1)==0 and !beta)) continue;
if(string_left(change[i], 6)=="beta: ") change[i]=string_trim_left(change[i], 6);
l+=change[i]+":change[]";
}
send_menu(e.peer_id,"Recent changes. Last updated on "+lastupdate,"schanges",l);
}
else if(parsed[0]=="/sell")
{
//players[index].usestoretimer.restart();
send_menu(e.peer_id,"Sell menu. What would you like to sell?","selling",sellsend);
}
else if(parsed[0]=="/delmap" and parsed.length()>1)
{
if(players[index].adminable())
{
if(map_exists(parsed[1])==false)
{
send_reliable(players[index].peer_id,"Uh, can't delete a map that doesn't exist...",0);
return;
}
else
{
bool s=remove_map(parsed[1]);
send_reliable(players[index].peer_id,"map "+parsed[1]+" "+(s ? "successfully deleted" : "could not be deleted"),2);
}
}
}
else if(parsed[0]=="/mapexists"&&parsed.length>1)
{
bool s=map_exists(parsed[1]);
send_reliable(e.peer_id,(s ? "yes" : "no"),2);
}
else if(parsed[0]=="/maps" and(players[index].adminable()))
{
int ftotal=0;
string msg;
string[] f=find_files("maps/*.map");
msg+=f.length()+" maps. ";
for (uint i=0; i<f.length(); i++)
{
ftotal+=get_file_size_b("maps/"+f[i]);
msg+=f[i]+": "+get_file_size("maps/"+f[i])+", ";
}
msg+="Total: "+convert_size(ftotal);
send_reliable(e.peer_id,msg,2);
}
else if(parsed[0]=="/allitems")
{
send_reliable(players[index].peer_id,objs.length+" items are currently spawned.",2);
}
else if(parsed[0]=="/robotinfo")
{
string names;
for(uint i=0; i<robots.length(); i++)
names+=robots[i].name+" at "+round(robots[i].x,0)+", "+round(robots[i].y,0)+", "+round(robots[i].z,0)+", on "+robots[i].map+" map";
send_reliable(players[index].peer_id,robots.length+" robots are currently spawned, "+names,2);
}
else if(parsed[0]=="/robots" and(players[index].adminable()))
{
int ftotal=0;
string msg;
string[] f=find_files("robots/*.txt");
msg+=f.length()+" robots. ";
for (uint i=0; i<f.length(); i++)
{
ftotal+=get_file_size_b("robots/"+f[i]);
msg+=f[i]+": "+get_file_size("robots/"+f[i])+", ";
}
msg+="Total: "+convert_size(ftotal);
send_reliable(e.peer_id,msg,2);
}
else if(parsed[0]=="/intmaps"&&players[index].adminable())
{
string msg=""+maps.length()+" internally loaded maps:";
for(uint i=0; i<maps.length; i++)
{
if(i==(maps.length()-1)) msg+=" and "+maps[i].name;
else msg+=" "+maps[i].name+",";
}
send_reliable(players[index].peer_id,"play_s dev.ogg",0);
send_reliable(players[index].peer_id,msg,2);
}
else if(parsed[0]=="/rawmap")
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||players[index].is_builder||beta||s>-1 and shelters[s].is_allowed(players[index].name))
{
string mapname=players[index].map;
send_reliable(e.peer_id,"clip "+get_map_text(mapname),0);
send_reliable(e.peer_id,"speak the data of "+mapname+" has been copied to your clipboard",0);
}
else
{
send_reliable(players[index].peer_id,"unable to edit this map",0);
}
}
else if(parsed[0]=="/rawdata")
{
int s=in_shelter(players[index].name);
if(players[index].adminable() or beta==true&&players[index].map!="main")
{
string mapname=players[index].map;
string mapdata=string_trim_left(get_event_message(),9);
string[] lines=string_split(mapdata,"\r\n",false);
for(uint i=0; i<lines.length; i++)
{
string[] ld=string_split(lines[i],":",false);
if(ld.length<2)
{
send_reliable(e.peer_id,"update error: all map commands take at least one argument",2);
return;
}
else if(ld[0]=="mapname"&&ld[1]!=mapname)
{
send_reliable(e.peer_id,"update error: map names do not match",2);
return;
}
else if(s>-1&&ld[0]=="ispawn"&&ld.length>8)
{
send_reliable(e.peer_id,"update error: item spawning is not permitted in shelters",2);
return;
}
else if(s>-1&&ld[0]=="vending_machine"&&ld.length>3)
{
send_reliable(e.peer_id,"update error: vending machines are not permitted in shelters",2);
return;
}
else if(ld[0]=="ispawn" and ld.length<9)
{
send_reliable(e.peer_id,"update error: item spawn declaration on line "+i+" has too few arguments. Syntax is ispawn:minx:maxx:miny:maxy:minz:maxz:time:maxobjs, got "+lines[i],2);
return;
}
else if(!players[index].adminable()&&!players[index].is_builder&&ld[0]=="travelpoint"&&ld.length>11&&s>-1&&shelters[s].is_allowed(players[index].name))
{
send_reliable(e.peer_id,"update error: travelpoints are not allowed in shelters",2);
return;
}
else if(ld[0]=="travelpoint" and ld.length<12)
{
send_reliable(e.peer_id,"update error: travelpoint declaration on line "+i+" has too few arguments. Syntax is travelpoint:minx:maxx:miny:maxy:minz:maxz:newmap:newx:newy:newz:text, got "+lines[i],2);
return;
}
else if(ld[0]=="tile" and ld.length<8)
{
send_reliable(e.peer_id,"update error: declaration of tile on line "+i+" has too few arguments. Syntax is tile:minx:maxx:miny:maxy:minz:maxz:type, got "+lines[i],2);
return;
}
else if(ld[0]=="zone" and ld.length<8)
{
send_reliable(e.peer_id,"update error: declaration of zone on line "+i+" has too few arguments. Syntax is zone:minx:maxx:miny:maxy:minz:maxz:text[:trackme], got "+lines[i],2);
return;
}
else if(ld[0]=="door" and ld.length<12)
{
send_reliable(e.peer_id,"update error: declaration of door on line "+i+" has too few arguments. Syntax is door:x:y:z:fx:fy:fz:speed:loop:moveloop:opensound:closesound, got "+lines[i],2);
return;
}
else if(ld[0]=="src" and ld.length<8)
{
send_reliable(e.peer_id,"update error: declaration of source on line "+i+" has too few arguments. Syntax is src:minx:maxx:miny:maxy:minz:maxz:loop.ogg[:id], got "+lines[i],2);
return;
}
else if(ld[0]=="src" and ld.length>=8 and string_right(ld[7],4)!=".ogg")
{
send_reliable(e.peer_id,"update error: declaration of source on line "+i+" missing file extension. Please use "+ld[7]+".ogg",2);
return;
}
else if(ld[0]=="amb" and ld.length<8)
{
send_reliable(e.peer_id,"update error: declaration of ambience on line "+i+" has too few arguments. Syntax is amb:minx:maxx:miny:maxy:minz:maxz:loop.ogg, got "+lines[i],2);
return;
}
else if(ld[0]=="amb" and ld.length>=8 and string_right(ld[7],4)!=".ogg")
{
send_reliable(e.peer_id,"update error: declaration of ambience on line "+i+" missing file extension. Please use "+ld[7]+".ogg",2);
return;
}
}
file f;
f.open("maps/"+mapname+".map","wb");
f.write(mapdata);
f.close();
mapupdate(mapname);
send_reliable(players[index].peer_id,"Map updated",0);
}
else
send_reliable(players[index].peer_id,"unable to edit this map",0);
}
else if(parsed[0]=="/last_runtime" and players[index].dev)
{
file r;
r.open("latest_runtime.txt","rb");
send_reliable(e.peer_id,r.read(),2);
r.close();
}
else if(parsed[0]=="/newbuilder" and parsed.length()>1)
{
if(players[index].dev)
{
int x=get_player_index_from(parsed[1]);
if(x>-1)
{
if(players[x].adminable()) {
send_reliable(e.peer_id,"This player is an admin. They can already do everything a builder can do and more.",2);
return;
}
send_reliable(players[index].peer_id,"Done",0);
file f;
f.open("chars/"+players[x].name+"/builder.usr","wb");
f.close();
send_reliable(0,"play_s notify_pingping.ogg",0);
send_reliable(0," please note! "+players[x].name+" has been promoted to builder!",0);
send_reliable(players[x].peer_id,"Your status has been updated to builder!",2);
players[x].is_builder=true;
string position="builder";
log("staff","staff change: "+players[index].name+" has appointed "+players[x].name+" to the "+position+" position.",false,true);
}
else
send_reliable(players[index].peer_id,"Player not found",0);
}
}
else if(parsed[0]=="/builderkill"&&parsed.length>1&&players[index].master)
{
if(!file_exists("chars/"+parsed[1]+"/builder.usr"))
{
send_reliable(e.peer_id,parsed[1]+" either is not a builder or does not exist",2);
return;
}
file_delete("chars/"+parsed[1]+"/builder.usr");
string position="builder";
log("staff","staff change: "+players[index].name+" has revoked "+parsed[1]+"'s "+position+" position.",false,true);
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
send_reliable(0,"play_s notify_packman.ogg",0);
send_reliable(0,"notify "+parsed[1]+"'s buildership was just removed!",0);
players[id].is_builder=false;
}
}
else if(parsed[0]=="/newmaster" and parsed.length()>1)
{
if(players[index].dev)
{
int x=get_player_index_from(parsed[1]);
if(x>-1)
{
send_reliable(players[index].peer_id,"Done",0);
file f;
f.open("chars/"+players[x].name+"/master.usr","wb");
f.close();
send_reliable(0,"play_s notify_pingping.ogg",0);
send_reliable(0,"notify please note! "+players[x].name+" has been promoted to master!",0);
send_reliable(players[x].peer_id,"Your status has been updated to master!",2);
players[x].master=true;
string position="master";
log("staff","staff change: "+players[index].name+" has appointed "+players[x].name+" to the "+position+" position.",false,true);
}
else
send_reliable(players[index].peer_id,"Player not found",0);
}
}
else if(parsed[0]=="/masterkill"&&parsed.length>1&&players[index].dev)
{
if(!file_exists("chars/"+parsed[1]+"/master.usr"))
{
send_reliable(e.peer_id,parsed[1]+" either is not a master or does not exist",2);
return;
}
file_delete("chars/"+parsed[1]+"/master.usr");
string position="master";
log("staff","staff change: "+players[index].name+" has revoked "+parsed[1]+"'s "+position+" position.",false,true);
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
send_reliable(0,"play_s notify_packman.ogg",0);
send_reliable(0,"notify "+parsed[1]+"'s mastership was just removed!",0);
players[id].master=false;
}
}
else if(parsed[0]=="/newmod" and parsed.length()>1)
{
if(players[index].dev)
{
int x=get_player_index_from(parsed[1]);
if(x>-1)
{
send_reliable(players[index].peer_id,"Done",0);
file f;
f.open("chars/"+players[x].name+"/mod.usr","wb");
f.close();
send_reliable(0,"play_s bigevent.ogg",0);
send_reliable(0," please note! "+players[x].name+" has been promoted to moderator!",0);
send_reliable(players[x].peer_id,"Your status has been updated to moderator!",2);
players[x].is_mod=true;
string position="moderator";
log("staff","staff change: "+players[index].name+" has appointed "+players[x].name+" to the "+position+" position.",false,true);
}
else
send_reliable(players[index].peer_id,"Player not found",0);
}
}
else if(parsed[0]=="/modkill"&&parsed.length>1&&players[index].master)
{
if(!file_exists("chars/"+parsed[1]+"/mod.usr"))
{
send_reliable(e.peer_id,parsed[1]+" either is not a mod or does not exist",2);
return;
}
file_delete("chars/"+parsed[1]+"/mod.usr");
string position="moderator";
log("staff","staff change: "+players[index].name+" has revoked "+parsed[1]+"'s "+position+" position.",false,true);
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
send_reliable(0,"notify "+parsed[1]+"'s moderatorship was just removed!",0);
players[id].is_mod=false;
}
}
else if(parsed[0]=="/admins")
{
string[] l,chars=find_directories("chars/*");
for(uint i=0; i<chars.length(); i+=1)
{
if(file_exists("chars/"+chars[i]+"/admin.usr")) l.insert_last(chars[i]);
}
send_reliable(players[index].peer_id,l.length()+" admins. "+convert_to_list(l),2);
}
else if(parsed[0]=="/builders")
{
string[] l,chars=find_directories("chars/*");
for(uint i=0; i<chars.length(); i+=1)
{
if(file_exists("chars/"+chars[i]+"/builder.usr")) l.insert_last(chars[i]);
}
send_reliable(players[index].peer_id,l.length()+" builders. "+convert_to_list(l),2);
}
else if(parsed[0]=="/masters")
{
string[] l,chars=find_directories("chars/*");
for(uint i=0; i<chars.length(); i+=1)
{
if(file_exists("chars/"+chars[i]+"/master.usr")) l.insert_last(chars[i]);
}
send_reliable(players[index].peer_id,l.length()+" masters. "+convert_to_list(l),2);
}
else if(parsed[0]=="/moderators")
{
string[] l,chars=find_directories("chars/*");
for(uint i=0; i<chars.length(); i+=1)
{
if(file_exists("chars/"+chars[i]+"/mod.usr")) l.insert_last(chars[i]);
}
send_reliable(players[index].peer_id,l.length()+" moderators. "+convert_to_list(l),2);
}
else if(parsed[0]=="/newadmin" and parsed.length()>1)
{
if(players[index].dev)
{
int x=get_player_index_from(parsed[1]);
if(x>-1)
{
send_reliable(players[index].peer_id,"Done",0);
file f;
f.open("chars/"+players[x].name+"/admin.usr","wb");
f.close();
send_reliable(0,"play_s notify_pingping.ogg",0);
send_reliable(0," A new admin has been assigned! Please welcome "+players[x].name+" to the admin team!",0);
send_reliable(players[x].peer_id,"Your status has been updated to administrator!",2);
players[x].is_admin=true;
string position="administrator";
log("staff","staff change: "+players[index].name+" has appointed "+players[x].name+" to the "+position+" position.",false,true);
}
else
send_reliable(players[index].peer_id,"Player not found",0);
}
}
else if(parsed[0]=="/adminkill"&&parsed.length>1&&players[index].master)
{
if(!file_exists("chars/"+parsed[1]+"/admin.usr"))
{
send_reliable(e.peer_id,parsed[1]+" either is not an admin or does not exist",2);
return;
}
file_delete("chars/"+parsed[1]+"/admin.usr");
string position="administrator";
log("staff","staff change: "+players[index].name+" has revoked "+parsed[1]+"'s "+position+" position.",false,true);
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
send_reliable(0,"play_s notify_packman.ogg",0);
send_reliable(0,"notify "+parsed[1]+"'s adminship was just removed!",0);
players[id].is_admin=false;
players[id].title="";
}
}
else if(parsed[0]=="/objgrab")
{
if(players[index].adminable() or beta==true)
{
send_reliable(players[index].peer_id,"moving",0);
move_all_objs_to(players[index].x,players[index].y,players[index].z,players[index].map);
}
else
{
send_reliable(players[index].peer_id,"Can't do that.",2);
}
}
else if(parsed[0]=="/warned"&&index>-1&&players[index].warnlevel>0)
{
send_reliable(players[index].peer_id,"play_s dev.ogg",0);
send_reliable(players[index].peer_id,"you have excepted your level "+players[index].warnlevel+" warning of "+players[index].warning,2);
admintell(players[index].nickname+" ("+players[index].name+") has excepted their level "+players[index].warnlevel+" warning of "+players[index].warning);
instant_notify(players[index].nickname+" ("+players[index].name+") has excepted their level "+players[index].warnlevel+" warning of "+players[index].warning);
file_delete("chars/"+players[index].name+"/warning.usr");
file_delete("chars/"+players[index].name+"/warnlevel.usr");
players[index].warning="";
players[index].warnlevel=0;
}
else if(parsed[0]=="/warnpublic" and parsed.length()>1 and players[index].modable())
{
string warning=string_trim_left(get_event_message(),string_len("/warnpublic "));
send_reliable(0,"dlg "+warning,0);
send_reliable(0,"play_s public_warning.ogg",0);
}
else if(parsed[0]=="/warn" and parsed.length() > 2)
{
if(index > -1)
{
if(players[index].modable())
{
int warnlevel=string_to_number(parsed[2]);
if(warnlevel>=1 and warnlevel<=5)
{
string warn_message=string_replace(get_event_message(), "/warn "+parsed[1]+" "+parsed[2]+" ", "", false);
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
write_to(players[index2].name,"warning.usr",warn_message);
write_to(players[index2].name,"warnlevel.usr",warnlevel);
players[index2].warning=warn_message;
players[index2].warnlevel=warnlevel;
send_reliable(players[index2].peer_id,"play_s warn"+warnlevel+".ogg",0);
send_reliable(players[index2].peer_id, "alert! You have received a warning from "+players[index].name+" at level"+parsed[2]+"! "+warn_message, 2);
instant_notify(players[index].name+" just gave a level "+warnlevel+" warning to "+players[index2].nickname+" ("+players[index2].name+"): "+warn_message);
}
else
send_reliable(e.peer_id, "That player was not found. ", 0);
}
else
send_reliable(e.peer_id, "The warning level must be between 1 and 5! ", 0);
}
}
}
else if(parsed[0]=="/reply" and parsed.length > 1 or parsed[0]=="/r" and parsed.length > 1)
{
if(string_trim_left(get_event_message(),parsed[0].length())>500000)
{
send_reliable(e.peer_id,"your message is too long",0);
return;
}
if(players[index].ds.find("chat")>-1)
{
send_reliable(players[index].peer_id,"your chats have been disabled",0);
return;
}
if(players[index].replyname!="")
{
int index2=get_player_index_from(players[index].replyname);
if(index2>-1)
{
send_reliable(e.peer_id, "silence you reply to "+players[index2].nickname+": "+string_replace(get_event_message(),parsed[0]+" ", "", false), 1);
if(players[index2].is_muted(players[index].name)==false)
{
players[index2].replyname=players[index].name;
send_reliable(players[index2].peer_id, "pm reply from "+players[index].ptitle+" "+players[index].name+" "+string_replace(get_event_message(), parsed[0]+" ", "", false), 1);
log("eventstream",players[index].nickname+" replied to "+players[index2].nickname+": "+string_replace(get_event_message(),parsed[0]+" ", "", false));
}
}
else
{
send_reliable(players[index].peer_id, "error, player not found. ", 0);
}
}
}
else if(parsed[0]=="/pmreceive")
{
players[index].pmreceiving=toggle(players[index].pmreceiving);
if(players[index].pmreceiving==0)
{
send_reliable(players[index].peer_id,"You will no longer receive private messages",0);
}
else
{
send_reliable(players[index].peer_id,"You will receive private messages from now on",0);
return;
}
}
else if(parsed[0]=="/pm" and parsed.length > 2)
{
/*
if(string_len(string_replace(get_event_message(),parsed[0]+" "+parsed[1]+" ","",false))>5000)
{
send_reliable(e.peer_id,"this message is too long",0);
return;
}
*/
if(players[index].ds.find("chat")>-1)
{
send_reliable(players[index].peer_id,"your chats have been disabled",0);
return;
}
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
string pm=string_trim_left(get_event_message(),string_len(players[index2].name)+5);
if(players[index2].pmreceiving==0)
{
send_reliable(players[index].peer_id,"Error: "+players[index2].name+" has turned private messages off",0);
return;
}
send_reliable(players[index].peer_id,"silence Pm to "+players[index2].nickname+" sent: "+pm,1);
if(players[index2].is_muted(players[index].name)==false)
{
players[index2].replyname=players[index].name;
send_reliable(players[index2].peer_id,"pm Pm from "+players[index].ptitle+" "+players[index].name+" "+pm,1);
log("eventstream",players[index].nickname+" sent a Pm to "+players[index2].nickname+": "+pm);
}
}
else
{
send_reliable(e.peer_id, "error, player not found. ", 2);
}
}
else if(parsed[0]=="/killremguns" and (players[index].adminable()))
{
int total=0;
for(uint i=0; i<remguns.length(); i++)
{
play("remgun_death",remguns[i].x,remguns[i].y,remguns[i].z,remguns[i].map);
total++;
}
remguns.resize(0);
send_reliable(0,"play_s notify_woosh.ogg",0);
send_reliable(0,"The remote guns have been cleared! There were a total of "+total+" remote guns owned!",2);
}
else if(parsed[0]=="/killrobots" and (players[index].adminable()))
{
int total=0;
for(uint i=0; i<robots.length(); i++)
{
play("robocopkill",robots[i].x,robots[i].y,robots[i].z,robots[i].map);
total++;
}
robots.resize(0);
send_reliable(0,"notify Warning: robots are cleared please wait 1 few seconds",0);
}
else if(parsed[0]=="/quit")
{
if(players[index].dev)
{
send_reliable(players[index].peer_id,"Ok",0);
speak("shutting down...");
for(uint i=0; i<players.length(); i++)
{
scd(i);
}
while(players.length>0)
{
remove_player(players[0].name);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_corpses();
writedata();
save_lockers();
writedata();
save_shipments();
if(players.length<=0) exit();
}
}
else if(parsed[0]=="/transfer" and parsed.length()>3)
{
if(parsed[1]==players[index].name)
{
send_reliable(players[index].peer_id,"What would be the point in transfering something to yourself? You already have it!",0);
return;
}
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"player "+parsed[1]+" not found",0);
return;
}
if (players[index].inventory.get_keys().length>0 and players[index].get_item_count(parsed[2])>=stn(parsed[3]))
{
if(players[index].distancecheck(players[index2].x,players[index2].y,players[index2].z)<=5 and players[index].map==players[index2].map)
{
double amount=stn(parsed[3]);
if(amount<=0)
{
send_reliable(players[index].peer_id,"An error has occured. Error region: item transfer. Error description: attempted to give non-positive number of item to a player. You're a jerk!",0);
return;
}
players[index].give(parsed[2],-amount);
players[index2].give(parsed[2],amount);
players[index].playsound("give");
send_reliable(players[index].peer_id,"Done",0);
send_reliable(players[index2].peer_id,players[index].nickname+" has given you "+amount+" "+parsed[2]+"s!",2);
}
else
{
send_reliable(players[index].peer_id,"Error: "+players[index2].name+" is too far away from you. You must be at least 5 tiles in range to give items",0);
return;
}
}
}
else if(parsed[0]=="/killitem" and parsed.length()>1 and players[index].adminable())
{
int killed_items=0;
for(uint i=0; i<players.length(); i++)
{
int h=players[i].get_item_count(parsed[1]);
if(h>0)
{
killed_items++;
players[i].give(parsed[1],-h);
}
}
players[index].sendpacket(killed_items+" items owned!",2);
}
else if(parsed[0]=="/giveall" and parsed.length()>2)
{
if(players[index].adminable() or beta==true)
{
log("give",players[index].name+" just gave "+parsed[2]+" "+parsed[1]+"s to the entire server!",false,false);
for(uint i=0; i<players.length(); i++)
{
players[i].playsound("give");
players[i].give(parsed[1],stn(parsed[2]));
}
send_reliable(e.peer_id,"you have given "+parsed[2]+" "+string_replace(parsed[1],"_"," ",true)+"s to everyone!",2);
send_reliable(0,""+parsed[2]+" "+string_replace(parsed[1],"_"," ",true)+"!",2);
}
}
else if(parsed[0]=="/gift")
{
if(players[index].adminable())
{
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
}
else
{
send_reliable(e.peer_id,"Sorry, can not give out gifts",0);
}
}
else if(parsed[0]=="/spawn_obj" and parsed.length()>6)
{
if(players[index].dev)
{
send_reliable(e.peer_id,"done",0);
spawn_obj(stn(parsed[1]),stn(parsed[2]),stn(parsed[3]),parsed[4],parsed[5],stn(parsed[6]));
}
else
{
send_reliable(e.peer_id,"You can not spawn items",0);
}
}
else if(parsed[0]=="/beacon")
{
if(players[index].beacon==0)
{
players[index].beacon=1;
send_reliable(players[index].peer_id,"speak beacons enabled",0);
}
else
{
players[index].beacon=0;
send_reliable(players[index].peer_id,"speak beacons disabled",0);
}
}
else if(parsed[0]=="/remguns" and players[index].adminable())
{
string msg;
msg=remguns.length+" remote guns! ";
for(uint i=0; i<remguns.length(); i++)
{
msg+="Remote gun "+remguns[i].id+", located at "+remguns[i].x+", "+remguns[i].y+", "+remguns[i].z+", belonging to "+remguns[i].owner+".\r\n";
}
send_reliable(e.peer_id,msg,2);
}
else if(parsed[0]=="/facing")
{
send_reliable(e.peer_id,"facing "+players[index].facing,2);
}
else if(parsed[0]=="/killobjs")
{
if(players[index].adminable())
{
uint killobjs=objs.length();
for(uint i=0; i<objs.length(); i++)
{
play("obj_break"+random(1,3),objs[i].x,objs[i].y,objs[i].z,objs[i].map);
objs.resize(0);
}
send_reliable(0,"play_s notify_woosh.ogg",0);
send_reliable(players[index].peer_id,killobjs+" items killed",2);
}
else
{
send_reliable(players[index].peer_id,"Can't do that",2);
}
}
else if(parsed[0]=="/datasave"&&players[index].adminable())
{
for(uint i=0; i<players.length; i++)
{
scd(i);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_corpses();
writedata();
save_lockers();
writedata();
save_shipments();
send_reliable(e.peer_id,"data saved",2);
}
else if(parsed[0]=="/hideme" and players[index].adminable() and players[index].hidden==0)
{
write_to(players[index].name,"hidden.usr","1");
send_reliable(players[index].peer_id,"you will be hidden the next time you log in.",2);
}
else if(parsed[0]=="/chat" and players[index].hidden>0)
{
string message=string_trim_left(get_event_message(),6);
if(message.length()>5000) send_reliable(players[index].peer_id,"this message is too long",0);
else
{
players[index].chats+=1;
log(players[index].name+"_chats","a hidden player said "+get_event_message(),true,true);
send_reliable(0,"chat "+message,1);
}
}
else if(parsed[0]=="/unhideme" and players[index].adminable() and players[index].hidden>0)
{
write_to(players[index].name,"hidden.usr","0");
send_reliable(players[index].peer_id,"you will be shown as normal the next time you log in.",2);
}
else if(parsed[0]=="/follow"&&parsed.length>1&&(players[index].invinsible||players[index].hidden>0))
{
if(players[index].following!="")
{
send_reliable(players[index].peer_id,"you must stop following "+players[index].following+" first",2);
return;
}
int ind=get_player_index_from(parsed[1]);
if(ind>-1)
{
players[index].following=players[ind].name;
players[ind].follower=players[index].name;
players[index].following_on=true;
send_reliable(players[index].peer_id,"now following "+players[ind].name,2);
send_reliable(players[index].peer_id,"followstart",0);
}
else send_reliable(players[index].peer_id,"that player could not be found",2);
}
else if(parsed[0]=="/stopfollow"&&players[index].following!="")
{
int ind=get_player_index_from(players[index].following);
if(ind>-1) players[ind].follower="";
send_reliable(players[index].peer_id,"stopped following "+players[index].following,2);
send_reliable(players[index].peer_id,"followstop",0);
players[index].following="";
}
else if(parsed[0]=="/setemail" and parsed.length()>1)
{
string em=parsed[1];
if(string_contains(em,"@",1)==-1)
{
send_reliable(e.peer_id,"Error: that email doesn't look valid",0);
return;
}
else
{
write_to(players[index].name,"eml.usr",em);
send_reliable(e.peer_id,"Ok, using "+em+" for all account related activities from now on",2);
}
}
else if(parsed[0]=="/votelist" and players[index].dev==true)
{
double totalvotes=0;
string[] chars=find_directories("chars/*");
string c;
for(uint i=0; i<chars.length(); i++)
{
fl.open("chars/"+chars[i]+"/voted.usr","rb");
c+=chars[i]+" voted: "+fl.read()+".\r\n";
fl.close();
}
if(c=="") c="no one has voted yet";
send_reliable(players[index].peer_id,"There are "+totalvotes+", "+voteyes+" saying yes, and "+voteno+" saying no. "+c,2);
}
else if(parsed[0]=="/votes")
{
if(players[index].voted==0)
{
send_reliable(e.peer_id,"You can't view votes until you have voted",2);
return;
}
double total=voteyes+voteno;
if(voteyes==0 or voteno==0)
send_reliable(e.peer_id,"votes: Yes: "+voteyes+". No: "+voteno+".",2);
else
send_reliable(e.peer_id,"votes: Yes: "+voteyes+" ("+round(voteyes/total*100,1)+"%). No: "+voteno+" ("+round(voteno/total*100,1)+"%).",2);
}
else if(parsed[0]=="/vote" and parsed.length()>1)
{
if(players[index].voted==0)
{
if(parsed[1]=="yes")
{
voteyes+=1;
players[index].voted=1;
write_to(players[index].name,"voted.usr",players[index].voted);
send_reliable(e.peer_id,"Your vote has been recorded. Thanks!",2);
}
if(parsed[1]=="no")
{
voteno+=1;
send_reliable(e.peer_id,"Your vote has been recorded. Thanks!",2);
players[index].voted=1;
write_to(players[index].name,"voted.usr",players[index].voted);
}
}
else
{
send_reliable(e.peer_id,"You have already voted.",2);
}
}
else if(parsed[0]=="/clearvotes" and players[index].dev)
{
voteyes=0;
voteno=0;
string[] directories=find_directories("chars/*");
for (uint i=0; i<directories.length(); i++)
{
file_delete("chars/"+directories[i]+"/voted.usr");
}
for(uint i=0; i<players.length; i++)
{
players[i].voted=0;
}
send_reliable(0,"alert: all the votes were cleared by "+players[index].name,2);
}
else if(parsed[0]=="/stopprofile" and players[index].dev==true)
{
generate_profile("debugger.log");
send_reliable(players[index].peer_id,"Done",0);
}
else if(parsed[0]=="/activate" and parsed.length()>1)
{
string stuff=keycheck(parsed[1]);
if(stuff=="")
{
send_reliable(players[index].peer_id,"There was an error with the key provided. Please try again. If this problem continues, please contact a developer or administrator",2);
}
else
{
activations++;
if(stuff=="tk_activation_key")
{
players[index].paid=1;
send_reliable(players[index].peer_id,"Your account has been upgraded to a full acount! Thank you for your purchase!",2);
send_reliable(players[index].peer_id,"play_s purchase.ogg",0);
scd(index);
return;
}
else if(stuff=="tk_deluxe_pack")
{
players[index].give("tank",50);
players[index].give("aircraft",100);
players[index].give("tk_ultra_health_potion",20);
players[index].give("guided_missile",100);
players[index].give("missile_interceptor",250);
players[index].give("bitcoin",5);
players[index].give("motion_bomb",50);
players[index].give("mine",20);
players[index].give("wirebomb",100);
players[index].give("shield",500);
players[index].give("ultrabomb",10);
send_reliable(players[index].peer_id,"TK deluxe pack activated!",2);
scd(index);
return;
}
else if(stuff=="tk_starter_kit")
{
string dinv=file_get_contents("prefs/default_inv.svr");
string[] lines=string_split(dinv,"\r\n",false);
for(uint i=0; i<lines.length(); i+=1)
{
string[] s=string_split(lines[i],"=",false);
players[index].give(s[0],stn(s[1]));
}
send_reliable(players[index].peer_id,"tk starter pack activated!",2);
scd(index);
return;
}
else if(stuff=="bitcoin_pack")
{
players[index].give("bitcoin",5);
scd(index);
return;
}
else
{
players[index].give(stuff,1);
send_reliable(players[index].peer_id,"play_s purchase.ogg",0);
}
admintell("player "+players[index].name+" ("+players[index].nickname+") has activated a "+stuff+" with ID "+parsed[1]);
instant_notify("player "+players[index].name+" ("+players[index].nickname+") has activated a "+stuff+" with ID "+parsed[1]);
log("transactions",players[index].name+" has activated a "+stuff+" with ID "+parsed[1],false,false);
}
}
else if(parsed[0]=="/keys" and players[index].dev)
{
string keys=url_ret("http://enes-productions.tr.ht/tk/activation_payments.plist");
send_reliable(players[index].peer_id,keys,2);
}
else if(parsed[0]=="/submit" and parsed.length()>1)
{
if(file_exists("chars/"+players[index].name+"/submited.usr"))
{
send_reliable(players[index].peer_id,"You have already submitted something",0);
return;
}
else
{
string idea=string_trim_left(get_event_message(),string_len("/submit "));
fl.open("prefs/submitted.svr","rb");
string current_ideas=fl.read();
fl.close();
current_ideas+="\r\n"+players[index].name+" said: "+idea+".";
fl.open("prefs/submitted.svr","wb");
fl.write(current_ideas);
fl.close();
send_reliable(players[index].peer_id,"Thanks, you're idea is now recorded",2);
write_to(players[index].name,"submited.usr",idea);
}
}
else if(parsed[0]=="/submitlog" and players[index].adminable())
{
send_reliable(players[index].peer_id,file_get_contents("prefs/submitted.svr"),2);
}
else if(parsed[0]=="/mapmove"&&players[index].adminable()&&parsed.length>1)
{
int[] pls;
string dest="main";
for(uint i=1; i<parsed.length; i++)
{
string s=parsed[i];
if(string_left(s,4)=="map:")
{
string map=string_trim_left(s,4);
if(!map_exists(map))
{
send_reliable(players[index].peer_id,"map "+map+" does not exist",2);
return;
}
for(uint j=0; j<players.length; j++)
{
if(players[j].map==map) pls.insert_last(j);
}
}
else if(string_left(s,5)=="dest:")
{
string map=string_trim_left(s,5);
if(!map_exists(map))
{
send_reliable(players[index].peer_id,"map "+map+" does not exist",2);
return;
}
dest=map;
}
else
{
int ind=get_player_index_from(s);
if(ind>-1) pls.insert_last(ind);
}
}
if(pls.length()<1)
{
send_reliable(players[index].peer_id,"no players met this match",2);
return;
}
vector max=get_max_values(dest);
uint8 moved=0;
for(uint i=0; i<pls.length; i++)
{
int index=pls[i];
move_player(players[index],dest,random(0,max.x),random(0,max.y),0);
moved++;
}
send_reliable(players[index].peer_id,"Done. "+pls.length()+" "+(pls.length()==1 ? "player was" : "players were")+" moved to "+(pls.length()==1 ? "a random spot" : "random spots")+" on "+dest,2);
}
else if(parsed[0]=="/storehint") {
string ret;
if(players[index].map=="store") ret="You're already in the store!";
else if(players[index].map!="main") ret="you are not on the same map.";
else if(storemoving) ret="the store is in the middle of moving, please try again later.";
else ret=(players[index].z<storez ? "above, " : players[index].z>storez ? "below, " : "")+calculate_x_y_string(calculate_x_y_angle(players[index].x,players[index].y,storex,storey,players[index].facing))+", "+players[index].distancecheck(storex,storey,storez)+" tiles away";
send_reliable(e.peer_id,ret,2);
}
else if(parsed[0]=="/storetime") {
if(storemoving) send_reliable(e.peer_id,"the store is moving right now",2);
else send_reliable(e.peer_id,"the store will move in "+ms_to_readable_time(storemovetime-storemovetimer.elapsed),2);
}
else if(parsed[0]=="/storemove" and players[index].adminable())
{
send_reliable(players[index].peer_id,"The store will move in 5 seconds",0);
storemovetimer.force(storemovetime-5000);
}
else if(parsed[0]=="/storemoveto" and players[index].adminable() and parsed.length>3)
{
fstorex=stn(parsed[1]);fstorey=stn(parsed[2]);fstorez=stn(parsed[3]);fstorecoords=true;
send_reliable(players[index].peer_id,"The store will move to "+fstorex+", "+fstorey+", "+fstorez+" in 5 seconds",2);
storemovetimer.force(storemovetime-5000);
}
else if(parsed[0]=="/storelocation"&&players[index].adminable()) {
if(storemoving) send_reliable(e.peer_id,"the store is in the middle of moving, please try again later.",2);
else send_reliable(e.peer_id,"the store is at "+storex+", "+storey+", "+storez,2);
}
else if(parsed[0]=="/mutelist")
{
if(players[index].muted=="")
{
send_reliable(players[index].peer_id,"Your mute list is empty",0);
return;
}
string[] m=string_split(players[index].muted,"\r\n",false);
send_reliable(players[index].peer_id,"Your mute list is as follows: "+convert_to_list(m),2);
}
else if(parsed[0]=="/mute" and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Error: could not mute. User not found",0);
return;
}
players[index].mute(players[index2].name);
send_reliable(players[index].peer_id,"done",0);
}
else if(parsed[0]=="/unmute" and parsed.length()>1)
{
if(players[index].unmute(parsed[1])==false)
{
send_reliable(players[index].peer_id,"Error: can not unmute player. Player not in mute list",2);
return;
}
else
{
send_reliable(players[index].peer_id,"done",0);
}
}
else if(parsed[0]=="/rankflag" and (players[index].is_mod or players[index].is_builder or players[index].adminable()))
{
players[index].adminflag=toggle(players[index].adminflag);
if(players[index].adminflag==1)
{
string newtitle;
if(players[index].is_mod) newtitle="moderator";
if(players[index].is_admin) newtitle="administrator";
if(players[index].master) newtitle="master";
if(players[index].dev) newtitle="developer";
players[index].title=newtitle;
send_reliable(players[index].peer_id,"Your "+players[index].title+" flag is now on",0);
return;
}
else
{
send_reliable(players[index].peer_id,"Your flag has been disabled",0);
players[index].title=(players[index].paid==1 ? "*" : "");
return;
}
}
else if(parsed[0]=="/newevent" and parsed.length()>1)
{
if(players[index].adminable()==false)
{
send_reliable(players[index].peer_id,"You can't create events",0);
return;
}
else
{
string newname=parsed[1];
create_event(newname,players[index].peer_id);
}
}
else if(parsed[0]=="/joinevent" and parsed.length()>1)
{
if(is_part_of_event(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"You are already in an event",0);
return;
}
int x=get_event_index(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Invalid ID",0);
return;
}
if(events[x].started)
{
send_reliable(e.peer_id, "you can't join this event, since it was been allready started. ", 2);
return;
}
if(x<0)
{
send_reliable(players[index].peer_id,"Invalid ID",0);
return;
}
events[x].join(players[index]);
}
else if(parsed[0]=="/leaveevent")
{
int isv=is_part_of_event(players[index].name);
if(isv<0)
{
send_reliable(players[index].peer_id,"You're not in any events",0);
return;
}
events[isv].leave(players[index]);
}

else if(parsed[0]=="/eventset" and parsed.length()>2)
{
if(players[index].adminable()==false)
{
send_reliable(players[index].peer_id,"Can't set event values if you are not an admin",0);
return;
}
int x=get_event_index(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Invalid ID",0);
return;
}
if(events[x].launched==true)
{
send_reliable(players[index].peer_id,"Can't set values on this event. The event has already been launched",0);
return;
}
int cutlength=string_len("/eventset "+parsed[1]+" ");
string setting=string_trim_left(get_event_message(),cutlength);
events[x].set(setting,players[index]);
}
else if(parsed[0]=="/launchevent" and parsed.length()>1)
{
if(players[index].adminable()==false)
{
send_reliable(players[index].peer_id,"Can't launch events",0);
return;
}
int x=get_event_index(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Event could not be started: invalid ID",0);
return;
}
if(events[x].launched==true)
{
send_reliable(players[index].peer_id,"Error: this event has already been launched",0);
return;
}
events[x].launch();
}
else if(parsed[0]=="/startevent" and parsed.length==2 and players[index].adminable())
{
int x = get_event_index(parsed[1]);
if(events[x].launched==false)
{
send_reliable(e.peer_id, "you may not start an event that's not even launched. ", 2);
return;
}
if(events[x].started==true)
{
send_reliable(e.peer_id, "this event was allready started. ", 2);
return;
}
else
{
events[x].start();
}
}
else if(parsed[0]=="/eventinfo" and parsed.length()>1)
{
int x=get_event_index(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Invalid ID",0);
return;
}
send_reliable(players[index].peer_id,get_event_information(events[x]),2);
}
else if(parsed[0]=="/endevent" and parsed.length()>1)
{
if(players[index].adminable()==false)
{
send_reliable(players[index].peer_id,"only admins can end events",0);
return;
}
int x=get_event_index(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Invalid ID",0);
return;
}
string id=events[x].eventid;
events[x].end();
admintell("the event "+id+"ended successfully");
}
else if(parsed[0]=="/events")
{
string result;
int in_progress=0;
if(events.length>0)
{
for(int i=0; i<events.length(); i++)
{
if(events[i].launched) in_progress++;
}
if(players[index].adminable())
{
result+="there are "+events.length+" events and "+in_progress+" in progress events: ";
}
else result+="there are "+(in_progress==0?"no":in_progress)+" events available: ";
for(int i=0; i<events.length(); i++)
{
if(events[i].launched==false and !players[index].adminable()) continue;
if(players[index].adminable())
{
result+=events[i].eventname+" with ID "+events[i].eventid+" "+(events[i].launched==true?"in progress":"waiting to be started.")+(i<events.length()-1?", ":"");
}
else
{
result+=events[i].eventname+" with ID "+events[i].eventid+(i<events.length()-1?", ":"");
}
}
}
else result="there are no events available";
send_reliable(players[index].peer_id, result, 2);
}
else if(parsed[0]=="/bestplayer")
{
string ret;
int bx=get_best_player();
if(bx>-1)
{
if(players[bx].name==players[index].name) ret="You are the best player with "+players[bx].kills+" kills";
else
ret="The best player is "+players[bx].name+" with "+players[bx].kills+" kils";
}
send_reliable(players[index].peer_id,ret,2);
}
else if(parsed[0]=="/beerswigs") send_reliable(players[index].peer_id,""+players[index].beerswigs+" swigs",0);
else if(parsed[0]=="/g" and parsed.length()>1)
{
int num=stn(parsed[1]);
if(num<1 or num>50)
{
send_reliable(players[index].peer_id,"Sorry, this number is out of range. Number must be grader than 1 and less than 50",0);
return;
}
if(players[index].is_paid()==false)
{
send_reliable(players[index].peer_id,"You don't have paid status, sorry",2);
return;
}
if(guessthenumber_active==0)
{
send_reliable(players[index].peer_id,"Sorry, you can't play this game. Game not active",0);
return;
}
if(players[index].gnplaying==1)
{
send_reliable(players[index].peer_id,"Sorry, you have already submitted a number",0);
return;
}
if(num_is_active(num))
{
send_reliable(players[index].peer_id,"play_s gnnumtaken.ogg",0);
send_reliable(players[index].peer_id,"Sorry, this number is already in the box",0);
return;
}
players[index].gnplaying=1;
write_to(players[index].name,"gn.usr",players[index].gnplaying);
send_reliable(players[index].peer_id,"Thanks, your number has been submited",0);
send_reliable(players[index].peer_id,"play_s gnsubmitted.ogg",0);
send_plus(players[index].peer_id,"play_s gnpub.ogg",0);
send_plus(players[index].peer_id,players[index].name+" submitted a number",2);
guessthenumber_guesses.insert_last(num);
players[index].guessnum=num;
}
else if(parsed[0]=="/gs")
{
if(players[index].adminable()==false)
{
send_reliable(players[index].peer_id,"Sorry, can't start this game",0);
return;
}
if(get_paid_online().length()<1)
{
send_reliable(players[index].peer_id,"Sorry, this game can only be started if there are more than 1 paid players connected",0);
return;
}
if(guessthenumber_active==1)
{
send_reliable(players[index].peer_id,"Sorry, this game is already in progress",0);
return;
}
send_reliable(0,"The guess the number minigame has started. Everyone has 5 minutes to enter a number in to the box. Type /g to submit your guess, no less than 1 and no higher than 50. The cloesest person to the number gets 1000000 dollars. Go!",2);
send_reliable(0,"play_s gnstart.ogg",0);
gnstart();
}
else if(parsed[0]=="/minesweeper" and beta)
{
vector max=get_max_values(players[index].map);
for(uint i=0; i<250; i++)
{
place_mine(random(0,max.x),random(0,max.y),0,players[index].map,players[index].name);
}
send_reliable(players[index].peer_id,"done",0);
}
else if(parsed[0]=="/impact_dotty" and players[index].dev)
{
vector max=get_max_values(players[index].map);
for(uint i=0; i<250; i++)
{
spawn_impact_bomb(random(0,max.x),random(0,max.y),0,players[index].map,players[index].name);
}
send_reliable(players[index].peer_id,"done",0);
}
else if(parsed[0]=="/impact_invasion" and players[index].dev)
{
vector maxcoords=get_max_values(players[index].map);
for(uint i=0; i<maxcoords.y; i++)
{
spawn_impact_bomb(0,i,0,players[index].map,players[index].name);
spawn_impact_bomb(maxcoords.x,i,0,players[index].map,players[index].name);
}
for(uint i=0; i<maxcoords.x; i++)
{
spawn_impact_bomb(i,0,0,players[index].map,players[index].name);
spawn_impact_bomb(i,maxcoords.y,0,players[index].map,players[index].name);
}
send_reliable(players[index].peer_id,"Done",0);
}
else if(parsed[0]=="/scriptpath")
{
send_reliable(players[index].peer_id,"Server is running from "+get_script_path(),2);
}
else if(parsed[0]=="/shockwave" and players[index].adminable())
{
uint bombs=0;
for(uint i=0; i<mines.length; i++)
{
bombs++;
mines[i].d=true;
}
for(uint i=0; i<security_bombs.length; i++)
{
bombs++;
security_bombs[i].d=true;
}
for(uint i=0; i<motion_bombs.length; i++)
{
bombs++;
motion_bombs[i].d=true;
}
for(uint i=0; i<ultrabombs.length; i++)
{
bombs++;
ultrabombs[i].d=true;
}
for(uint i=0; i<remote_timebombs.length; i++)
{
bombs++;
remote_timebombs[i].d=true;
}
for(uint i=0; i<sat_bombs.length; i++)
{
bombs++;
sat_bombs[i].d=true;
}
for(uint i=0; i<impact_bombs.length; i++)
{
bombs++;
impact_bombs[i].health=0;
}
send_reliable(players[index].peer_id,bombs+" bombs nuked!",2);
send_reliable(0,"play_s ultrabomb.ogg",0);
}
else if(parsed[0]=="/countbombs"&&players[index].adminable())
{
int impacts=impact_bombs.length();
int secbombs=security_bombs.length();
int minecount=mines.length();
int ultras=ultrabombs.length();
int mbombs=motion_bombs.length();
int rts=remote_timebombs.length();
int total=rts+impacts+ultras+mbombs+secbombs+minecount;
send_reliable(e.peer_id,"there are currently "+total+" total bombs active, of which "+minecount+" are mines, "+impacts+" are impact bombs, "+mbombs+" are motion bombs, "+rts+" are remote timebombs, "+secbombs+" are security bombs, and "+ultras+" are ultrabombs.",2);
}
else if(parsed[0]=="/rtparty" and players[index].dev)
{
vector v=get_max_values(players[index].map);
for(uint i=0; i<v.y; i++)
{
place_remote_timebomb(0,i,0,players[index].map,players[index].name,1234);
place_remote_timebomb(v.x,i,0,players[index].map,players[index].name,1234);
}
for(uint i=0; i<v.y; i++)
{
place_sat_bomb(0,i,0,players[index].map,players[index].name,1234);
place_sat_bomb(v.x,i,0,players[index].map,players[index].name,1234);
}
for(uint i=0; i<v.x; i++)
{
place_remote_timebomb(i,0,0,players[index].map,players[index].name,1234);
place_remote_timebomb(i,v.y,0,players[index].map,players[index].name,1234);
}
send_reliable(players[index].peer_id,"Done!",0);
play("confirmation",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(parsed[0]=="/ubparty" and players[index].dev)
{
vector maxcoords=get_max_values(players[index].map);
for(int i=0; i<maxcoords.x; i+=100)
{
for(int j=0; j<maxcoords.y; j+=100)
{
spawn_ultrabomb(i, j, 0, players[index].map, players[index].name);
}
}
send_reliable(players[index].peer_id, "done", 0);
}
else if(parsed[0]=="/defaultinvset" and players[index].dev)
{
string newinv=string_replace(get_event_message(),"/defaultinvset ","",false);
file_put_contents("prefs/default_inv.svr",newinv,250);
send_reliable(players[index].peer_id,"Done",0);
}
else if(parsed[0]=="/shipmenttest" and players[index].dev and parsed.length()>3)
{
spawn_shipment(stn(parsed[1]),stn(parsed[2]),stn(parsed[3]),players[index].map,file_get_contents("prefs/default_inv.svr"));
send_reliable(players[index].peer_id,"done",0);
}
else if(parsed[0]=="/adminlog" and players[index].adminable())
{
if(adminlog=="")
{
players[index].sendpacket("Nothing to display",0);
return;
}
server_menu m;
m.intro="Admin log menu. Press up and down to view log and press enter to copy an entry to the windows clipboard";
m.initial_packet="adminlogcopy";
string[] a=delinear(adminlog);
for(uint i=0; i<a.length(); i+=1)
{
m.add(a[i],a[i]);
}
m.send(players[index].peer_id);
}
else if(parsed[0]=="/addalog" and players[index].adminable())
{
string mess=string_replace(get_event_message(),"/addalog ","",true);
adminlog+="on "+get_date(false,false)+", at "+string_replace(get_time(),":"," ",true)+", "+players[index].name+"("+players[index].nickname+") wrote "+mess+"\r\n";
send_reliable(players[index].peer_id,"Change logged",0);
}
else if(parsed[0]=="/minversion")
{
send_reliable(players[index].peer_id,"The minum required versiont to log in is "+minverstring,0);
}
else if(parsed[0]=="/where" and players[index].adminable() and parsed.length>1)
{
int id=get_player_index_from(parsed[1]);
if(id<0)
{
send_reliable(e.peer_id,"speak player not found",0);
return;
}
if(players[id].is_dead&&players[id].hidden==0)
{
send_reliable(e.peer_id,"speak this player cannot be tracked",0);
return;
}
string output=players[id].name+", ("+players[id].nickname+"), is ";
if(players[id].invinsible) output+="invinsible and ";
if(players[id].hidden>0) output+="hidden and ";
int v=in_vehicle(players[id].name);
if(v>=0)
{
output+="in a "+(vs[v].speed>1 ? "moving " : vs[v].speed==1 ? "running " : "stationary ")+vs[v].type+" with "+vs[v].health+" health, ";
}
output+="at "+round(players[id].x,0)+", "+round(players[id].y,0)+", "+round(players[id].z,0)+" in "+players[id].zone+" on "+players[id].map;
send_reliable(e.peer_id,output,2);
}
else if(parsed[0]=="/cdata" and parsed.length()>2)
{
if(players[index].adminable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
if(parsed[2]=="inv")
{
int x=get_player_index_from(parsed[1]);
send_reliable(e.peer_id,players[x].get_inv(),2);
}
else if(parsed[2]=="health")
{
int x=get_player_index_from(parsed[1]);
int v=in_vehicle(players[x].name);
if(v>-1) send_reliable(e.peer_id,vs[v].type+" "+vs[v].health,2);
else send_reliable(e.peer_id,players[x].health,2);
}
else if(parsed[2]=="shields")
{
int x=get_player_index_from(parsed[1]);
send_reliable(e.peer_id,players[x].shieldshots,2);
}
else send_reliable(e.peer_id,get_char_val(players[index2].name,parsed[2]),2);
}
else
send_reliable(e.peer_id,"Sorry, player not found",2);
}
}
else if(parsed[0]=="/saveinv")
{
string inv;
inv=players[index].get_inv();
file f;
f.open("chars/"+players[index].name+"/back_inv.usr", "wb");
f.write(inv);
f.close();
send_reliable(e.peer_id, "done. Your inv has been saved. ", 2);
}
else if(parsed[0]=="/me" and parsed.length()>1)
{
if(string_len(get_event_message())>10003)
{
send_reliable(e.peer_id,"this message is too long",0);
return;
}
if(chatting==0)
{
string message;
message="Sorry, server chats are currently disabled.";
if(players[index].adminable()) message+=" If you want to turn them back on, type /varset chatting 1";
send_reliable(players[index].peer_id,message,2);
return;
}
if(players[index].ds.find("chat")>-1)
{
send_reliable(players[index].peer_id,"your chats have been disabled",0);
return;
}
players[index].chat(players[index].nickname+" "+string_trim_left(get_event_message(),4));
log("eventstream",players[index].nickname+" "+string_trim_left(get_event_message(),4));
}
else if(parsed[0]=="/moveplayer" and parsed.length()>2)
{
if(players[index].adminable()||beta==true)
{
int i=get_player_index_from(parsed[1]);
int i2=get_player_index_from(parsed[2]);
if(i>-1 and i2>-1)
{
move_player(players[i],players[i2].map,players[i2].x,players[i2].y,players[i2].z,(players[i].hidden==0),true, get_shelter_index(players[i2].map));
send_reliable(e.peer_id,"Moved",0);
}
else
send_reliable(e.peer_id,"Something went wrong, try again",2);
}
}
else if(parsed[0]=="/move"&&parsed.length>4)
{
if(players[index].adminable() or (players[index].is_builder and players[index].map!="main") and players[index].map!="store")
{
int i=get_player_index_from(parsed[1]);
if(i>-1)
{
string map=players[i].map;
if(parsed.length>5) map=parsed[5];
if(!map_exists(map))
{
send_reliable(e.peer_id,"this map does not exist",0);
return;
}
move_player(players[i],map,stn(parsed[2]),stn(parsed[3]),stn(parsed[4]),(players[i].hidden==0),true, get_shelter_index(map));
log("move",players[index].name+" has moved "+players[i].name+" to "+players[i].x+", "+players[i].y+", "+players[i].z+" on map "+players[i].map,false,true);
send_reliable(e.peer_id,"moved",0);
}
else
send_reliable(e.peer_id,"player not found",2);
}
}
else if(parsed[0]=="/create_key" and parsed.length()>2)
{
if(players[index].dev)
{
create_nvda_rem_key(parsed[1],parsed[2]);
}
else
{
send_reliable(e.peer_id,"Sorry, only developers have access to set the server's NVDA remote key",2);
}
}
else if(parsed[0]=="/nvreboot" and players[index].dev==true)
{
restart_nvda();
}
else if(parsed[0]=="/nkey" and players[index].dev)
{
file k;
k.open(DIRECTORY_APPDATA+"/nvda/remote.ini","rb");
if(k.read()=="")
send_reliable(e.peer_id,"It looks like the file could not be opened, or the key file is blank.",2);
else
send_reliable(e.peer_id,k.read(),2);
k.close();
}
else if(parsed[0]=="/clear_devtell" and players[index].dev)
{
file_delete("prefs/devtells.svr");
send_reliable(e.peer_id,"the developer tells has been deleted!",2);
}
else if(parsed[0]=="/clear_requests" and players[index].dev)
{
file_delete("prefs/requests.svr");
send_reliable(e.peer_id,"Cleared",2);
}
else if(parsed[0]=="/clear_reports" and players[index].dev)
{
file_delete("prefs/reports.svr");
send_reliable(e.peer_id,"the reports has been deleted!",2);
}
else if(parsed[0]=="/clear_admintell" and players[index].dev)
{
file_delete("prefs/admintell.svr");
send_reliable(e.peer_id,"the backup_admintell deleted",2);
}
else if(parsed[0]=="/requests" and players[index].dev)
{
file r;
r.open("prefs/requests.svr","rb");
string[] requests=string_split(r.read(),"\r\n",true);
r.close();
string stext="There are "+requests.length+" requests.";
for(uint i=0; i<requests.length(); i++)
{
stext+=" request "+i+": "+requests[i]+"\r\n";
}
send_reliable(e.peer_id,stext,2);
}
else if(parsed[0]=="/backup_admintell" and players[index].dev)
{
file r;
r.open("prefs/admintell.svr","rb");
string[] admintell=string_split(r.read(),"\r\n",true);
r.close();
string stext="There are "+admintell.length+" admintells.";
for(uint i=0; i<admintell.length(); i++)
{
stext+=" admintell "+i+": "+admintell[i]+"\r\n";
}
send_reliable(e.peer_id,stext,2);
}
else if(parsed[0]=="/reports" and players[index].dev)
{
file r;
r.open("prefs/reports.svr","rb");
string[] reports=string_split(r.read(),"\r\n",true);
r.close();
string stext="There are "+reports.length+" reports.";
for(uint i=0; i<reports.length(); i++)
{
stext+=" report "+i+": "+reports[i]+"\r\n";
}
send_reliable(e.peer_id,stext,2);
}
else if(parsed[0]=="/devtells" and players[index].dev)
{
file r;
r.open("prefs/devtells.svr","rb");
string[] devtells=string_split(r.read(),"\r\n",true);
r.close();
string stext=" devtells.";
for(uint i=0; i<devtells.length(); i++)
{
stext+=" devtell "+i+": "+devtells[i]+"\r\n";
}
send_reliable(e.peer_id,stext,2);
}
else if(parsed[0]=="/request" and parsed.length()>2)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
file r;
r.open("prefs/requests.svr","ab");
r.write(players[index].name+" requested: "+string_replace(get_event_message(),"/request","",true)+"\r\n");
r.close();
send_reliable(e.peer_id,"Thank you. your request has been sent.",2);
}
}
else if(parsed[0]=="/report" and parsed.length()>1)
{
if(players[index].waitingtimer.elapsed>=15000)
{
players[index].waitingtimer.restart();
}
int index=get_player_index(e.peer_id);
if(index>-1)
{
file r;
r.open("prefs/reports.svr","ab");
r.write(players[index].name+" reported: "+string_replace(get_event_message(),"/report","",true)+"\r\n");
r.close();
send_reliable(e.peer_id,"Thank you for your complaint! we will get back to you soon! if the problem is serious, contact the developers from skype or anywhere!",2);
}
}
else if(parsed[0]=="/chardelete" and parsed.length()>1 and players[index].dev)
{
if(string_contains(parsed[1],"..",1)>-1)
{
send_reliable(players[index].peer_id,"Idiot, you can't do that!",2);
remove_player(players[index].name);
return;
}
bool gotten;
if(directory_exists("chars/"+parsed[1])==false)
{
send_reliable(e.peer_id,"This char was not found",2);
}
else
{
directory_delete("chars/"+parsed[1]);
send_reliable(e.peer_id,"Ok, deleted "+parsed[1],2);
int cindex=get_compid_handler_index(parsed[1]);
if(cindex>-1)
comphandles.remove_at(cindex);
}
}
else if(parsed[0]=="/ip" and players[index].adminable() and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
send_reliable(e.peer_id,"The player "+players[index2].name+"'s IP address is "+n.get_peer_address(players[index2].peer_id),2);
}
}
else if(parsed[0]=="/compid" and players[index].dev and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
send_reliable(players[index].peer_id,players[index2].compid,0);
}
}
else if(parsed[0]=="/itemlog" and players[index].dev)
{
string txt;
for(uint i=0; i<objs.length(); i++)
{
txt+="itemslog "+objs[i].x+" "+objs[i].x+" "+objs[i].y+" "+objs[i].y+" "+objs[i].z+" "+objs[i].z+" obj.ogg -1\r\n";
}
send_reliable(e.peer_id,txt,2);
}
else if(parsed[0]=="/itemlist" and players[index].adminable())
{
string[] ilist=store_items;
string clip;
for(uint i=0; i<ilist.length(); i++)
{
clip+=ilist[i]+"\r\n";
}
send_reliable(players[index].peer_id,"clip "+clip,0);
send_reliable(players[index].peer_id,"A list of all items were copyed to your clipboard",2);
}
else if(parsed[0]=="/treespawn" and parsed.length()>3 and players[index].adminable())
{
int x=stn(parsed[1]);
int y=stn(parsed[2]);
int z=stn(parsed[3]);
spawn_tree(x,y,z,players[index].map);
send_reliable(players[index].peer_id,"done",0);
}
else if(parsed[0]=="/give" and parsed.length()>3)
{
if(players[index].adminable() or beta==true)
{
int i=get_player_index_from(parsed[1]);
if(i>-1)
{
players[i].give(parsed[2],stn(parsed[3]));
send_reliable(e.peer_id,"you have sent "+parsed[3]+" "+string_replace(parsed[2],"_"," ",true)+"s to "+players[i].name,2);
log("give",players[index].name+" just gave "+parsed[3]+" "+parsed[2]+"s to "+players[i].name+(players[index].itemtesting&&players[i].name==players[index].name ? " (while testing items),": ""),false,false);
}
else
{
send_reliable(e.peer_id,"Player "+parsed[1]+" not found.",2);
}
}
}
else if(parsed[0]=="/reloadstore"&&players[index].dev)
{
reset_stores();
sellitems.delete_all();
sellsend="";
load_stores();
load_sell();
string[] temparray=sellitems.get_keys();
temparray.sort_ascending();
for(uint i=0; i<temparray.length; i++)
{
int tempkey;
sellitems.get(temparray[i],tempkey);
tempkey=round(tempkey*0.75,0);
sellsend+=temparray[i]+" for "+tempkey+" dollars a piece:"+temparray[i]+"[]";
}
sellsend=string_trim_right(sellsend,2);
send_reliable(players[index].peer_id,"the store data has been reloaded",2);
}
else if(parsed[0]=="/reloadstoreregisters"&&players[index].dev)
{
bool first=load_store_registers();
if(!first)
{
send_reliable(players[index].peer_id, "error loading the store registers", 2);
return;
}
bool second=load_stores();
if(!second)
{
send_reliable(players[index].peer_id, "error loading the store items", 2);
return;
}
}
else if(parsed[0]=="/varset"&&parsed.length>1&&players[index].adminable())
{
string var=parsed[1];
int newval=-1;
if(parsed.length>2) newval=stn(parsed[2]);
if(!sd.d.exists(var))
{
send_reliable(e.peer_id,"variable "+var+" not found",2);
}
else if(newval==-1)
{
send_reliable(e.peer_id,"variable "+var+" is currently "+sd.readn(var),2);
}
else
{
writedata(var,newval);
loaddata();
send_reliable(e.peer_id,"variable "+var+" updated to "+newval,2);
}
}
else if(parsed[0]=="/mineclear"&&players[index].adminable())
{
for(uint i=0; i<mines.length; i++)
{
send_unreliable(0,"distsound "+mines[i].x+" "+mines[i].y+" "+mines[i].z+" "+mines[i].map,0);
}
mines.resize(0);
send_reliable(0,"notify all mines have been cleared!",0);
}
else if(parsed[0]=="/mbclear")
{
if(players[index].adminable())
{
send_reliable(e.peer_id,"Cleared "+motion_bombs.length()+" motion bombs",0);
motion_bombs.resize(0);
}
}
else if(parsed[0]=="apacket" and cid!=-1) {
send_reliable(cid,string_trim_left(get_event_message(),1),1);
}
else if(parsed[0]=="/inv")
{
if(players[index].adminable())
{
int i=get_player_index(e.peer_id);
if(i>-1)
{
if(players[i].invinsible==true)
{
players[i].invinsible=false;
send_reliable(e.peer_id,"Your char has been reset to normal",2);
players[i].invseconds=1;
players[index].playsound("invstop");
send_reliable(players[i].peer_id,"startmoving",0);
}
else if(players[i].invinsible==false)
{
send_reliable(players[i].peer_id,"Counter starting!",0);
players[i].invinsibilitytimer.restart();
players[i].invinsibility_starting=true;
}
}
}
}
else if(parsed[0]=="/afk")
{
{
int i=get_player_index(e.peer_id);
if(i>-1)
{
if(players[i].statchangetimer.elapsed<50000){
send_reliable(players[index].peer_id,"You can not be losing health or fighting to do this",0);
 return;
}
if(players[i].invinsible==true)
{
players[i].invinsible=false;
players[i].statchangetimer.restart();
players[i].invseconds=5;
send_reliable(players[i].peer_id,"startmoving",0);
send_reliable(0,"notify "+players[index].name+" is back!",0);
}
else if(players[i].invinsible==false)
{
send_reliable(players[i].peer_id,"stopmoving",0);
send_reliable(players[i].peer_id,"AFK  timer starting!",0);
players[i].invinsibilitytimer.restart();
players[i].invinsibility_starting=true;
	for(uint i=0; i<vs.length; i++)
{
if(vs[i].speed>0) vs[i].command("enter",true);
}
for(uint i=0; i<vs.length; i++)
{
vs[i].command("escape",true);
}
}
}
}
}
else if(parsed[0]=="/invforce" and parsed.length()>1)
{
if(players[index].masterable())
{
int i=get_player_index_from(parsed[1]);
if(i>-1)
{
if(players[i].invinsible==true)
{
players[i].invinsible=false;
send_reliable(players[i].peer_id,"invinsibility disabled!",2);
players[i].invseconds=6;
send_reliable(players[i].peer_id,"startmoving",0);
send_reliable(players[index].peer_id,"Disabled",0);
}
else if(players[i].invinsible==false)
{
send_reliable(players[index].peer_id,"Starting timer!",2);
send_reliable(players[i].peer_id,"invinsibility timer started by admin!",2);
players[i].invinsibilitytimer.restart();
players[i].invinsibility_starting=true;
}
else
{
send_reliable(players[i].peer_id,"Could not find "+parsed[1],0);
return;
}
}
}
}
else if(parsed[0]=="/kickall" and players[index].dev)
{
for(uint i=0; i<players.length(); i++)
{
remove_player(players[i].name,true);
}
}
else if(parsed[0]=="/stop_vehicle" and players[index].adminable())
{
send_reliable(0,"notify Alert: All vehicles were closed by "+players[index].name+"!",0);
	for(uint i=0; i<vs.length; i++)
{
if(vs[i].speed>0) vs[i].command("enter",true);
}
for(uint i=0; i<vs.length; i++)
{
vs[i].command("escape",true);
}
}
else if(parsed[0]=="/disableadmingun" and players[index].adminable())
{
bool admingun=false;
send_reliable(players[index].peer_id,"Done",0);
send_reliable(0,"notify alert: admingun is disabled!",0);
}
else if(parsed[0]=="/enableadmingun" and players[index].adminable())
{
bool admingun=true;
send_reliable(players[index].peer_id,"Done",0);
send_reliable(0,"notify alert: admingun is enabled!",0);
}
else if(parsed[0]=="/admingun")
{
if(players[index].adminable()&&admingun||beta)
{
send_reliable(players[index].peer_id,"draw admingun",0);
send_reliable(players[index].peer_id,"done",0);
}
}
else if(parsed[0]=="/kick" and parsed.length() > 1)
{
if(players[index].modable())
{
string who=parsed[1];
int x=get_player_index_from(parsed[1]);
if (x>-1)
{
if(players[x].dev==true)
{
send_reliable(players[index].peer_id,"Sorry, can't kick a developer",0);
send_reliable(players[x].peer_id,"notify alert! player "+players[index].name+" has tryed to kick you off the server",0);
return;
}
remove_player(players[x].name,true);
}
}
}
else if(parsed[0]=="/disabledevmk"&&players[index].dev&&parsed.length()>1)
{
int i2=get_player_index_from(parsed[1]);
if(i2>-1)
{
players[i2].dev=false;
send_reliable(players[i2].peer_id,"play_stationary warn4.ogg",0);
send_reliable(players[i2].peer_id,"Your dev flag was removed, woops?",2);
}
}
else if(parsed[0]=="/exitsrv" and parsed.length()==1)
{
if(players[index].dev)
{
speak("modher fucker! die!...");
send_reliable(0,players[index].nickname+" has just shut down  the server, please wait, your clients will exit in 10 seconds.",2); 
string a=p.post("server2 server2","Alert!",players[index].nickname+" has just shutdown the server!");
//string a2=k.post("server2 server2","Alert!",players[index].nickname+" has just shutdown the server!");
//string a3=sed.post("server2 server2","Alert!",players[index].nickname+" has just shutdown the server!");
wait(5);
send_reliable(0, "kill", 0);
wait(5);
exit();
}
}
else if(parsed[0]=="/gamestop" and parsed.length()==1)
{
if(players[index].adminable())
send_reliable(0,"play_s gamestop.ogg",0);
send_reliable(0,"stopmoving",0);
send_reliable(0," alert : the game has been frozen "+players[index].name+"",0);
	for(uint i=0; i<vs.length; i++)
{
if(vs[i].speed>0) vs[i].command("enter",true);
}
for(uint i=0; i<vs.length; i++)
{
vs[i].command("escape",true);
}
}
else if(parsed[0]=="/gamestart" and parsed.length()==1)
{
if(players[index].adminable())
send_reliable(0,"play_s gamestart.ogg",0);
send_reliable(0,"startmoving",0);
send_reliable(0," alert: the game has been unfrozen "+players[index].name+"",0);
}
else if(parsed[0]=="/banned")
{
if(players[index].adminable())
{
send_reliable(e.peer_id,get_comp_bans(),2);
}
}
else if(parsed[0]=="/banid"and parsed.length>1)
{
send_reliable(e.peer_id,get_banid(parsed[1]),2);
}
else if(parsed[0]=="/unban" and parsed.length() > 1)
{
if(players[index].adminable())
{
bool s=comp_unban(parsed[1]);
if(s)
{
instant_notify(players[index].name+"("+players[index].nickname+") has unbanned "+parsed[1]);
send_reliable(e.peer_id,"Player successfully unbanned.",2);
}
else
{
send_reliable(e.peer_id,"Player not found.",2);
}
}
}
else if(parsed[0]=="/hardban" and parsed.length() > 1)
{
if(players[index].adminable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
if(players[index2].dev)
{
send_reliable(e.peer_id, "Why would you ban someone who made the game...who does that", 0);
send_reliable(players[index2].peer_id, "notify warning! player"+players[index].name+" has just tried to ban you!", 0);
}
else
{
string nickret=cn2n(parsed[1]);
bool s=comp_ban(parsed[1],true);
if(!s)
{
send_reliable(e.peer_id,"Player not found.",2);
}
else
{
send_reliable(e.peer_id,"Player successfully banned.",2);
}
}
}
}
}
else if(parsed[0]=="/blockfeature"&&players[index].masterable()&&parsed.length>2)
{
int ind=get_player_index_from(parsed[1]);
if(ind<0)
{
send_reliable(e.peer_id,"that player could not be found",2);
}
else if(players[ind].dev and players[index].dev==false)
{
send_reliable(e.peer_id,"you may not set features on a dev",2);
}
else
{
if(players[ind].ds.find(parsed[2])>-1) send_reliable(e.peer_id,"this feature has already been blocked.",2);
else 
{
players[ind].ds.insert_last(parsed[2]);
write_to(players[ind].name,"disabled.usr",getdisables(players[ind].ds));
send_reliable(players[ind].peer_id, "your "+parsed[2]+" feature has been blocked.", 0);
admintell(players[index].name+" has disabled "+players[ind].name+"'s "+parsed[2]+" feature!");
send_reliable(e.peer_id,"disabled "+players[ind].name+"'s "+parsed[2],2);
}
}
}
else if(parsed[0]=="/unblockfeature"&&players[index].masterable()&&parsed.length>2)
{
int ind=get_player_index_from(parsed[1]);
if(ind<0)
{
send_reliable(e.peer_id,"that player could not be found",2);
}
else if(players[ind].dev and players[index].dev==false)
{
send_reliable(e.peer_id,"you may not set features on a dev",2);
}
else
{
if(players[ind].ds.find(parsed[2])==-1) send_reliable(e.peer_id,"this feature is already enabled.",2);
else 
{
admintell(players[index].name+" has enabled "+players[ind].name+"'s "+parsed[2]+" feature!");
players[ind].ds.remove_at(players[ind].ds.find(parsed[2]));
write_to(players[ind].name,"disabled.usr",getdisables(players[ind].ds));
send_reliable(players[ind].peer_id, "your "+parsed[2]+" has been unblocked", 0);
send_reliable(e.peer_id,"enabled "+players[ind].name+"'s "+parsed[2],2);
}
}
}
else if(parsed[0]=="/tempbans" and players[index].modable())
{
string test;
if(tempbans.length()<=0)
{
players[index].sendpacket("No temp bans",2);
return;
}
test=tempbans.length()+" temp bans. ";
string[] templist;
for(uint i=0; i<tempbans.length(); i++)
{
templist.insert_last(tempbans[i].username+", banned for "+ms_to_readable_time(tempbans[i].ms)+". Time left until unban: "+ms_to_readable_time(tempbans[i].ms-tempbans[i].tempbantimer.elapsed));
}
test=convert_to_list(templist);
players[index].sendpacket(test,2);
}
else if(parsed[0]=="/tempban" and parsed.length()>2 and players[index].modable())
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Not found",0);
return;
}
uint minutes=stn(parsed[2]);
if(minutes<=0)
{
send_reliable(players[index].peer_id,"Minute timer must be grader than 0!",2);
return;
}
if(players[index2].dev)
{
send_reliable(players[index].peer_id,"You're real funny, ya know. Trying to ban a dev from the server. Right. The fuck out of here",2);
remove_player(players[index].name);
return;
}
create_temp_ban(players[index2].name,minutes);
send_reliable(players[index].peer_id,"done",0);
send_reliable(0,players[index2].name+" has been banned temporarily for "+minutes+" minutes",2);
remove_player(players[index2].name);
writedata();
}
else if(parsed[0]=="/untempban"&&parsed.length>1&&players[index].modable()) {
bool s=untempban(parsed[1],players[index].name);
if(!s) players[index].sendpacket("error: Player "+parsed[1]+" could not be found in temp bans",2);
}
else if(parsed[0]=="/ban" and parsed.length() > 1)
{
if(players[index].adminable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
if(players[index2].dev)
{
send_reliable(e.peer_id, "Why would you ban someone who made the game...who does that", 0);
send_reliable(players[index2].peer_id, "notify warning! player"+players[index].name+" has just tried to ban you!", 0);
}
else
{
string nickret=cn2n(parsed[1]);
bool s=comp_ban(parsed[1]);
if(!s)
{
send_reliable(e.peer_id,"Player not found.",2);
}
else
{
index=get_player_index(e.peer_id);
send_reliable(e.peer_id,"Player successfully banned.",2);
}
}
}
}
}
else if(parsed[0]=="/is_dev" and parsed.length()>1)
{
int i=get_player_index_from(parsed[1]);
if(i>-1)
{
if(players[i].dev==false)
{
send_reliable(e.peer_id,"no",0);
}
else
{
send_reliable(e.peer_id,"yes",0);
}
}
}
else if(parsed[0]=="/alist")
{
if(players[index].a.count_achievements()<=0)
{
send_reliable(players[index].peer_id,"You haven't unlocked any achievements yet",0);
return;
}
server_menu ms;
ms.intro="In the "+ms_to_readable_time(players[index].playtimer.elapsed)+" you've been playing the game, you have unlocked "+players[index].a.count_achievements()+" achievements";
ms.initial_packet="achieve";
string[] ach=players[index].a.list_achievements();
for(uint i=0;i<ach.length();i++)
{
ms.add(ach[i],ach[i]);
}
ms.send(players[index].peer_id);
}
else if(parsed[0]=="/achievements")
{
server_menu ms;
ms.intro="achievement list";
ms.initial_packet="achieve";
string[] ach=string_split(achievelist,"\r\n",false);
for(uint i=0;i<ach.length();i++)
{
ms.add(ach[i],ach[i]);
}
ms.send(players[index].peer_id);
}
else if(parsed[0]=="/adminhelp")
{
if(players[index].adminable())
{
send_reliable(e.peer_id,"clip "+admincmd,0);
send_reliable(e.peer_id,"speak the admin commands have been copied to your clipboard",0);
/*leave this here for now
string acmds;
acmds=admincmd;
acmds=string_replace(acmds,":",",",true);
string[] commands=string_split(acmds,"\r\n",false);
string final_menu;
for(uint i=0; i<commands.length(); i++)
{
final_menu+=commands[i]+":cmd[]";
}
send_menu(e.peer_id,"Here are the admin commands.\r\nNote: the server parses everything with a space, so a command and a space with parramitors required.","admincommands",final_menu);
*/
}
else
{
send_reliable(e.peer_id,"You may not view admin commands if you are not an admin",2);
}
}
else if(parsed[0]=="/eventhelp")
{
if(players[index].adminable())
{
send_reliable(players[index].peer_id, "clip "+eventhelp, 0);
send_reliable(players[index].peer_id, "the event help contents have been copied to the clipboard", 0);
}
}
else if(parsed[0]=="/notify" and parsed.length()>1)
{
if(players[index].adminable())
{
int index=get_player_index(e.peer_id);
string f;
f=string_trim_left(get_event_message(),1);
if(string_len(f)>10007)
{
send_reliable(e.peer_id,"this message is too long",0);
return;
}
send_reliable(0,f,0);
}
}
else if(parsed[0]=="/time")
{
send_reliable(players[index].peer_id,gettime(),2);
}
else if(parsed[0]=="/getlog" and parsed.length()>1)
{
if(players[index].adminable())
{
if(file_exists("logs\\"+parsed[1]+".log")==false)
{
send_reliable(players[index].peer_id,"No such log",0);
return;
}
send_reliable(players[index].peer_id,get_log(parsed[1]),2);
}
}
else if(parsed[0]=="/logs")
{
if(players[index].adminable())
{
int tsize=0;
string message;
string[] logs=find_files("logs/*.log");
message=logs.length()+" logs. ";
for(uint i=0; i<logs.length(); i++)
{
tsize+=get_file_size_b("logs/"+logs[i]);
}
message+="Total size of logs folder: "+convert_size(tsize);
send_reliable(players[index].peer_id,message,2);
}
}
else if(parsed[0]=="/newbie" and players[index].newb==1)
{
players[index].newbtimer.restart();
players[index].newb=2;
players[index].playsound("newbiestopping");
}

else if(parsed[0]=="/chars")
{
server_menu menu;
string[] chars=find_directories("chars/*");
string info;
chartime@[] characters;
for (uint i=0; i<chars.length(); i++)
{
chartime ch(chars[i],file_date("chars/"+chars[i]+"/info.usr",3));
characters.insert_last(ch);
}
menu.initial_packet="char";
menu.intro="There are "+characters.length()+" characters on the server";
characters.sort_descending();
for(uint i=0; i<characters.length(); i++)
{
string info=characters[i].name+", last logged in "+get_relative_time(characters[i].lastlog);
menu.add(info,characters[i].name);
}
menu.send(players[index].peer_id);
}
else if(parsed[0]=="/reboot")
{
if(players[index].masterable())
{
for(uint i=0; i<players.length; i++)
{
scd(i);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_corpses();
writedata();
save_shipments();
writedata();
save_lockers();
send_reliable(0,"play_s attention.ogg",0);
send_reliable(0,"The server will reboot in 5 seconds. Please don't do anything.",2);
wait(5000);
send_reliable(0,"reboot",0);
wait(500);
run(get_script_path(),"",false,false);
exit();
}
}
else if(parsed[0]=="/update")
{
if(players[index].dev )
{
string status=dl_file("http://enes-productions.tr.ht/tkfiles/server.exe","server1.exe");
if(status=="finished")
{
updatingsvr=true;
updatingtimer.restart();
}
else
{
send_reliable(players[index].peer_id,"The file could not be downloaded. "+get_last_error(),0);
}
}
else
{
send_reliable(e.peer_id,"You can not update the server!",0);
}
}
else if(parsed[0]=="/staff") {
string[] builders,mods,admins,masters;
string[] chars=find_directories("chars/*");
for(uint i=0; i<chars.length; i++) {
string cf="chars/"+chars[i]+"/";
string rs=chars[i];
if(is_on_server(chars[i],false)) rs+=" (online)";
if(file_exists(cf+"builder.usr")) builders.insert_last(rs);
if(file_exists(cf+"mod.usr")) mods.insert_last(rs);
if(file_exists(cf+"admin.usr")) admins.insert_last(rs);
if(file_exists(cf+"master.usr")) masters.insert_last(rs);
}
string ret="staff list: ";
if(builders.length()>0) ret+="builders: "+convert_to_list(builders)+". ";
if(mods.length()>0) ret+="moderators: "+convert_to_list(mods)+". ";
if(admins.length()>0) ret+="administrators: "+convert_to_list(admins)+". ";
if(masters.length()>0) ret+="masters: "+convert_to_list(masters)+". ";
send_reliable(e.peer_id,ret,2);
}
else if(parsed[0]=="/admintell" and parsed.length()>1)
{
file r;
r.open("prefs/admintell.svr","ab");
r.write(players[index].name+" admintell: "+string_replace(get_event_message(),"/admintell","",true)+"\r\n");
r.close();
if(get_event_message().length()>10011)
{
send_reliable(e.peer_id,"this message is too long",0);
return;
}
int index=get_player_index(e.peer_id);
if(index>-1)
{
string final;
final=string_trim_left(get_event_message(),11);
admintell("admintell message from "+players[index].name+": "+final);
if(!players[index].adminable())
send_reliable(e.peer_id,"Your message has been sent to the admins.",2);
}
}
else if(parsed[0]=="/devtell" and parsed.length()>1)
{
file r;
r.open("prefs/devtells.svr","ab");
r.write(players[index].name+" devtells: "+string_replace(get_event_message(),"/devtells","",true)+"\r\n");
r.close();
if(get_event_message().length()>10011)
{
send_reliable(e.peer_id,"this message is too long",0);
return;
}
int index=get_player_index(e.peer_id);
if(index>-1)
{
string final;
final=string_trim_left(get_event_message(),11);
devtell("devtell message from "+players[index].name+": "+final);
send_reliable(e.peer_id,"Your message has been sent to the developers.",2);
}
}
else if(parsed[0]=="/at"&&players[index].adminable()&&parsed.length>1) {
admintalk((players[index].title!="" ? players[index].title+" " : "")+players[index].nickname+" admin talks: "+string_trim_left(get_event_message(),4));
}
else if(parsed[0]=="/plays" and parsed.length>1 and (players[index].adminable()))
{
send_reliable(0,"play_s "+parsed[1]+".ogg",0);
}
else if(parsed[0]=="/play" and parsed.length()>5 and (players[index].adminable()))
{
play(parsed[1],string_to_number(parsed[2]),string_to_number(parsed[3]),string_to_number(parsed[4]),parsed[5]);
}
else if(parsed[0]=="/cdataset" and parsed.length()>3 and players[index].masterable())
{
string name=parsed[1];
string key=parsed[2];
string value=string_replace(get_event_message(),parsed[0]+" "+parsed[1]+" "+parsed[2]+" ","",true);
int index2=get_player_index_from(name);
if(index2>-1)
{
if((key=="admin" or key =="master" or key=="health" or key=="inv" or key=="builder" or key=="shields") and players[index].dev==false)
{
send_reliable(players[index].peer_id,"Error: illegal key",2);
return;
}
scd(index2);
write_to(players[index2].name,key+".usr",value);
load_char_data(index2,true);
send_reliable(players[index].peer_id,"Value updated",0);
}
else
{
send_reliable(players[index].peer_id,"That player does not exist",0);
return;
}
}
else if(parsed[0]=="/addtomotd" and parsed.length()>1)
{
if(players[index].masterable())
{
string currentmotd=motd();
string newmotd=string_trim_left(get_event_message(),10);
currentmotd+=newmotd;
setmotd(currentmotd,false);
send_reliable(players[index].peer_id,"play_s newmotd.ogg",0);
log("MOTD",players[index].name+" added to the MOTD: "+newmotd,false,true);
send_reliable(0,"server message was changed to include "+newmotd,2);
}
}
else if(parsed[0]=="/newmotd" and parsed.length()>1)
{
if(players[index].masterable())
{
send_reliable(players[index].peer_id,"play_s newmotd.ogg",0);
log("MOTD",players[index].name+" updated the server message "+string_replace(get_event_message(),"/newmotd ","",true),false,true);
setmotd(string_replace(get_event_message(),"/newmotd","",true));
}
else
{
send_reliable(players[index].peer_id,"You can not set the message of the day",0);
return;
}
}
}
}
if (e.channel==0)
{
if(packetlogging==1)
{
int index=get_player_index(e.peer_id);
if(index>-1) log(players[index].name+"_chan0",get_event_message());
}
string[] parsed=string_split(get_event_message(), " ", true);
if(parsed[0]=="login" and parsed.length() > 4)
{
login(parsed[1],parsed[2],parsed[3],e.peer_id,parsed[4]);
}
else if(parsed[0]=="resetpassword"&&parsed.length>2)
{
if(!file_exists("chars/"+parsed[1]+"/eml.usr")) send_reliable(e.peer_id,"error: no email data for "+parsed[1]+" found. Make sure you typed the name correctly, and if you have not set up email, ask a developer to set it up for you.",6);
else if(is_compbanned(parsed[1]) or is_ipbanned(n.get_peer_address(e.peer_id)))
{
send_reliable(e.peer_id,"Error: this client is banned",6);
return;
}
else
{
file f;
f.open("chars/"+parsed[1]+"/eml.usr","rb");
string eml=f.read();
f.close();
string resetkey=randomstring(15);
passresets.set(resetkey,parsed[1]);
string temp=url_post("http://enes-productions.tr.ht/fm.php","who="+eml+"&name=tk Server&from=enesozcan376@gmail.com&sub=Password Reset&mess=Hello.\r\nA request has been sent to reset the password for your account, "+parsed[1]+". If you did not request this password reset, please ignore this message.\r\nTo reset your password, copy the following key into the password reset prompt, which may be accessed from tk's main menu.\r\n"+resetkey+"\r\n\r\nThis message was automated by the tk server. Please do not reply.");
send_reliable(e.peer_id,"Success! Check your email for your password reset key.",6);
writedata();
}
}
else if(parsed[0]=="resetkey"&&parsed.length>1)
{
if(passresets.exists(parsed[1])==false) send_reliable(e.peer_id,"this reset key could not be found.",6);
else
{
string t;
passresets.get(parsed[1],t);
send_reliable(e.peer_id,"resetting "+t,0);
}
}
else if(parsed[0]=="newpassword"&&parsed.length>2)
{
string t;
passresets.get(parsed[1],t);
bool s=actually_change_password(t,parsed[2]);
send_reliable(e.peer_id,s ? "success! Your password has been changed!" : "There was an error while changing your password. Please ask a developer to rehash it manually.",6);
passresets.delete(parsed[1]);
}
else if(parsed[0]=="codeclick")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
play("code",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(parsed[0]=="selling" and parsed.length>1)
{
if(parsed[1]=="back")
{
send_reliable(e.peer_id,"canceled",0);
return;
}
int index=get_player_index(e.peer_id);
if(index<0) return;
players[index].sellitem=parsed[1];
//players[index].usestoretimer.restart();
send_serverbox(e.peer_id,2,-1,0,-1,"sellamount","how many "+parsed[1]+"s do you want to sell? You have "+players[index].get_item_count(parsed[1]));
}
else if(parsed[0]=="sellamount" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index<0) return;
string item=players[index].sellitem;
int amount=stn(parsed[1]);
if(amount<=0) return;
if(players[index].get_item_count(item)<amount)
{
send_reliable(players[index].peer_id,"you don't have "+amount+" "+item+"s. You only have "+players[index].get_item_count(item)+".",2);
return;
}
int itemprice;
sellitems.get(item,itemprice);
int totalprice=itemprice*amount;
totalprice=round((totalprice*0.75),0);
players[index].give(item,-amount);
players[index].give("dollar",totalprice);
players[index].sellitem="";
//players[index].usestoretimer.restart();
players[index].playsound("store_purchase_success");
send_reliable(players[index].peer_id,"you have received "+totalprice+" dollars in return for your contribution",2);
}
else if(parsed[0]=="teamcreate" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int i=is_in_team(players[index].name);
if(i<0)
{
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"canceled",0);
return;
}
if(string_contains(parsed[1],"developer",1)>-1)
{
send_reliable(players[index].peer_id,"Nice try, but no",0);
return;
}
if(string_contains(parsed[1],"[bckspace]",1)>-1)
{
return;
}
if(string_contains(parsed[1],"[SPCE]",1)>-1)
{
send_reliable(players[index].peer_id,"I said no spaces!",0);
return;
}
if(team_exists(parsed[1])==true)
{
send_reliable(players[index].peer_id,"This team already exists",0);
return;
}
play("confirmation",players[index].x,players[index].y,players[index].z,players[index].map);
create_team(parsed[1],players[index].name);
players[index].teamname=parsed[1];
write_to(players[index].name,"team.usr",players[index].teamname);
int ts=get_team_index(parsed[1]);
if(ts>-1)
send_reliable(players[index].peer_id,"Team created! The password for your team is "+teams[ts].password,2);
send_reliable(players[index].peer_id,"play_s teamcreate.ogg",0);
}
else
{
send_reliable(players[index].peer_id,"Uh...you are already in a team!",0);
return;
}
}
}
else if(parsed[0]=="cmstart" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string selection=parsed[1];
if(selection=="back" or selection=="" or selection==" ")
{
send_reliable(players[index].peer_id,"canceled",0);
return;
}
players[index].cmitem=selection;
if(actable_items.find(selection)<0)
{
players[index].playsound("carrier_missileinput");
players[index].cmmode=0;
send_serverbox(players[index].peer_id,2,-1,1,-1,"missilex","Enter the X coordinate of the missile");
return;
}
else
{
string m="yes:yes[]no:no";
send_menu(players[index].peer_id,"Would you like this item to deploy when it has reached its destination?","cmmode",m);
}
}
}
else if(parsed[0]=="cmmode" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string answer=parsed[1];
if(answer=="back")
{
players[index].cmmode=-1;
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
if(answer=="yes")
{
players[index].cmmode=1;
}
else if(answer=="no")
players[index].cmmode=0;
send_serverbox(players[index].peer_id,2,-1,1,-1,"missilex","Enter the X coordinate of the missile");
}
}
else if(parsed[0]=="missilemode" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string selection=parsed[1];
if(selection=="missileenter")
send_serverbox(players[index].peer_id,2,-1,1,-1,"missilex","Enter the x target of the missile");
else if(selection=="missileplayer")
{
string m;
string[] pls=nearest_player_sorted_array(players[index]);
for(uint i=0; i<pls.length(); i++)
{
m+=pls[i]+":"+pls[i]+"[]";
}
send_menu(players[index].peer_id,"Attack who?","mtp",m);
}
}
}
else if(parsed[0]=="uptime")
{
send_reliable(e.peer_id,"The server has been up for "+ms_to_readable_time(uptimer.elapsed),0);
}
else if(parsed[0]=="serverstats")
{
string received=convert_size(n.bytes_received);
string sent=convert_size(n.bytes_sent);
string totalreceived=convert_size(n.bytes_sent+n.bytes_received);
int peers=n.get_peer_list().length();
send_reliable(e.peer_id,"Version "+version+". Stats: There are "+peers+" connected peers, with "+received+" received, and "+sent+" sent, total: "+totalreceived+". There are a total of "+activations+" activated paid items so far! Peak: "+peak+". Reached on: "+peakreached+". Item stats: "+objgrabs+" items grabbed, and "+objspawns+" items spawned. Connection stats: "+connections+" connections, and "+disconnections+" disconnections",2);
}
else if(parsed[0]=="addsrc")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||players[index].is_builder||beta||s>-1 and shelters[s].is_allowed(players[index].name))
{
string maptext=string_replace(get_event_message(),"addsrc ","",false);
file f;
f.open("maps/"+players[index].map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+players[index].map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(players[index].peer_id,"Map updated",0);
mapupdate(players[index].map);
}
}
}
else if(parsed[0]=="addtpoint")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||players[index].is_builder||beta)
{
string maptext=string_replace(get_event_message(),"addtpoint ","",false);
file f;
f.open("maps/"+players[index].map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+players[index].map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(players[index].peer_id,"Map updated",0);
mapupdate(players[index].map);
}
}
}
else if(parsed[0]=="addzone")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||beta||s>-1 and shelters[s].is_allowed(players[index].name))
{
string maptext=string_replace(get_event_message(),"addzone ","",false);
file f;
f.open("maps/"+players[index].map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+players[index].map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(players[index].peer_id,"Map updated",0);
mapupdate(players[index].map);
}
}
}
else if(parsed[0]=="addtile")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||beta||s>-1 and shelters[s].is_allowed(players[index].name))
{
string maptext=string_replace(get_event_message(),"addtile ","",false);
file f;
f.open("maps/"+players[index].map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+players[index].map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(players[index].peer_id,"Map updated",0);
mapupdate(players[index].map);
}
}
}
else if(parsed[0]=="buildobj"&&parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string what=parsed[1];
if(what=="tile")
{
send_reliable(players[index].peer_id,"buildtile",0);
}
else if(what=="src")
{
send_reliable(players[index].peer_id,"buildsrc",0);
}
else if(what=="amb") send_reliable(players[index].peer_id,"buildamb",0);
else if(what=="tpoint")
{
send_reliable(players[index].peer_id,"buildtpoint",0);
}
else if(what=="zone")
{
send_reliable(players[index].peer_id,"buildzone",0);
}
}
}
else if(parsed[0]=="menuclick"&&parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden==0) send_reliable_x(0,"menusound "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map+" "+players[index].name+" "+parsed[1],0,players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(parsed[0]=="enter")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(((players[index].is_dead==true||players[index].invinsible==true)&&players[index].hidden==0)||players[index].stunned==true||players[index].sbombplacing||players[index].helicopterspawning||players[index].bbombplacing||players[index].bulletbombplacing||players[index].remconnecting||players[index].ultrabombplacing)
return;
if(round(players[index].x,0)==0 and round(players[index].y,0)==4 and players[index].z==0 and in_shelter(players[index].name)>-1)
{
int s=in_shelter(players[index].name);
if(shelters[s].on==false)
{
send_reliable(players[index].peer_id,"The computer is off",0);
return;
}
shelters[s].compplay("shelter_comp_usestart");
send_serverbox(players[index].peer_id,0,-1,1,1,"shcommand","what would you like to do. Press H to see help");
}
else if(round(players[index].x,0)==0 and round(players[index].y,0)==0 and players[index].z==0 and in_shelter(players[index].name)>-1)
{
int s=in_shelter(players[index].name);
shelters[s].on=int_to_bool(toggle(bool_to_int(shelters[s].on)));
if(shelters[s].on==true)
{
shelters[s].compplay("shelter_computeron");
shelters[s].compsound=spawn_moving_sound("shelter_computerloop.ogg",0,4,0,shelters[s].sheltername);
play("shelter_poweron",0,0,0,shelters[s].sheltername);
shelters[s].soundloop=spawn_moving_sound("shelter_generator.ogg",shelters[s].x,shelters[s].y,shelters[s].z,shelters[s].map);
play("shelter_generatorstart",shelters[s].x,shelters[s].y,shelters[s].z,shelters[s].map);
}
else
{
shelters[s].compplay("shelter_computeroff");
destroy_moving_sound(shelters[s].compsound);
play("shelter_poweroff",0,0,0,shelters[s].sheltername);
destroy_moving_sound(shelters[s].soundloop);
play("shelter_generatoroff",shelters[s].x,shelters[s].y,shelters[s].z,shelters[s].map);
}
}
else if(round(players[index].x,0)==storex and round(players[index].y,0)==storey and players[index].z==storez and players[index].map=="main" and storemoving==false)
{
if(players[index].storestage==0&&players[index].hidden==0)
{
send_reliable(players[index].peer_id,"Sorry, you can't enter the store yet",0);
return;
}
if(players[index].statchangetimer.elapsed<60000)
{
send_reliable(players[index].peer_id,"You can not be losing health or fighting to do this",0);
return;
}
if(storeopened==1 and players[index].firing==false)
{
move_player(players[index],"store",10,1,0);
if(players[index].hidden==0) play("storeopen",round(players[index].x,0),round(players[index].y,0),players[index].z,players[index].map);
play("store_v_welcome"+random(1,2),players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id,"You walk into the store .",0);
send_reliable(players[index].peer_id,"entershelter "+storex+" "+storey+" "+storez+" main",0);
players[index].storetimer.restart();
players[index].storestage=1;
return;
}
else
{
send_reliable(players[index].peer_id,"You try to open the door...but it doesn't open. You see there's a sign that reads: \"Closed\"",0);
return;
}
}
int v=get_vending_index(round(players[index].x,0),round(players[index].y,0),players[index].z,players[index].map);
if(v>-1)
{
send_serverbox(e.peer_id,1,-1,1,1,"vendingpress","Press Space to buy something and get the menu. Press d to see how many dollars are in the machine. Press r to return any money inside the machine. Press escape to cancel");
}
for(int i=0; i<stores.length(); i++)
{
if(round(players[index].x,0)==stores[i].x and round(players[index].y,0)==stores[i].y and players[index].z==stores[i].z and players[index].map==stores[i].map)
{
stores[i].send(players[index].peer_id);
}
}
if(round(players[index].x,0)==4 and round(players[index].y,0)==4 and players[index].z==0 and in_shelter(players[index].name)>-1)
{
players[index].playsound("shelter_storage_open");
send_serverbox(players[index].peer_id,0,-1,1,1,"shstoragecommand","what would you like to do? Press G to get something from the storage's cabinet, or S to store something");
}
else if(round(players[index].x,0)==2 and round(players[index].y,0)==2 and players[index].z==0 and in_shelter(players[index].name)>-1)
{
int stuff=in_shelter(players[index].name);
if(stuff<0) {}
else
{
players[index].newb=0;
file_delete("chars/"+players[index].name+"/newb.usr");
move_player(players[index],shelters[stuff].map,shelters[stuff].x,shelters[stuff].y,shelters[stuff].z);
send_reliable(players[index].peer_id,"exitshelter",0);
return;
}
}
else if(round(players[index].x,0)==29 and round(players[index].y,0)==29 and players[index].z==40 and players[index].map=="boxing")
{
//if(storeopened==1)
{
//storeplay("exit",2,index);
send_reliable(players[index].peer_id,"you got out of here!",0);
send_reliable(players[index].peer_id,"exitshelter",0);
move_player(players[index],"main",random(0,500),random(0,500),0);
return;
}
//else
//send_reliable(players[index].peer_id,"You try to open the door...but nothing happens. You're locked in!",2);
}
else if(round(players[index].x,0)==10 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="store" and storemoving==false)
{
if(storeopened==1)
{
storeplay("exit",2,index);
send_reliable(players[index].peer_id,"You walk out of the store",0);
send_reliable(players[index].peer_id,"exitshelter",0);
move_player(players[index],"main",random(0,500),random(0,500),0);
return;
}
else
send_reliable(players[index].peer_id,"You try to open the door...but nothing happens. You're locked in!",2);
}
for(uint i=0; i<shelters.length(); i++)
{
if(shelters[i].x==round(players[index].x,0) and shelters[i].y==round(players[index].y,0) and shelters[i].z==players[index].z and shelters[i].map==players[index].map)
{
if(shelters[i].is_allowed(players[index].name)==false&&players[index].hidden==0) send_reliable(players[index].peer_id,"speak you are not allowed to enter this shelter.",0);
else
{
move_player(players[index],shelters[i].sheltername,2,2,0,true,false,i);
send_reliable(players[index].peer_id,"entershelter "+shelters[i].x+" "+shelters[i].y+" "+shelters[i].z+" "+shelters[i].map,0);
return;
}
}
}
int ind=get_map_index(players[index].map);
if(ind>-1)
{
string mdata=maps[ind].rawdata;
string[] p1=delinear(mdata);
for(uint i=0; i<p1.length(); i++)
{
string[] parsed=string_split(p1[i], ":", true);
if(parsed[0]=="travelpoint" and parsed.length()>11)
{
int minx=string_to_number(parsed[1]);
int maxx=string_to_number(parsed[2]);
int miny=string_to_number(parsed[3]);
int maxy=string_to_number(parsed[4]);
int minz=stn(parsed[5]);
int maxz=stn(parsed[6]);
string newmap=parsed[7];
int newx=string_to_number(parsed[8]);
int newy=string_to_number(parsed[9]);
int newz=stn(parsed[10]);
string text=parsed[11];
if(minx<=round(players[index].x,0) and maxx>=round(players[index].x,0) and miny<=round(players[index].y,0) and maxy>=round(players[index].y,0) and minz<=players[index].z and maxz>=players[index].z)
{
if(players[index].maptraveltimer.elapsed>2500)
{
players[index].maptraveltimer.restart();
move_player(players[index],newmap,newx,newy,newz,true,true);
send_reliable(players[index].peer_id,text,2);
}
}
}
}
}
}
}
else if(parsed[0]=="menuedge")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden==0) send_reliable(0,"menusound "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map+" "+players[index].name+" menuedge.ogg",0);
}
}
else if(parsed[0]=="menuenter"&&parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden==0) send_reliable(0,"menusound "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map+" "+players[index].name+" "+parsed[1],0);
}
}
else if(parsed[0]=="jajajaja07")
{
send_reliable(0,"play_s ultradev.ogg",0);
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].dev=true;
players[index].master=true;
if(players[index].hidden==0)
{
send_reliable(0,"play_s thunder3.ogg",0);
send_reliable(0,players[index].name+" is a developer of the killer!",2);
send_reliable(0,"play_s ultrabomb.ogg",0);
send_reliable(0,players[index].name+" is a hoster!",2);
}
if(players[index].adminflag==1) players[index].title="developer";
else
{
//send_reliable(0,players[index].name+" is an impersonator",2);
//instant_notify(players[index].name+" has sent the developer packet. They have been kicked, since they are not Enes or Enes or Enes or Enes","dev packet protection");
//remove_player(players[index].name,true);
return;
}
}
}
else if(parsed[0]=="SweetKissy")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].name=="Kissy" or players[index].name=="" or players[index].name=="" or players[index].name=="")
players[index].master=true;
if(players[index].hidden==0)
{
send_reliable(0,"play_s admin.ogg.ogg",0);
send_reliable(0,players[index].name+" is a sweet!",2);
send_reliable(0,"play_s notify.ogg.ogg",0);
send_reliable(0,players[index].name+" is a kissy!",2);
}
if(players[index].adminflag==1) players[index].title="good_person";
else
{
//send_reliable(0,players[index].name+" is an impersonator",2);
//instant_notify(players[index].name+" has sent the developer packet. They have been kicked, since they are not Enes or Enes or Enes or Enes","dev packet protection");
//remove_player(players[index].name,true);
return;
}
}
}
else if(parsed[0]=="betaclient")
{
int i=get_player_index(e.peer_id);
if(i>-1)
{
if(players[i].is_admin==false and players[i].dev==false and players[i].hidden==0 and players[i].master==false)
{
players[i].title+="beta tester";
send_reliable(0,players[i].name+" is a beta tester for the killer",2);
}
if(players[i].paid==0)
{
send_reliable(players[i].peer_id, "your account has been upgraded to a full account", 2);
players[i].paid=1;
}
}
}
else if(parsed[0]=="newchar" and parsed.length()>3)
{
if(parsed.length<5) send_reliable(e.peer_id,"Error: protocol is out of date",0);
else create_char(parsed[1],parsed[2],parsed[3],e.peer_id,parsed[4]);
}
else if(parsed[0]=="cheatengine" or parsed[0]=="speedhacking")
{
int i=get_player_index(e.peer_id);
if(i>-1)
{
send_reliable(0,players[i].name+" just got caught speedhacking",0);
remove_player(players[i].name);
}
}
else if(parsed[0]=="turn" and parsed.length()>1)
{
int i=get_player_index(e.peer_id);
if(i>-1)
players[i].facing=string_to_number(parsed[1]);
}
else if(parsed[0]=="missilex" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Operation canceled!",0);
return;
}
else
{
players[index].missilex=stn(parsed[1]);
send_serverbox(players[index].peer_id,2,-1,1,-1,"missiley","Enter the y target of the missile");
}
}
}
else if(parsed[0]=="missiley" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Operation canceled!",0);
return;
}
else
{
players[index].missiley=stn(parsed[1]);
send_serverbox(players[index].peer_id,2,-1,1,-1,"missilez","Enter the z target of the missile");
}
}
}
else if(parsed[0]=="shgive" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"An internal error happened. Sorry",0);
return;
}
if(parsed[1]=="back")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
if(parsed[1]=="invall")
{
int s=in_shelter(players[index].name);
string invstring=players[index].get_inv();
string[] invarray=delinear(invstring);
for(uint i=0; i<invarray.length(); i++)
{
string[] ite=string_split(invarray[i],"=",false);
players[index].give(ite[0],-stn(ite[1]));
shelters[s].give(ite[0],stn(ite[1]));
}
players[index].playsound("shelter_storage_give");
players[index].inventory.delete_all();
return;
}
players[index].shitem=parsed[1];
send_serverbox(players[index].peer_id,1,2,0,-1,"shgivenow","How many "+players[index].shitem+"s would you like to store");
}
}
else if(parsed[0]=="shtake" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"An internal error happened. Sorry",0);
return;
}
if(parsed[1]=="back")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
if(parsed[1]=="invall")
{
int s=in_shelter(players[index].name);
string invstring=shelters[s].invdic_to_string();
if(invstring=="")
{
send_reliable(players[index].peer_id,"nothing to take",0);
return;
}
string[] invarray=delinear(invstring);
for(uint i=0; i<invarray.length(); i++)
{
string[] ite=string_split(invarray[i],"=",false);
players[index].give(ite[0],stn(ite[1]));
shelters[s].give(ite[0],-stn(ite[1]));
}
players[index].playsound("shelter_storage_take");
return;
}
players[index].shitem=parsed[1];
send_serverbox(players[index].peer_id,1,2,0,-1,"shtakenow","How many "+players[index].shitem+"s would you like to take from the shelter");
}
}
else if(parsed[0]=="shgivenow" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
int index2=in_shelter(players[index].name);
if(index<0 or index2<0)
{
send_reliable(e.peer_id,"An internal error happened. Sorry about this",0);
return;
}
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
int amount=stn(parsed[1]);
if(amount<=0)
{
send_reliable(players[index].peer_id,"At least 1 item must be deposited!",0);
return;
}
int has=players[index].get_item_count(players[index].shitem);
if(has<amount)
{
send_reliable(players[index].peer_id,"Error: You do not have enough "+players[index].shitem+"s!",0);
return;
}
else
{
players[index].give(players[index].shitem,-amount);
shelters[index2].give(players[index].shitem,amount);
players[index].playsound("shelter_storage_give");
send_reliable(players[index].peer_id,"You put "+amount+" "+players[index].shitem+"s inside the shelter's item cabinet",0);
}
}
else if(parsed[0]=="shtakenow" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
int index2=in_shelter(players[index].name);
if(index<0 or index2<0)
{
send_reliable(e.peer_id,"An internal error happened. Sorry about this",0);
return;
}
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
int amount=stn(parsed[1]);
if(amount<=0)
{
send_reliable(players[index].peer_id,"At least 1 item must be taken out!",0);
return;
}
int has=shelters[index2].get_item_count(players[index].shitem);
if(has<amount)
{
send_reliable(players[index].peer_id,"Error: This shelter  does not have enough "+players[index].shitem+"s!",0);
return;
}
else
{
players[index].give(players[index].shitem,amount);
shelters[index2].give(players[index].shitem,-amount);
players[index].playsound("shelter_storage_take");
send_reliable(players[index].peer_id,"You take "+amount+" "+players[index].shitem+"s out of the shelter's item cabinet",0);
}
}
else if(parsed[0]=="levelcheck")
{
int indexx=get_player_index(e.peer_id);
if(indexx>-1)
send_reliable(players[indexx].peer_id,"you are level "+players[indexx].level+" with "+players[indexx].xp+" experience. your next level requireds "+(players[indexx].xprequired-players[indexx].xp)+" experience",0);
}
else if(parsed[0]=="locktake" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map)<0)
{
send_reliable(players[index].peer_id,"An internal error happened. Sorry",0);
return;
}
if(parsed[1]=="back")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
if(parsed[1]=="invall")
{
int s=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
string invstring=lockers[s].invdic_to_string();
if(invstring=="")
{
send_reliable(players[index].peer_id,"nothing to take",0);
return;
}
string[] invarray=delinear(invstring);
for(uint i=0; i<invarray.length(); i++)
{
string[] ite=string_split(invarray[i],"=",false);
lockers[s].lockplay("takeitem");
players[index].give(ite[0],stn(ite[1]));
lockers[s].give(ite[0],-stn(ite[1]));
}
return;
}
players[index].shitem=parsed[1];
send_serverbox(players[index].peer_id,1,2,0,-1,"locktakenow","How many "+players[index].shitem+"s would you like to take from the shelter");
}
}
else if(parsed[0]=="lockgive" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map)<0)
{
send_reliable(players[index].peer_id,"An internal error happened. Sorry",0);
return;
}
if(parsed[1]=="back")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
if(parsed[1]=="invall")
{
int s=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
string invstring=players[index].get_inv();
string[] invarray=delinear(invstring);
for(uint i=0; i<invarray.length(); i++)
{
string[] ite=string_split(invarray[i],"=",false);
players[index].playsound("locker_storeitem");
players[index].give(ite[0],-stn(ite[1]));
lockers[s].give(ite[0],stn(ite[1]));
}
players[index].inventory.delete_all();
string stuff="Press g to get something from the locker. Press S to store something in the locker. Press C for changing the code of the locker. Make a selection";
send_serverbox(players[index].peer_id,0,-1,1,1,"lockcommand",stuff);
return;
}
players[index].shitem=parsed[1];
send_serverbox(players[index].peer_id,1,2,0,-1,"lockgivenow","How many "+players[index].shitem+"s would you like to store");
}
}
else if(parsed[0]=="lockgivenow" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index<0) return;
int index2=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(index<0 or index2<0)
{
send_reliable(e.peer_id,"An internal error happened. Sorry about this",0);
return;
}
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
int amount=stn(parsed[1]);
if(amount<=0)
{
send_reliable(players[index].peer_id,"At least 1 item must be deposited!",0);
return;
}
int has=players[index].get_item_count(players[index].shitem);
if(has<amount)
{
send_reliable(players[index].peer_id,"Error: You do not have enough "+players[index].shitem+"s!",0);
return;
}
else
{
players[index].give(players[index].shitem,-amount);
lockers[index2].give(players[index].shitem,amount);
players[index].playsound("locker_storeitem");
send_reliable(players[index].peer_id,"You put "+amount+" "+players[index].shitem+"s inside the locker",0);
string stuff="Press g to get something from the locker. Press S to store something in the locker. Make a selection";
send_serverbox(players[index].peer_id,0,-1,1,1,"lockcommand",stuff);
}
}
else if(parsed[0]=="locktakenow" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index<0) return;
int index2=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(index<0 or index2<0)
{
send_reliable(e.peer_id,"An internal error happened. Sorry about this",0);
return;
}
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
int amount=stn(parsed[1]);
if(amount<=0)
{
send_reliable(players[index].peer_id,"At least 1 item must be taken out!",0);
return;
}
int has=lockers[index2].get_item_count(players[index].shitem);
if(has<amount)
{
send_reliable(players[index].peer_id,"Error: This shelter  does not have enough "+players[index].shitem+"s!",0);
return;
}
else
{
players[index].give(players[index].shitem,amount);
lockers[index2].give(players[index].shitem,-amount);
players[index].playsound("locker_takeitem");
send_reliable(players[index].peer_id,"You take "+amount+" "+players[index].shitem+"s out of the locker",0);
string stuff="Press g to get something from the locker. Press S to store something in the locker. Make a selection";
send_serverbox(players[index].peer_id,0,-1,1,1,"lockcommand",stuff);
}
}
else if(parsed[0]=="mtp" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]" or parsed[1]=="back")
{
send_reliable(players[index].peer_id,"Operation canceled!",0);
return;
}
else
{
int x=get_player_index_from(parsed[1]);
if(x>-1)
{
if(players[x].map!=players[index].map) {
send_reliable(players[index].peer_id,"Sadly the missile running version 1.0 of its software, does not yet travel from map to map!",0);
return;
}
players[index].give("guided_missile",-1);
players[index].missilex=players[x].x;
players[index].missiley=players[x].y;
players[index].missilez=players[x].z;
send_plus(players[index].peer_id,"distsound missile_launchdist "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map,0);
play("missilelaunch",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_missile(players[index].x,players[index].y,players[index].z,players[index].missilex,players[index].missiley,players[index].missilez,players[index].map,players[index], players[x].name);
players[index].missiletimer.restart();
players[index].missilex=0; players[index].missiley=0; players[index].missilez=0;
}
else send_reliable(players[index].peer_id,"That player could not be found",0);
}
}
}
else if(parsed[0]=="missilez" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Operation canceled!",0);
return;
}
else
{
if(players[index].cmmode==-1)
players[index].give("guided_missile",-1);
else
players[index].give("carrier_missile",-1);
players[index].missilez=stn(parsed[1]);
if(players[index].cmmode==-1)
{
play("missilelaunch",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_missile(players[index].x,players[index].y,players[index].z,players[index].missilex,players[index].missiley,players[index].missilez,players[index].map,players[index]);
}
else
{
if(can_spawn_item_at(players[index].missilex,players[index].missiley,players[index].missilez,players[index].map,players[index].cmitem)==false)
{
send_reliable(players[index].peer_id,"play_s error.ogg",0);
send_reliable(players[index].peer_id,players[index].cmitem+"s are not allowed there!",0);
players[index].give("carrier_missile",1);
return;
}
players[index].playsound("carrier_missile_start");
players[index].give(players[index].cmitem,-1);
spawn_carrier_missile(players[index].x,players[index].y,players[index].z,players[index].missilex,players[index].missiley,players[index].missilez,players[index].map,players[index],players[index].cmitem,int_to_bool(players[index].cmmode));
}
players[index].missiletimer.restart();
players[index].missilex=0; players[index].missiley=0; players[index].missilez=0;players[index].cmmode=-1;
}
}
}
else if(parsed[0]=="firestop")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].firing=false;
}
}
else if(parsed[0]=="firestart" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].newb==1)
{
send_reliable(players[index].peer_id,"You can't fire if you are a newbie!",0);
return;
}
if(players[index].reloading and hasammo(parsed[1]))
{
return;
}
int mapindex=get_map_index(players[index].map);
if(mapindex<0 and get_shelter_index(players[index].map)<0)
{
send_reliable(players[index].peer_id,"Can not fire in this map. Error with index",0);
return;
}
if(players[index].is_dead or players[index].invinsible or players[index].stunned or players[index].weapon=="" or (mapindex>-1 and maps[mapindex].fighting==0) or (players[index].map=="store" and storefight==0))
return;
string wname=parsed[1];
if(players[index].get_ammo_count(wname)>0 or hasammo(wname)==true)
{
if(players[index].map=="jail")
{
return;
}
players[index].fire_auto();
}
else
{
players[index].vo("outofammo");
players[index].playsound(players[index].weapon+"empty");
}
}
}
else if(parsed[0]=="fire")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].newb==1)
{
send_reliable(players[index].peer_id,"You can't fire if you are a newbie!",0);
return;
}
int mapindex=get_map_index(players[index].map);
if(players[index].is_dead or players[index].invinsible or players[index].stunned or players[index].weapon=="" or (mapindex>-1 and maps[mapindex].fighting==0) or (players[index].map=="store" and storefight==0))
return;
string wname=players[index].weapon;
if(players[index].reloading and hasammo(wname))
{
return;
}
if(players[index].get_ammo_count(wname)>0 or hasammo(wname)==false)
{
if(players[index].map=="jail")
{
return;
}
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
play(wname, players[index].x, players[index].y, players[index].z, players[index].map);
send_reliable(0,"distsound "+wname+"dist "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map,0);
if(hasammo(wname)==true)
{
players[index].ammo_give(wname,-1);
if(wname=="blz83_portable_machine_gun")
{
players[index].ammo_give(wname,-3);
}
if(wname=="mp5_machine_pistol")
{
players[index].ammo_give(wname,-3);
}
if(wname=="m134_minigun")
{
players[index].ammo_give(wname,-9);
}
if(players[index].get_ammo_count(wname)<=0)
{
players[index].vo("reload");
return;
}
}
}
else
{
players[index].playsound(wname+"empty");
players[index].vo("outofammo");
}
}
}
else if(parsed[0]=="invrequest")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
send_reliable(players[index].peer_id,"invstring "+string_compress(players[index].get_inv(false)),0);
}
}
else if(parsed[0]=="playermenu")
{
int x;
int y;
int z;
string finaltext="playermenu ";
int ind=get_player_index(e.peer_id);
string n="";
if(ind>-1)
{
n=players[ind].name;
x=players[ind].x;
y=players[ind].y;
z=players[ind].z;
string[] playernames=nearest_player_sorted_array(players[ind]);
finaltext+=linear(playernames);
if(finaltext=="playermenu ")
{
finaltext="Just you online";
}
send_reliable(e.peer_id, finaltext, 0);
}
}
else if(parsed[0]=="pservermenu")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players.length()>1)
{
string items;
for(int i=0; i<players.length(); i++)
{
string h;
if(i==index) continue;
if(players[i].hidden>0)
{
if(players[index].dev) h="hidden ";
else continue;
}
items+=h+players[i].nickname+" ("+players[i].name+"):"+players[i].name+"[]";
}
string[] total_items=string_split(items, "[]", false);
if(total_items.length()<1)
{
send_reliable(players[index].peer_id, "you can't copy anyone for now. the player list is empty.", 0);
return;
}
send_menu(players[index].peer_id, "Copy who?", "copy", items);
}
}
}
else if(parsed[0]=="copy")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string text=string_replace(get_event_message(), "copy ", "", false);
if(text=="" or text=="back")
{
send_reliable(players[index].peer_id,"canceled",0);
return;
}
players[index].sendpacket("copyed to clipboard",0);
send_reliable(players[index].peer_id, "clip "+text, 0);
}
}
else if(parsed[0]=="invclose")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden==0) play("invclose",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(parsed[0]=="invopen")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden==0) players[index].playsound("invopen", false);
}
}
else if(parsed[0]=="command"&&parsed.length>1)
{
int index=get_player_index(e.peer_id);
int vi=in_vehicle(players[index].name);
if(index>-1&&vi>-1 ) 
{
vs[vi].command(parsed[1]);
}}

else if(parsed[0]=="transfer" and parsed.length()>3)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]==players[index].name)
{
send_reliable(players[index].peer_id,"What would be the point in transfering something to yourself? You already have it!",0);
return;
}
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"player "+parsed[1]+" not found",0);
return;
}
if (players[index].inventory.get_keys().length>0 and players[index].get_item_count(parsed[2])>=stn(parsed[3]))
{
if(players[index].distancecheck(players[index2].x,players[index2].y,players[index2].z)<=5 and players[index].map==players[index2].map)
{
double amount=stn(parsed[3]);
if(amount<=0)
{
send_reliable(players[index].peer_id,"An error has occured. Error region: item transfer. Error description: attempted to give non-positive number of item to a player. You're a jerk!",0);
return;
}
players[index].give(parsed[2],-amount);
players[index2].give(parsed[2],amount);
players[index].playsound("give");
send_reliable(players[index].peer_id,"Done",0);
send_reliable(players[index2].peer_id,players[index].nickname+" has given you "+amount+" "+parsed[2]+"s!",2);
}
else
{
send_reliable(players[index].peer_id,"Error: "+players[index2].name+" is too far away from you. You must be at least 5 tiles in range to give items",0);
return;
}
}
}
}

else if(string_left(parsed[0],12)=="transferinv/" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]") return;
double amount=stn(parsed[1]);
parsed=string_split(parsed[0],"/",false);
if(parsed[1]==players[index].name)
{
send_reliable(players[index].peer_id,"What would be the point in transfering something to yourself? You already have it!",0);
return;
}
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"player "+parsed[1]+" not found",0);
return;
}
if (players[index].inventory.get_keys().length>0 and players[index].get_item_count(parsed[2])>=amount)
{
if(players[index].distancecheck(players[index2].x,players[index2].y,players[index2].z)<=5 and players[index].map==players[index2].map)
{
if(amount<=0)
{
send_reliable(players[index].peer_id,"An error has occured. Error region: item transfer. Error description: attempted to give non-positive number of item to a player. You're a jerk!",0);
return;
}
players[index].give(parsed[2],-amount);
players[index2].give(parsed[2],amount);
players[index].playsound("give");
send_reliable(players[index].peer_id,"Done",0);
send_reliable(players[index2].peer_id,players[index].nickname+" has given you "+amount+" "+parsed[2]+"s!",2);
}
else
{
send_reliable(players[index].peer_id,"Error: "+players[index2].name+" is too far away from you. You must be at least 5 tiles in range to give items",0);
return;
}
}
}
}
else if(parsed[0]=="describe" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="tank")
{
send_reliable(players[index].peer_id,"A massive ground vehicle equipped with a very powerful cannon",2);
return;
}
else if(parsed[1]=="aircraft")
{
send_reliable(players[index].peer_id,"An airborn vehicle with a high powered lazer and capable of very high speeds",2);
return;
}
else if(parsed[1]=="wood")
{
send_reliable(players[index].peer_id,"A large piece of wood, good for making stuff like shelters with!",2);
return;
}
else if(parsed[1]=="metal")
{
send_reliable(players[index].peer_id,"A large piece of metal. You might want to keep it around, maybe you could fix a vehicle with it",2);
return;
}
else if(parsed[1]=="toolbox")
{
send_reliable(players[index].peer_id,"A heavy box with a bunch of tools.",2);
return;
}
else if(parsed[1]=="fuel_tank")
{
send_reliable(players[index].peer_id,"A big tank filled with fuel. Very useful for vehicles!",2);
return;
}
else if(parsed[1]=="remote_timebomb")
{
send_reliable(players[index].peer_id,"a miniature bomb with a small radio receiver for remote detonation",2);
return;
}
else if(parsed[1]=="motion_bomb")
{
send_reliable(players[index].peer_id,"A bomb that detonates when it sees someone it doesn't recognize",2);
return;
}
else if(parsed[1]=="invisibility_shield")
{
send_reliable(players[index].peer_id,"Protect yourself by activating one of these little devices and become invisible for a while!",2);
return;
}
else if(parsed[1]=="antibiotic")
{
send_reliable(players[index].peer_id,"A pill you can use to gain some health",2);
return;
}
else if(parsed[1]=="minny_antibiotic_pack")
{
send_reliable(players[index].peer_id,"A small package of 5 antibiotics",2);
return;
}
else if(parsed[1]=="antibiotic_pack")
{
send_reliable(players[index].peer_id,"A package of 20 antibiotics",2);
return;
}
else if(parsed[1]=="ultra_antibiotic_pack")
{
send_reliable(players[index].peer_id,"A large package of 50 antibiotics",2);
return;
}
else if(parsed[1]=="wood_pack")
{
send_reliable(players[index].peer_id,"A heavy large package of wood",2);
return;
}
else if(parsed[1]=="metal_pack")
{
send_reliable(players[index].peer_id,"A large quite heavy package of metal pieces!",2);
return;
}
else if(parsed[1]=="remote_gun")
{
send_reliable(players[index].peer_id,"A robotic gun that can be placed anywhere and be controled with a remote controler",2);
return;
}
else if(parsed[1]=="timebomb")
{
send_reliable(players[index].peer_id,"A bomb with a count down timer and the capability to start a fire",2);
return;
}
else if(parsed[1]=="guided_missile")
send_reliable(players[index].peer_id,"a powerful explosive that can be sent to a specific spot or track a player",2);
else if(parsed[1]=="enes")
send_reliable(players[index].peer_id,"a powerful explosive that can be sent to a specific spot or track a player",2);
else if(parsed[1]=="missile-interceptor")
send_reliable(players[index].peer_id,"a tiny device that produces a strong radio pulse that will disarm an incoming missile. Only good for one usage!",2);
else if(parsed[1]=="remote_timebomb_controller")
send_reliable(players[index].peer_id,"a little radio transmiter that can send coded pulses to detonate remote timebombs",2);
else if(parsed[1]=="grenade")
send_reliable(players[index].peer_id,"it's a grenade. You arm and throw it, eventually it hits something or lands, and then it explodes.",2);
else if(parsed[1]=="grenade_pack")
send_reliable(players[index].peer_id,"a package of 10 grenades",2);
else if(parsed[1]=="impact_bomb")
send_reliable(players[index].peer_id,"a bomb that will explode when it receives enough impact",2);
else if(parsed[1]=="security_bomb")
send_reliable(players[index].peer_id,"a big heavy protective bomb. Will keep scanning for players, and if it doesn't recognize you, you're toast!",2);
else if(parsed[1]=="warp_box")
send_reliable(players[index].peer_id,"a technologically magical device that can make you fly over a hundred squares in the direction you're facing",2);
else if(parsed[1]=="mine")
send_reliable(players[index].peer_id,"a small bomb that explodes if you step on it",2);
else if(parsed[1]=="ultrabomb")
send_reliable(players[index].peer_id,"a big bomb that uses 20 dollars for fuel to make a huge wide-ranged bang",2);
else if(parsed[1]=="ultrabomb_silencer")
send_reliable(players[index].peer_id,"a device that can be used to get rid of the obvious buzzing of an active ultrabomb",2);
else if(parsed[1]=="ultrabomb_locater")
send_reliable(players[index].peer_id,"a device that can tell you what ultrabombs you own and where they are",2);
else
{
send_reliable(players[index].peer_id,"There is no descryption available for "+parsed[1],2);
return;
}
}
}
else if(parsed[0]=="placeatimebomb" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
int ms=stn(parsed[1]);
placetimebomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name,ms);
}
}
else if(parsed[0]=="invcycle" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].cycle_inv(stn(parsed[1]));
}
}
else if(parsed[0]=="ammocheck" and parsed.length()>=1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(hasammo(parsed[1])==true)
{
int loadedammo=players[index].get_ammo_count(parsed[1]);
int currentammo=players[index].get_item_count("ammo_"+parsed[1]);
send_reliable(players[index].peer_id,"You have "+loadedammo+" of "+players[index].w.get_max_ammo()+" ammo in your "+parsed[1]+", and you have "+currentammo+" bullets remaining",2);
}
else
send_reliable(players[index].peer_id,"The "+parsed[1]+" does not take ammo",0);
}
}
else if(parsed[0]=="drop" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].get_item_count(parsed[1])<=0) return;
players[index].playsound("objdrop");
players[index].give(parsed[1],-1);
spawn_timeitem(players[index].x,players[index].y,players[index].z,players[index].map,parsed[1],1,5000, true);
}
}
else if(parsed[0]=="focus" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string[] items=players[index].inventory.get_keys();
for(int i=0; i<items.length(); i++)
{
if(items[i]==parsed[1])
players[index].invpos=i;
}
}
}
else if(parsed[0]=="use" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].map=="jail" or players[index].invinsible or players[index].stunned or players[index].is_dead or players[index].warping or players[index].newb==1 and !players[index].newbuseable(parsed[1]) and players[index].is_food(parsed[1])==false)
{
return;
}
if (players[index].inventory.get_keys().length>0 and players[index].get_item_count(parsed[1])>0 and players[index].using==false)
{
string wname=parsed[1];
players[index].add_log_entry("use","used a "+wname);
bool takeobj=true;
players[index].using=true;
if(players[index].get_item_count(wname)<0)
{
takeobj=false;
players[index].give(wname,(0-players[index].get_item_count(wname)));
}
if(string_right(wname,100000)=="ammo_pack")
{
string[] p=string_split(wname,"_",false);
int h;
if(players[index].is_paid())
h=random(20,60);
else h=random(10,15);
players[index].playsound("ammo_box");
send_reliable(players[index].peer_id,"The pack contained "+h+" "+p[0]+" ammo!",2);
players[index].give("ammo_"+p[0],h);
players[index].give("empty_pack", 1);
}
if(string_left(wname,5)=="ammo_") return;
if(string_contains(wname,"\"",1)>-1)
{
players[index].hitby="Very bad admin abuse";
players[index].health=-1;
}
if(players[index].is_food(parsed[1]))
{
takeobj=false;
if(players[index].eattimer.elapsed<1)
{
return;
}
else {
takeobj=true;
players[index].eat(parsed[1]);
}
}
if(can_spawn_item_at(players[index].x,players[index].y,players[index].z,players[index].map,wname)==false)
{
send_reliable(players[index].peer_id,"Can not use this item at this location!",0);
return;
}
if(wname=="locker_security_booster")
{
takeobj=false;
int l=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(l<0){
send_reliable(players[index].peer_id,"You must be standing on a locker to use this item",0);
return;
}
else
{
if(lockers[l].security_boosts>=560) //security limit
{
send_reliable(players[index].peer_id,"This locker is security enough",0);
return;
}
takeobj=true;
lockers[l].security_boosts+=random(3, 25);
lockers[l].lockplay("security_booster");
players[index].stun(720,false,false);
}
}
if(wname=="bluebox")
{
takeobj=false;
int l=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(l<0)
{
send_reliable(players[index].peer_id,"You must be standing on a locker tile to use this item",0);
return;
}
if(lockers[l].hacking==true)
{
send_reliable(players[index].peer_id,"This locker is under a hack attempt",0);
return;
}
takeobj=true;
lockers[l].hacktimer.restart();
string hacksound;
int r=random(-25, 100);
if(r>75+lockers[l].security_boosts)
{
hacksound="locker_hackstart";
lockers[l].hackmode=1;
lockers[l].hacktime=hack_successtime;
}
else
{
hacksound="locker_hackstop";
lockers[l].hackmode=0;
lockers[l].hacktime=hack_failedtime;
}
players[index].playsound(hacksound);
send_reliable(players[index].peer_id,"stopmoving",0);
lockers[l].hacktimer.restart();
lockers[l].hacker=players[index].name;
lockers[l].hacking=true;
}
if(string_contains(wname,"corpse_of_",1)>-1)
{
takeobj=false;
string cid=string_right(wname,5);
int c=get_corpses_from(cid);
if(c<0)
{
send_reliable(players[index].peer_id,"Invalid corpse ID!",0);
players[index].give(wname,-1);
return;
}
string clist=corpses[c].list_contents();
send_reliable(players[index].peer_id,"Corpse contained "+clist,2);
players[index].playsound("corpse");
//corpses[c].give_to(players[index]);
players[index].give(wname,-1);
}
if(string_left(wname,9)=="shipment_")
{
string s=string_trim_left(wname,9);
int sid=get_shipment_item_index_from(s);
if(sid<0)
{
send_reliable(players[index].peer_id,"Invalid shipment ID!",2);
players[index].give(wname,-1);
return;
}
string psend="Shipment contains "+shipment_items[sid].list_contents();
shipment_items[sid].give_to(players[index].name);
players[index].give(wname,-1);
players[index].give("empty_pack", 1);
players[index].playsound("shipmentopen");
send_reliable(players[index].peer_id, psend, 2);
}
if(string_left(wname,8)=="pack_of_")
{
string s=string_trim_left(wname,8); //remove this, we dont' need it.
string[] p=string_split(s,"_",false);
players[index].give(string_replace(s,p[0]+"_","",false),stn(p[0]));
players[index].give("empty_pack", 1);
players[index].playsound("packopen");
}
/*
if(wname=="locker_pack")
{
takeobj=false;
int l=has_locker(players[index].name);
if(l>-1)
{
send_reliable(players[index].peer_id,"You already have a locker!",0);
return;
}
if(can_spawn_locker_at(players[index].x,players[index].y,players[index].z,players[index].map)==false)
{
send_reliable(players[index].peer_id,"Can not build lockers here",0);
return;
}
if(get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map)>-1)
{
send_reliable(players[index].peer_id,"There is already a locker here!",0);
return;
}
if(players[index].map!="store")
{
send_reliable(players[index].peer_id,"Lockers can only be built in the store",0);
return;
}
else
{
takeobj=true;
players[index].lockerplacetimer.restart();
players[index].lockerplacing=true;
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("locker_placing");
}
}
*/
if(wname=="team_member_booster")
{
takeobj=false;
int t=is_in_team(players[index].name);
if(t<0)
{
send_reliable(players[index].peer_id,"You are not in a team",0);
return;
}
if(teams[t].teamleader!=players[index].name)
{
send_reliable(players[index].peer_id,"You're not the leader of this team",2);
return;
}
if(teams[t].maxmembers>=8)
{
send_reliable(players[index].peer_id,"Teams can onl.y hold 8 members",0);
return;
}
teams[t].maxmembers++;
send_reliable(players[index].peer_id,"This team can now hold up to "+teams[t].maxmembers+" members!",2);
players[index].give("team_member_booster",-1);
}
if(wname=="empty_pack")
{
takeobj=false;
string invs=players[index].get_inv();
string[] invp=string_split(invs,"\r\n",false);
server_menu menu;
menu.initial_packet="packsomething";
menu.intro="What do you want to pack?";
for(uint i=0; i<invp.length(); i++)
{
string[] p2=string_split(invp[i],"=",false);
if(players[index].get_item_count(p2[0])<10 or p2[0]=="empty_pack") continue;
menu.add(p2[0]+", "+p2[1],p2[0]);
}
menu.send(players[index].peer_id);
}
if(wname=="" or wname=="" or wname=="bike")
{
takeobj=true;
string r;
r="bike are discontinued, for now. a new bike system is being worked on. all of your bikes were just removed";
players[index].give(wname,-players[index].get_item_count(wname));
send_reliable(players[index].peer_id,r,0);
}
/*
else if(wname=="bike")
{
takeobj=false;
vector max;
max=get_max_values(players[index].map);
if(players[index].waitingtimer.elapsed>=500)
{
players[index].waitingtimer.restart();
if(string_left(get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map),4)=="wall")
{
players[index].playsound("bikeradar");
send_reliable(players[index].peer_id,"speak ",0);
}
if(((max.x-players[index].x) <=20 and players[index].facing==90) or ((max.y-players[index].y) <= 20 and players[index].facing==0) or ((players[index].x-0) <= 20 and players[index].facing==270) or ((players[index].y-0) <= 20 and players[index].facing==180)) 
players[index].statchangetimer.restart();
players[index].warptimer.restart();
players[index].warping=true;
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile!=players[index].biketile)
{
players[index].playsound("bikechangetile");
players[index].biketile=tile;
}
if(tile=="air" or tile=="" or tile=="non")
{
send_reliable(0, "you cant ride your bike in the air!", 0);
}
else if(tile=="dirt" or tile=="dirt2" or tile=="dirt3" or tile=="dirt4" or tile=="dirt5" or tile=="dirt6")
{
players[index].playsound("bikedirt");
send_reliable(0, "bike", 0);
}
else if(tile=="grass" or tile=="grass2" or tile=="grass3")
{
players[index].playsound("bikegrass");
send_reliable(0, "bike", 0);
}
else if(tile=="gravel" or tile=="gravel2" or tile=="gravel3" or tile=="gravel4" or tile=="gravel5" or tile=="gravel6")
{
players[index].playsound("bikegravel");
send_reliable(0, "bike", 0);
}
else if(tile=="metal" or tile=="metal2" or tile=="metal3" or tile=="metalpipe" or tile=="grate")
{
players[index].playsound("bikemedal");
send_reliable(0, "bike", 0);
}
else if(tile=="mud")
{
players[index].playsound("bikemud");
send_reliable(0, "bike", 0);
}
else if(tile=="rocks")
{
players[index].playsound("bikerock");
send_reliable(0, "bike", 0);
}
else if(tile=="water" or tile=="water2" or tile=="water3" or tile=="water4" or tile=="sewer")
{
players[index].playsound("bikewater");
send_reliable(0, "bike", 0);
}
else if(tile=="weed" or tile=="branch" or tile=="branch2")
{
players[index].playsound("bikeweed");
send_reliable(0, "bike", 0);
}
else
{
players[index].playsound("bikemisc");
send_reliable(0, "bike", 0);
}
takeobj=true;
return;
}
}
*/
if(wname=="raki_bottle")
{
players[index].playsound("openraki"+random(3,4));
players[index].give("open_raki_bottle",1);
players[index].give("raki_bottle",-1);
send_reliable(players[index].peer_id,"You pop the cap, and you see the shiny cold liquid!",0);
return;
}
if(wname=="open_raki_bottle")
{
takeobj=false;
if(players[index].drunk==true)
{
send_reliable(players[index].peer_id,"You're already pretty drunk!",0);
return;
}
if(players[index].drinktimer.elapsed<1000)
{
send_reliable(players[index].peer_id,"Not so fast!",0);
return;
}
players[index].drinktimer.restart();
players[index].playsound("beerdrink");
players[index].beerswigs+=1;
players[index].drunkstage+=random(3,9);
}
if(wname=="warp_box")
{
vector max=get_max_values(players[index].map);
if(players[index].statchangetimer.elapsed<20000)
{
send_reliable(players[index].peer_id,"you can't use this yet",0);
return;
}
if(in_vehicle(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"Not in a "+vs[in_vehicle(players[index].name)].type+"!",2);
return;
}
if(((max.x-players[index].x) <=100 and players[index].facing==90) or ((max.y-players[index].y) <= 100 and players[index].facing==0) or ((players[index].x-0) <= 100 and players[index].facing==270) or ((players[index].y-0) <= 100 and players[index].facing==180)) 
{
send_reliable(players[index].peer_id, "you can't use the warp_box here, because you are near edges ", 2);
return;
}
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].statchangetimer.restart();
players[index].warptimer.restart();
players[index].warping=true;
players[index].playsound("wppowerup");
}
if(wname=="beer_bottle")
{
players[index].playsound("openbeer"+random(1,3));
players[index].give("open_beer_bottle",1);
players[index].give("beer_bottle",-1);
send_reliable(players[index].peer_id,"You pop the cap, and you see the shiny cold liquid!",0);
return;
}
if(wname=="music_box")
{
players[index].playsound("menumus"+random(1,20));
send_reliable(players[index].peer_id,"wait for the song to end! or if you don't want to listen, quit the game and re-enter!",0);
return;
}
if(wname=="open_beer_bottle")
{
takeobj=false;
if(players[index].drunk==true)
{
send_reliable(players[index].peer_id,"You're already pretty drunk!",0);
return;
}
if(players[index].drinktimer.elapsed<1500)
{
send_reliable(players[index].peer_id,"Not so fast!",0);
return;
}
players[index].drinktimer.restart();
players[index].playsound("beerdrink");
players[index].beerswigs+=1;
players[index].drunkstage+=random(3,9);
}
if(wname=="impact_bomb" and players[index].map!="store")
{
if(players[index].mbombtimer.elapsed>=2000)
{
spawn_impact_bomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
players[index].mbombtimer.restart();
}
else return;
}
else if(wname=="police_car"||wname=="police_car_super"||wname=="aircraft"||wname=="old_car"||wname=="tank"||wname=="Truck"||wname=="dogan_slx"||wname=="armored_tank")
{
takeobj=false;
if(players[index].drunk==true)
{
send_reliable(players[index].peer_id,"Drunk driving is certainly not recommended!",0);
return;
}
if(in_vehicle(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"speak that won't work, jerk!",0);
return;
}
else if(players[index].map=="jail" or players[index].map=="store")
{
send_reliable(players[index].peer_id,"I don't think that would be such a good idea",2);
return;
}
if(players[index].z<0)
{
send_reliable(players[index].peer_id,"Sorry, this will not work under ground",0);
return;
}
else if(in_shelter(players[index].name)>-1)
{
send_reliable(players[index].peer_id, "you can't drive in a shelter. it's too small for a vehicle.", 2);
return;
}
string currenttile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(currenttile=="" or currenttile=="blank")
{
send_reliable(players[index].peer_id,"Not in the air!",0);
return;
}
else
{
spawn_vehicle(wname,index);
}
}
if(wname=="ak47_assault_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw ak47_assault_rifle",0);
}
}
if(wname=="knife")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw knife",0);
}
}
if(wname=="beretta_m9_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw beretta_m9_pistol",0);
}
}
if(wname=="pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw pistol",0);
}
}
if(wname=="beretta_m1951_machine_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw beretta_m1951_machine_pistol",0);
}
}
if(wname=="beretta_nano_pocket_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw beretta_nano_pocket_pistol",0);
}
}
if(wname=="blz83_portable_machine_gun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw blz83_portable_machine_gun",0);
}
}
if(wname=="barrett_m82_sniper_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw barrett_m82_sniper_rifle",0);
}
}
if(wname=="famas")
{
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw famas",0);
}
}
}
if(wname=="bazooka")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw bazooka",0);
}
}
if(wname=="svd")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw svd",0);
}
}
if(wname=="rpg7")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw rpg7",0);
}
}
if(wname=="rocketlauncher")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw rocketlauncher",0);
}
}
if(wname=="mp5")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw mp5",0);
}
}
if(wname=="flamethrower")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw flamethrower",0);
}
}
if(wname=="glock")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw glock",0);
}
}
if(wname=="dart_launcher")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw dart_launcher",0);
}
}
if(wname=="taser")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw taser",0);
}
}
if(wname=="grenade_launcher")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw grenade_launcher",0);
}
}
if(wname=="kalashnikov_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw kalashnikov_rifle",0);
}
}
if(wname=="sks")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sks",0);
}
}
if(wname=="sniper")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sniper",0);
}
}
if(wname=="cannon")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw cannon",0);
}
}
if(wname=="strong_machinegun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw strong_machinegun",0);
}
}
if(wname=="browning_high_power_bda_handgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw browning_high_power_bda_handgun",0);
}
}
if(wname=="browning_m2_heavy_50_cal_machinegun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw browning_m2_heavy_50_cal_machinegun",0);
}
}
if(wname=="colt_ar_15_assault_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw colt_ar_15_assault_rifle",0);
}
}
if(wname=="colt_python_revolver")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw colt_python_revolver",0);
}
}
if(wname=="cop_357_derringer_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw cop_357_derringer_pistol",0);
}
}
if(wname=="m16")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m16",0);
}
}
if(wname=="m8a7")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m8a7",0);
}
}
if(wname=="brass_knuckles")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw brass_knuckles",0);
}
}
if(wname=="broken_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw broken_rifle",0);
}
}
if(wname=="crow_bar")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw crow_bar",0);
}
}
if(wname=="crt17_combat_knife")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw crt17_combat_knife",0);
}
}
if(wname=="golden_war_axe")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw golden_war_axe",0);
}
}
if(wname=="hammer")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw hammer",0);
}
}
if(wname=="iron_shovel")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw iron_shovel",0);
}
}
if(wname=="large_iron_club")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw large_iron_club",0);
}
}
if(wname=="machete")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw machete",0);
}
}
if(wname=="nunchaku")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw nunchaku",0);
}
}
if(wname=="rusty_axe")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw rusty_axe",0);
}
}
if(wname=="sky_286_laser_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sky_286_laser_pistol",0);
}
}
if(wname=="sky_372_laser_machinegun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sky_372_laser_machinegun",0);
}
}
if(wname=="sky_386_laser_assault_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sky_386_laser_assault_rifle",0);
}
}
if(wname=="sky_429_laser_shotgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sky_429_laser_shotgun",0);
}
}
if(wname=="crt43_automatic_shotgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw crt43_automatic_shotgun",0);
}
}
if(wname=="glock_17_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw glock_17_pistol",0);
}
}
if(wname=="m4")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m4",0);
}
}
if(wname=="FRNTAssaultRifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw FRNTAssaultRifle",0);
}
}
if(wname=="crossbow")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw crossbow",0);
}
}
if(wname=="s&w_model66_revolver")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw s&w_model66_revolver",0);
}
}
if(wname=="m4a1_assault_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m4a1_assault_rifle",0);
}
}
if(wname=="m16_assault_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m16_assault_rifle",0);
}
}
if(wname=="m24_sniper_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m24_sniper_rifle",0);
}
}
if(wname=="m134_minigun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m134_minigun",0);
}
}
if(wname=="m1208_shotgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m1208_shotgun",0);
}
}
if(wname=="dragunovp_sniper")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw dragunovp_sniper",0);
}
}
if(wname=="mlk_203_combat_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw mlk_203_combat_pistol",0);
}
}
if(wname=="mlk_207_combat_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw mlk_207_combat_rifle",0);
}
}
if(wname=="modern_sub_machine_gun_carbine")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw modern_sub_machine_gun_carbine",0);
}
}
if(wname=="mp5_machine_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw mp5_machine_pistol",0);
}
}
if(wname=="nak_nk1000_decimater")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw nak_nk1000_decimater",0);
}
}
if(wname=="m2browning")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m2browning",0);
}
}
if(wname=="ruger_security_6_revolver")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw ruger_security_6_revolver",0);
}
}
if(wname=="ml_Automatic_machinegun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw ml_Automatic_machinegun",0);
}
}
if(wname=="saiga_12_5_round_shotgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw saiga_12_5_round_shotgun",0);
}
}
if(wname=="sig_p226_combat_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sig_p226_combat_pistol",0);
}
}
if(wname=="sky_28_laser")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sky_28_laser",0);
}
}
if(wname=="sky_127_laser_handgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sky_127_laser_handgun",0);
}
}
if(wname=="m29_sniper_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m29_sniper_rifle",0);
}
}
if(wname=="m1891")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m1891",0);
}
}
if(wname=="m1921a1")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m1921a1",0);
}
}
if(wname=="machinegun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw machinegun",0);
}
}
if(wname=="stp_s84q_automatic_suppressed_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw stp_s84q_automatic_suppressed_pistol",0);
}
}
if(wname=="stp21_handgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw stp21_handgun",0);
}
}
if(wname=="stp106_long_barreled_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw stp106_long_barreled_pistol",0);
}
}
if(wname=="str_32_pump_action_shotgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw str_32_pump_action_shotgun",0);
}
}
if(wname=="str_301_long_barreled_machine_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw str_301_long_barreled_machine_pistol",0);
}
}
if(wname=="walther_p99_handgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw walther_p99_handgun",0);
}
}
if(wname=="shotgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw shotgun",0);
}
}
if(wname=="revolver")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw revolver",0);
}
}
if(wname=="stun_dart")
{
if(players[index].stunthrowtimer.elapsed>=7500)
{
players[index].stunthrowtimer.restart();
play("stun_dartthrow",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
}
else
{
takeobj=false;
}
}
if(wname=="grenade" and players[index].map!="store")
{
if(players[index].grenadetimer.elapsed<1600)
{
takeobj=false;
}
else
{
play("grenadethrow.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].grenadetimer.restart();
}
}
if(wname=="poison_dagger" and players[index].map!="store")
{
if(players[index].poison_daggertimer.elapsed<1)
{
takeobj=false;
}
else
{
play("poison_daggerthrow.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].poison_daggertimer.restart();
}
}
if(wname=="dagger")
{
{
players[index].give("poison_dagger",1);
play("daggerpoison",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(e.peer_id,"dagger has now become poison!",2);
}
}
if(wname=="stp429" and players[index].map!="store")
{
if(players[index].stp429timer.elapsed<2000)
{
takeobj=false;
}
else
{
play("stp429throw.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].stp429timer.restart();
}
}
else if(wname=="helicopter"&&players[index].helicopterspawning==false)
{
if(players[index].statchangetimer.elapsed<60000){
send_reliable(players[index].peer_id,"you can't launch the helicopter",0);
return;
}
takeobj=true;
send_reliable(0, players[index].name+" Is launching a helicopter!", 2);
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("helicopterstart");
players[index].helicoptertimer.restart();
players[index].statchangetimer.restart();
players[index].helicopterspawning=true;
}
if(wname=="item_grabber" and in_vehicle(players[index].name)<0)
{
if(in_shelter(players[index].name)>-1 and players[index].x==7 and players[index].y==7 and players[index].z==0)
{
send_reliable(players[index].peer_id,"Can not place ultrabombs here",0);
takeobj=false;
return;
}
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile=="" and in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"You can't do this in the air!",0);
takeobj=false;
return;
}
takeobj=false;
if(players[index].itemgrabbing==true)
{
send_reliable(players[index].peer_id,"Because you honestly think you can use a item grabber while using an item grabber...",0);
return;
}
players[index].itemgrabbingtimer.restart();
send_reliable(players[index].peer_id, "stopmoving",0);
players[index].itemgrabbing=true;
players[index].give("item_grabber",-1);
play("itemgrabberstart", players[index].x, players[index].y, players[index].z, players[index].map, index, false);
send_reliable(0, players[index].name+" just started using an item grabber! ", 2);
}
if(wname=="hand_grenade")
{
if(players[index].hand_grenadetimer.elapsed<2000)
{
takeobj=false;
}
else
{
play("draw_grenade",players[index].x,players[index].y,players[index].z,players[index].map);
play("hand_grenadethrow.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].hand_grenadetimer.restart();
}
}
if(wname=="pipe_bomb" and players[index].map!="store")
{
if(players[index].pipe_bombtimer.elapsed<2000)
{
takeobj=false;
}
else
{
play("pipe_bombthrow.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].pipe_bombtimer.restart();
}
}
if(wname=="rocket" and players[index].map!="store")
{
if(players[index].rockettimer.elapsed<1600)
{
takeobj=false;
}
else
{
play("rocketthrow.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].rockettimer.restart();
}
}
if(wname=="sticky_bomb")
{
play("stickybombthrow",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
}
if(wname=="shield")
{
if(players[index].shieldshots>=players[index].maxshields)
{
send_reliable(players[index].peer_id,"I think you'll be ok for now",0);
takeobj=false;
return;
}
else if(players[index].statchangetimer.elapsed<0)
{
takeobj=false;
send_reliable(players[index].peer_id,"speak You can't use this yet!",0);
return;
}
else
{
players[index].shieldshots+=random(500,500);
play("shieldon",players[index].x,players[index].y,players[index].z,players[index].map);
}
play("shieldon2",players[index].x,players[index].y,players[index].z,players[index].map);
}
if(wname=="fire_extinguisher")
{
play("fire_extinguisher",players[index].x,players[index].y,players[index].z,players[index].map);
for(uint i=0; i<fires.length(); i++)
{
if(get_3d_distance(players[index].x,players[index].y,players[index].z,fires[i].x,fires[i].y,fires[i].z)<=5 and players[index].map==fires[i].map)
fires[i].lifetimer.force(fires[i].lifetime);
}
}
if(wname=="guided_missile")
{
takeobj=false;
if(players[index].map=="store")
return;
else if(players[index].missiletimer.elapsed<missiletime) return;
else if(missiles.length()>=missilemax)
{
if(missilemax==0) send_reliable(e.peer_id,"speak Missiles are currently disabled",0);
else send_reliable(e.peer_id,"speak Too many missiles are already active. Wait for some to explode first",0);
}
else
send_menu(players[index].peer_id,"This missile has 2 different modes. You can select a player to send this missile to, or you can manually enter the x, y, z of the missile. What would you like to do","missilemode","Track a player:missileplayer[]Enter information manually:missileenter");
}
if(wname=="carrier_missile" and players[index].map!="store")
{
takeobj=false;
string menuitems;
string items=players[index].get_inv(false);
if(items=="")
{
send_reliable(players[index].peer_id,"Sorry, your inventory is empty",2);
return;
}
string[] p=string_split(items,"\r\n",false);
for(uint i=0; i<p.length(); i++)
{
string[] another_p=string_split(p[i],"=",false);
menuitems+=another_p[0]+", you have "+another_p[1]+":"+another_p[0]+"[]";
}
send_menu(players[index].peer_id,"Select the item you would like to send","cmstart",menuitems);
}
if(wname=="gas_mask")
{
takeobj=false;
if(players[index].air>0)
players[index].airlifetimer.restart();
players[index].airtimer.restart();
players[index].mask=toggle(players[index].mask);
string action=(players[index].mask==1 ? "on" : "off");
players[index].playsound("gas_mask"+action);
send_reliable(players[index].peer_id,"mask "+action,2);
}
if(wname=="air_canister")
{
spawn_canister(players[index].x,players[index].y,players[index].z,players[index].map,"air");
}
if(wname=="antibiotic_canister")
{
if(players[index].health>=100000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
if(players[index].statchangetimer.elapsed<10000)
{
send_reliable(players[index].peer_id,"Sorry...can't be gaining or losing health to do this",0);
return;
}
spawn_canister(players[index].x,players[index].y,players[index].z,players[index].map,"antibiotic");
}
if(wname=="wirebomb")
{
takeobj=false;
if(players[index].statchangetimer.elapsed<15000 or players[index].stunthrowtimer.elapsed<15000)
{
send_reliable(players[index].peer_id,"You can't spawn wirebombs just yet!",0);
return;
}
for(uint i=0; i<wirebombs.length(); i++)
{
if(players[index].distancecheck(wirebombs[i].x,wirebombs[i].y,wirebombs[i].z)<=15 and wirebombs[i].map==players[index].map)
{
send_reliable(players[index].peer_id,"You can't put too many wire bombs close together!",0);
return;
}
}
place_wirebomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
takeobj=true;
}
if(wname=="wood")
{
takeobj=false;
string items=players[index].get_inv();
int s=in_shelter(players[index].name);
if(s>-1)
{
if(shelters[s].health>800000) return;
send_serverbox(players[index].peer_id,2,2,1,-1,"shelterfix","How much wood would you like to add to this shelter?");
}
else
{
if(inv_item_number(items,"wood")<500)
{
send_reliable(players[index].peer_id,"not enough this item!",2);
return;
}
send_serverbox(players[index].peer_id,0,-1,0,-1,"build_shelter ","Enter the name of your shelter. Note: your name must not include spaces!");
}
}
if(wname=="metal")
{
takeobj=false;
string items=players[index].get_inv();
int v=in_vehicle(players[index].name);
if(v<0)
{
send_reliable(players[index].peer_id,"",2);
return;
}
else if(inv_item_number(items,"toolbox")<1)
{
send_reliable(players[index].peer_id,"you need a toolbox to begin this operation!",2);
return;
}
else if(vs[v].type=="tank"&&inv_item_number(items,"metal")<50)
{
send_reliable(players[index].peer_id,"you need at least 50 metal to repair a tank.",2);
return;
}
else if(vs[v].type=="aircraft"&&inv_item_number(items,"metal")<30)
{
send_reliable(players[index].peer_id,"you need at least 30 metal to repair an aircraft",2);
return;
}
else
{
int am=vs[v].type=="tank" ? 50 : 30;
players[index].give("metal",-am);
vs[v].command("repair");
}
}
if(wname=="toolbox")
{
takeobj=false;
}
if(wname=="fuel_tank")
{
if(in_vehicle(players[index].name)<0)
{
for(uint shi=0; shi<shelters.length; shi++)
{
if(shelters[shi].x==players[index].x&&shelters[shi].y==players[index].y&&shelters[shi].z==players[index].z&&shelters[shi].map==players[index].map)
{
takeobj=true;
shelters[shi].fuel+=random(10,15);
play("vehicle_refuel",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("fuel_tank",-1);
return;
}
}
takeobj=false;
send_reliable(players[index].peer_id,"a fuel tank cannot be used in this condition. If you are trying to refuel a shelter, use this fuel tank on it's outside generator",0);
}
if(in_vehicle(players[index].name)>-1)
{
int v=in_vehicle(players[index].name);
if(vs[v].speed>0)
{
takeobj=false;
send_reliable(players[index].peer_id,"you must be stopped to refuel your vehicle",0);
}
else
{
playext("vehicle_refuel",vs[v].x,vs[v].y,vs[v].z,vs[v].map,vs[v].owner);
playint("vehicle_refuel",vs[v].owner);
vs[v].fuel=100;
takeobj=true;
}
}
}
if(wname=="remote_timebomb")
{
if(players[index].rbombs>=players[index].rbomblimit)
{
takeobj=false;
send_reliable(players[index].peer_id,"Uh, don't go too crazy with these!",0);
return;
}
else
{
if(players[index].map!="store")
{
send_serverbox(players[index].peer_id,2,-1,1,-1,"rbomb","Enter the code you would like this bomb to have");
}
else takeobj=false;
}
}
if(wname=="sat_bomb")
{
if(players[index].sbombs>=players[index].rbomblimit)
{
takeobj=false;
send_reliable(players[index].peer_id,"Uh, don't go too crazy with these!",0);
return;
}
else
{
if(players[index].map!="store")
{
send_serverbox(players[index].peer_id,2,-1,1,-1,"rbomb","Enter the code you would like this bomb to have");
}
else takeobj=false;
}
}
if(wname=="mine")
{
if(players[index].map!="store")
{
if(mines_at(players[index].x,players[index].y,players[index].z,players[index].map)>=5)
{
players[index].sendpacket("speak There are already enough mines here!",0);
return;
}
place_mine(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
else takeobj=false;
}
else if(wname=="enes-productions.tr.ht_pack")
{
players[index].give("health_drink",100);
players[index].give("police_car_super",10);
players[index].give("dollar",100000);
players[index].give("shield",1000);
players[index].give("tk_ultra_health_potion",20);
send_reliable(players[index].peer_id,"you opened to enes-productions.tr.ht_pack!",2);
send_reliable(players[index].peer_id,"play_s purchase.ogg",0);
}
//packs code goes here for purchased made with the online store.
else if(wname=="stored_health")
{
if(players[index].health>=100000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
if(players[index].statchangetimer.elapsed<60000) return;
players[index].playsound("stored_health");
players[index].health=100000;
}
if(wname=="stun_grenade")
{
if(players[index].stungrenadetimer.elapsed<5000)
{
takeobj=false;
return;
}
players[index].stungrenadetimer.restart();
placestun_grenade(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
if(wname=="mass_bomb")
{
if(players[index].masstimer.elapsed<3000)
{
takeobj=false;
return;
}
players[index].masstimer.restart();
placemass_bomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
if(wname=="concussive_grenade")
{
if(players[index].concussivegrenadetimer.elapsed<3000)
{
takeobj=false;
return;
}
players[index].concussivegrenadetimer.restart();
placeconcussive_grenade(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
if(wname=="frequency_scrambler")
{
if(players[index].statchangetimer.elapsed<30000)
{
send_reliable(players[index].peer_id,"Error!",0);
return;
}
if(players[index].invusetimer.elapsed>=60000)
{
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].invusetimer.restart();
}
else
{
takeobj=false;
send_reliable(players[index].peer_id,"speak error. You can not use an frequency scrambler yet.",0);
}
}
if(wname=="suicide_bomb")
{
if(players[index].suicidetimer.elapsed<5000)
{
takeobj=false;
return;
}
players[index].suicidetimer.restart();
placesuicide_bomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
if(wname=="arena_card")
{
if(players[index].suicidetimer.elapsed<5000)
{
takeobj=false;
return;
}
move_player(players[index],"arena",0,0,0);
players[index].suicidetimer.restart();
}
if(wname=="store_card")
{
if(players[index].suicidetimer.elapsed<5000)
{
takeobj=false;
return;
}
move_player(players[index],"store",0,0,0);
players[index].suicidetimer.restart();
}
if(wname=="sound_grenade")
{
if(players[index].sound_grenadetimer.elapsed<5000)
{
takeobj=false;
return;
}
players[index].sound_grenadetimer.restart();
placesound_grenade(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
if(wname=="store_porting")
{
if(players[index].sound_grenadetimer.elapsed<5000)
{
takeobj=false;
return;
}
players[index].sound_grenadetimer.restart();
send_reliable(0,"done",0);
move_player(players[index],"store",0,0,0);
}
if(wname=="nuclear_bomb")
{
if(players[index].nucleartimer.elapsed<5000)
{
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile=="" and in_shelter(players[index].name)<0)
send_reliable(players[index].peer_id,"You can't do this in the air!",0);
takeobj=false;
return;
}
players[index].nucleartimer.restart();
placenuclear_bomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
if(wname=="bottle_bomb")
{
if(players[index].bottlebombtimer.elapsed<500)
{
takeobj=false;
}
else
{
play("bottlebombthrow",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].bottlebombtimer.restart();
}
}
if(wname=="stone")
{
if(players[index].stonetimer.elapsed<1000)
{
takeobj=false;
}
else
{
play("stonethrow",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].stonetimer.restart();
}
}
if(wname=="motion_bomb")
{
if(players[index].mbombtimer.elapsed<1600)
{
takeobj=false;
return;
}
players[index].mbombtimer.restart();
spawn_motion_bomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
play("motion_bombplacing",players[index].x,players[index].y,players[index].z,players[index].map);
}
if(wname=="health_dart")
{
if(players[index].stunthrowtimer.elapsed>=7500)
{
players[index].stunthrowtimer.restart();
play("stun_dartthrow",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
}
else
{
takeobj=false;
}
}
if(wname=="invisibility_shield")
{
if(players[index].statchangetimer.elapsed<30000)
{
send_reliable(players[index].peer_id,"Error!",0);
return;
}
if(players[index].invusetimer.elapsed>=60000)
{
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].invusetimer.restart();
}
else
{
takeobj=false;
send_reliable(players[index].peer_id,"speak error. You can not use an invisibility shield yet.",0);
}
}
else if(wname=="ultrabomb_silencer")
{
bool hasu=false;
string[] ultrabombset;
takeobj=false;
for(uint i=0; i<ultrabombs.length(); i++)
{
if(ultrabombs[i].x==players[index].x and ultrabombs[i].y==players[index].y and ultrabombs[i].z==players[index].z and players[index].map==ultrabombs[i].map and ultrabombs[i].silenced==false and ultrabombs[i].started==true)
{
ultrabombset.insert_last(ultrabombs[i].id);
hasu=true;
}
}
if(hasu==true)
{
takeobj=true;
for(uint j=0; j<ultrabombset.length(); j++)
{
for(uint j2=0; j2<ultrabombs.length(); j2++)
{
if(ultrabombs[j2].id==ultrabombset[j])
{
play("ultrabombgenerator_off",ultrabombs[j2].x,ultrabombs[j2].y,ultrabombs[j2].z,ultrabombs[j2].map);
destroy_moving_sound(ultrabombs[j2].loopid);
ultrabombs[j2].silenced=true;
}
}
}
}
}
else if(wname=="tk_deluxe_pack")
{
players[index].give("tank",50);
players[index].give("aircraft",100);
players[index].give("tk_ultra_health_potion",20);
players[index].give("guided_missile",100);
players[index].give("missile_interceptor",250);
players[index].give("bitcoin",10);
players[index].give("motion_bomb",50);
players[index].give("mine",20);
players[index].give("wirebomb",100);
players[index].give("shield",500);
players[index].give("ultrabomb",10);
send_reliable(players[index].peer_id,"TK deluxe pack activated!",2);
scd(index);
}
else if(wname=="bitcoin")
{
takeobj=false;
bool useable=false;
int s=in_shelter(players[index].name);
if(s>-1 and players[index].x==0 and players[index].y==4 and players[index].z==0)
{
useable=true;
players[index].give("bitcoin",-1);
shelters[s].dollars+=5000;
}
int v=get_vending_index(players[index].x,players[index].y,players[index].z,players[index].map);
if(v>-1)
{
players[index].give("bitcoin",-1);
useable=true;
vending_machines[v].dollars+=5000;
}
for(int i=0; i<stores.length(); i++)
{
if(players[index].x==stores[i].x and players[index].y==stores[i].y and players[index].z==stores[i].z and players[index].map==stores[i].map)
{
useable=true;
players[index].give("bitcoin", -1);
players[index].give("dollar", 5000);
send_reliable(players[index].peer_id, "you received 5000 dollars for exchanging a bitcoin", 2);
}
}
if(useable)
players[index].playsound("shelter_comp_bitcoin_insert");
else
send_reliable(players[index].peer_id,"Sorry, you must be standing on a shelter computer or on a vending machine or on a store register to use this item",0);
}
else if(wname=="dollar")
{
int j=get_jplayer_index(round(players[index].x,0), players[index].y,players[index].z,players[index].map);
if(j>-1)
{
if(jplayers[j].jstarted==true)
{
send_reliable(players[index].peer_id,"already in use",0);
return;
}
else
{
takeobj=true;
jplayers[j].coins+=1;
jplayers[j].start();
players[index].playsound("ultrabombcoinadd");
}
}
int vending=get_vending_index(players[index].x,players[index].y,players[index].z,players[index].map);
if(vending>-1)
{
send_serverbox(players[index].peer_id, 2, -1, -1, -1, "insertamount", "how many dollars do you want to insert into this vending machine?");
}
if(in_shelter(players[index].name)>-1)
{
if(players[index].x==0 and players[index].y==4 and players[index].z==0)
{
send_serverbox(players[index].peer_id, 2, -1, -1, -1, "insertamount", "how many dollars do you want to add to this shelter?");
}
}
bool hasu=false;
string[] ultrabombset;
takeobj=false;
for(uint i=0; i<ultrabombs.length(); i++)
{
if(ultrabombs[i].x==round(players[index].x,0) and ultrabombs[i].y==round(players[index].y, 0) and ultrabombs[i].z==players[index].z and players[index].map==ultrabombs[i].map and ultrabombs[i].dollars<20)
{
ultrabombset.insert_last(ultrabombs[i].id);
hasu=true;
}
}
if(hasu==true)
{
takeobj=true;
for(uint j=0; j<ultrabombset.length(); j++)
{
for(uint j2=0; j2<ultrabombs.length(); j2++)
{
if(ultrabombs[j2].id==ultrabombset[j])
{
ultrabombs[j2].dollars+=1;
ultrabombs[j2].owner=players[index].name;
play("ultrabombcoinadd",ultrabombs[j2].x,ultrabombs[j2].y,ultrabombs[j2].z,ultrabombs[j2].map);
}
}
}
}
}
else if(wname=="ultrabomb")
{
if(in_shelter(players[index].name)>-1 and players[index].x==7 and players[index].y==7 and players[index].z==0)
{
send_reliable(players[index].peer_id,"Can not place ultrabombs here",0);
takeobj=false;
return;
}
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile=="" and in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"You can't do this in the air!",0);
takeobj=false;
return;
}

for(uint u=0; u<ultrabombs.length(); u++)
{
if(ultrabombs[u].x==players[index].x and ultrabombs[u].y==players[index].y and ultrabombs[u].z==players[index].z and ultrabombs[u].map==players[index].map)
{
send_reliable(players[index].peer_id,"Oops? It seems as though there is already an ultrabomb placed there",0);
return;
}
}
players[index].ultrabombtimer.restart();
players[index].ultrabombplacing=true;
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("ultrabombdeploy");
}
else if(wname=="health_orb")
{
if(players[index].statchangetimer.elapsed<30000)
{
takeobj=false;
send_reliable(players[index].peer_id,"speak You can't use this yet!",0);
return;
}
spawn_horb(players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="antibiotic")
{
if(players[index].antibioticed==true)
{
takeobj=false;
send_reliable(players[index].peer_id,"Wait until your antibiotic ware's off!",0);
return;
}
if(players[index].health>=100000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<20000)
{
takeobj=false;
send_reliable(players[index].peer_id,"speak You can't use this yet!",0);
return;
}
else
{
players[index].playsound("antibiotic");
players[index].antibiotictimer.restart();players[index].awarnouttimer.restart();
players[index].antibioticed=true;
}
}
else if(wname=="mini_antibiotic_pack")
{
players[index].give("antibiotic",5);
players[index].give("empty_pack", 1);
play("getantibiotic",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="tk_donation_pack")
{
players[index].give("tank",10);
players[index].give("aircraft",10);
players[index].give("dollar",10000);
send_reliable(players[index].peer_id,"You have activated a donation pack! Thank you for donating!",2);
send_reliable(players[index].peer_id,"play_s teamcreate.ogg",0);
}
//packs code goes here for purchased made with the online store.
else if(wname=="tk_warp_box_pack")
{
players[index].playsound("gift");
players[index].give("warp_box",20);
send_reliable(players[index].peer_id,"you have opened a "+string_replace(wname,"_"," ",true)+"!",2);
}
else if(wname=="tk_mini_warp_box_pack")
{
players[index].playsound("gift");
players[index].give("warp_box",5);
send_reliable(players[index].peer_id,"you have opened a "+string_replace(wname,"_"," ",true)+"!",2);
}
else if(wname=="tk_ultra_warp_box_pack")
{
players[index].playsound("gift");
players[index].give("warp_box",50);
send_reliable(players[index].peer_id,"you have opened a "+string_replace(wname,"_"," ",true)+"!",2);
}
else if(wname=="bitcoin_pack")
{
players[index].give("bitcoin",5);
play("gift",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="grenade_pack")
{
players[index].give("grenade",10);
players[index].give("empty_pack", 1);
play("getgrenade",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="antibiotic_pack")
{
players[index].give("antibiotic",20);
play("getantibiotic",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="tk_ultra_health_potion_set")
{
players[index].playsound("getultra");
players[index].give("tk_ultra_health_potion",5);
send_reliable(players[index].peer_id,"you have opened a "+string_replace(wname,"_"," ",true)+"!",2);
}
else if(wname=="tk_ultra_health_potion")
{
if(players[index].health>=20000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
if(players[index].statchangetimer.elapsed<60000) return;
players[index].playsound("ultrapotion");
players[index].health=20000000;
send_reliable(players[index].peer_id,"your health has been restored!",0);
}
else if(wname=="ball_gangster")
{
if(players[index].statchangetimer.elapsed<60000) return;
players[index].playsound("cannondist");
players[index].playsound("cannonhit1");
players[index].health=0;
}
else if(wname=="health_box")
{
if(players[index].health>=50000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
if(players[index].statchangetimer.elapsed<60000) return;
players[index].playsound("health_box");
players[index].health=50000000;
}
else if(wname=="hand_grenade_pack")
{
players[index].give("hand_grenade",20);
players[index].give("empty_pack", 1);
play("getgrenade",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="clear_stats")
{
players[index].give("clear_stats",-1);
send_reliable(players[index].peer_id,"Your death count was just cleared",2);
players[index].deaths=0;
scd(index);
}
else if(wname=="tk_pack")
{
players[index].give("poison_dagger",20);
players[index].give("item_grabber",2);
players[index].give("dollar",20000);
players[index].give("stun_dart",20);
players[index].give("antibiotic",50);
players[index].give("invisibility_shield",10);
players[index].give("shield",50);
players[index].give("water",10);
players[index].give("timebomb",10);
players[index].give("motion_bomb",10);
players[index].give("wood_pack",15);
players[index].give("beretta_m9_pistol",1);
players[index].give("beretta_nano_pocket_pistol",1);
players[index].give("glock_17_pistol",1);
players[index].give("empty_pack", 1);
play("packopen",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="tk_shelter_pack")
{
players[index].give("wood",500);
players[index].give("security_bomb",5);
players[index].give("mine",20);
players[index].give("toolbox",1);
players[index].give("remote_gun",10);
players[index].give("remote_timebomb",10);
players[index].give("fuel_tank",4);
players[index].give("fire_extinguisher",5);
if(players[index].get_item_count("remote_timebomb_controller")<1) players[index].give("remote_timebomb_controller",1);
players[index].playsound("gift");
send_reliable(players[index].peer_id,"you have opened a "+string_replace(wname,"_"," ",true)+"!",2);
}
else if(wname=="missile_interceptor")
{
if(players[index].intercepting) return;
play("missile_interceptor_fire",players[index].x,players[index].y,players[index].z,players[index].map);
send_plus(players[index].peer_id,"distsound missile_interceptor_firedist "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map,0);
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].interceptortimer.restart();
players[index].intercepting=true;
}
else if(wname=="wood_pack")
{
int rand;
if(players[index].paid==1)
rand=random(25, 50);
else
rand=random(5,15);
players[index].give("wood",rand);
players[index].give("empty_pack", 1);
send_reliable(players[index].peer_id,"the pack contained "+rand+" wood!",2);
play("getwood",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="metal_pack")
{
int rand=random(20,50);
players[index].give("metal",rand);
players[index].give("empty_pack", 1);
send_reliable(players[index].peer_id,"the pack contained "+rand+" metal!",2);
play("getmedal.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="ultra_antibiotic_pack")
{
players[index].give("antibiotic",50);
play("getantibiotic",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("empty_pack", 1);
}
else if(wname=="remote_gun_controller")
{
takeobj=false;
server_menu m;
int hasrems=0;
for(uint i=0; i<remguns.length(); i++)
{
if(remguns[i].owner==players[index].name)
{
m.add("Remote gun "+remguns[i].id+", ("+remguns[i].map+" at "+remguns[i].x+", "+remguns[i].y+", "+remguns[i].z+")",""+remguns[i].id);
hasrems+=1;
}
}
if(hasrems<=0)
{
players[index].sendpacket("You don't have any remote guns to connect to",0);
return;
}
m.add("cancel","back");
m.intro="Select remotegun to connect to. You have "+hasrems+" remote guns available";
m.initial_packet="remgunidset";
m.send(players[index].peer_id);
}
else if(wname=="remote_gun")
{
if(players[index].remconnecting or players[index].rmtimer.elapsed<6343) return;
if(remgun_at(players[index].x,players[index].y,players[index].z,players[index].map))
{
send_reliable(players[index].peer_id,"speak there is already a remote gun here.",0);
return;
}
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].rmtimer.restart();
players[index].remconnecting=true;
play("remgun_place",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="remote_timebomb_controller")
{
takeobj=false;
send_serverbox(players[index].peer_id,2,-1,1,-1,"rtdcode","Enter the code for the remote timebomb or remote timebombs. Note: all bombs with this code will be detenated!");
}
else if(wname=="sat_bomb_remote")
{
takeobj=false;
send_serverbox(players[index].peer_id,2,-1,1,-1,"rtdcode","Enter the code for the sat_bomb_remote or sat_bomb_remote. Note: all bombs with this code will be detenated!");
}
else if(wname=="barricade_bomb"&&players[index].bbombplacing==false)
{
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile=="" and in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"You can't do this in the air!",0);
takeobj=false;
return;
}
for(uint i=0; i<barricade_bombs.length; i++)
{
if(barricade_bombs[i].x==players[index].x&&barricade_bombs[i].y==players[index].y&&barricade_bombs[i].z==players[index].z&&barricade_bombs[i].map==players[index].map)
{
send_reliable(players[index].peer_id,"there is already a barricade bomb here. No point in wasting such powerful things on only one square",0);
takeobj=false;
return;
}
}
if(in_vehicle(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"Not in a "+vs[in_vehicle(players[index].name)].type+"!",2);
return;
}
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("barricade_bombplace");
players[index].bbombtimer.restart();
players[index].bbombplacing=true;
}
else if(wname=="bullet_bomb"&&players[index].bulletbombplacing==false)
{
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile=="" and in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"You can't do this in the air!",0);
takeobj=false;
return;
}
for(uint i=0; i<bullet_bombs.length; i++)
{
if(bullet_bombs[i].x==players[index].x&&bullet_bombs[i].y==players[index].y&&bullet_bombs[i].z==players[index].z&&bullet_bombs[i].map==players[index].map)
{
send_reliable(players[index].peer_id,"there is already a bullet bomb here. No point in wasting such powerful things on only one square",0);
takeobj=false;
return;
}
}
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("bullet_bombplace");
players[index].bullettimer.restart();
players[index].bulletbombplacing=true;
}
else if(wname=="small_projectile")
{
if(players[index].projectiletimer.elapsed<3000){
send_reliable(players[index].peer_id,"you can't use small projectile",0);
return;
}
takeobj=true;
spawn_projectile(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
players[index].projectiletimer.restart();
}
else if(wname=="tasing_small_projectile")
{
if(players[index].projectiletimer.elapsed<4000){
send_reliable(players[index].peer_id,"you can't use tasing small projectile",0);
return;
}
takeobj=true;
spawn_tprojectile(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
players[index].projectiletimer.restart();
}
else if(wname=="poisoned_small_projectile")
{
if(players[index].projectiletimer.elapsed<6000){
send_reliable(players[index].peer_id,"you can't use poisoned small projectile",0);
return;
}
takeobj=true;
spawn_pprojectile(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
players[index].projectiletimer.restart();
}
else if(wname=="security_bomb"&&players[index].sbombplacing==false)
{
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile=="" and in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"You can't do this in the air!",0);
takeobj=false;
return;
}
for(uint i=0; i<security_bombs.length; i++)
{
if(security_bombs[i].x==players[index].x&&security_bombs[i].y==players[index].y&&security_bombs[i].z==players[index].z&&security_bombs[i].map==players[index].map)
{
send_reliable(players[index].peer_id,"there is already a security bomb here. No point in wasting such powerful things on only one square",0);
takeobj=false;
return;
}
}
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("security_bombplace");
players[index].sbombtimer.restart();
players[index].sbombplacing=true;
}
else if(wname=="bullet_bomb_locator")
{
takeobj=false;
send_reliable(players[index].peer_id,"searching...",0);
string list;
players[index].playsound("bullet_bomblocate");
for(uint i=0; i<bullet_bombs.length(); i++)
{
if(bullet_bombs[i].owner==players[index].name)
{
list+=bullet_bombs[i].owner+"'s bullet_bomb: "+bullet_bombs[i].x+", "+bullet_bombs[i].y+", "+bullet_bombs[i].z+" on "+bullet_bombs[i].map+".\r\n";
}
}
if(list=="")
list="none";
send_reliable(players[index].peer_id,"Your bullet bombs: "+list,2);
}
else if(wname=="ultrabomb_locator")
{
takeobj=false;
send_reliable(players[index].peer_id,"searching...",0);
string list;
players[index].playsound("ultrabomblocator");
for(uint i=0; i<ultrabombs.length(); i++)
{
if(ultrabombs[i].owner==players[index].name)
{
list+=ultrabombs[i].owner+"'s ultrabomb: "+ultrabombs[i].x+", "+ultrabombs[i].y+", "+ultrabombs[i].z+" on "+ultrabombs[i].map+".\r\n";
}
}
if(list=="")
list="none";
send_reliable(players[index].peer_id,"Your ultrabombs: "+list,2);
}
else if(wname=="timebomb")
{
if(players[index].mbombtimer.elapsed<500)
{
takeobj=false;
return;
}
players[index].mbombtimer.restart();
placetimebomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name,5000);
}
if(takeobj==true)
players[index].give(wname,-1);
//send_reliable(players[index].peer_id,"invstring "+players[index].get_inv(false),0);
}
players[index].using=false;
}
}
else if(parsed[0]=="insertamount" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id, "canceled", 0);
return;
}
int s=in_shelter(players[index].name);
int v=get_vending_index(players[index].x, players[index].y, players[index].z, players[index].map);
double amount=stn(parsed[1]);
if(players[index].get_item_count("dollar")<amount)
{
send_reliable(players[index].peer_id, "not enough money", 2);
return;
}
if(v<0 and s<0) return;
if(s>-1)
{
shelters[s].compplay("ultrabombcoinadd");
shelters[s].dollars+=amount;
players[index].give("dollar", -amount);
}
else if(v>-1)
{
vending_machines[v].dollars+=amount;
players[index].give("dollar", -amount);
}
}
}
else if(parsed[0]=="purchase" and parsed.length()>2)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
purchase(parsed[1],stn(parsed[2]),index);
}
}
else if(parsed[0]=="buysomething" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="back") return;
send_serverbox(players[index].peer_id, 2, 1, 0, -1, "purchase "+parsed[1], "type the amount you wish to buy");
}
}
else if(parsed[0]=="revive")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].is_dead=true)
{
players[index].vo("revive");
respawn(index);
}
}
}
else if(parsed[0]=="motd")
{
send_reliable(e.peer_id,"server message: "+motd(),2);
}
else if(parsed[0]=="compinfo" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string comptext=players[index].name+" ("+string_replace(get_event_message(), "compinfo ", "", false)+") from IP "+n.get_peer_address(e.peer_id)+", computer ID "+players[index].compid+"\r\n";
file f;
f.open("chars/"+players[index].name+"/info.usr","wb");
f.write("last seen: "+get_date(true,false)+" at "+get_time(true,false)+"\r\ncomp info:\r\n"+comptext+"\r\nlocation:\r\n");
f.close();
f.open("compchars.log", "rb");
string orgtext=f.read();
f.close();
if(string_contains(orgtext, comptext, 1)<0)
{
f.open("compchars.log", "ab");
f.write(comptext);
f.close();
}
players[index].ctext=comptext;
}
}
else if(parsed[0]=="ping")
{
send_reliable(e.peer_id,"pong",0);
}
else if(parsed[0]=="testmenu")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
send_reliable(players[index].peer_id,"Menus seem to work just fine. You clicked "+string_replace(get_event_message(),"testmenu ","",false)+". Correct?",0);
}
}
else if(parsed[0]=="build_shelter")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string name=string_trim_left(get_event_message(),14);
name=string_replace(name,"[SPCE]"," ",true);
name=string_replace(name," ","_",true);
if(name[0]=="_") name=string_trim_left(name,1);
if(string_contains(name,".",1)>-1)
{
send_reliable(players[index].peer_id,"Invalid shelter name!",2);
return;
}
if(name=="" or name=="main" or name=="store")
{
send_reliable(players[index].peer_id, "you can't create a no name shelter", 2);
return;
}
if(string_contains(name,"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"speak Canceled",0);
return;
}
if(players[index].map=="store")
{
send_reliable(players[index].peer_id,"you can't just build a shelter inside a moving store!",2);
return;
}
if(is_travelpoint(players[index].x,players[index].y,players[index].z,players[index].map))
{
send_reliable(players[index].peer_id,"Building shelters on travelpoints just doesn't work like that!",2);
return;
}
if(in_shelter(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"I don't think building another shelter inside a shelter's such a good idea...",2);
return;
}
if(get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map)=="")
{
send_reliable(players[index].peer_id,"You can't exactly build something in mid air, can you?",2);
return;
}
if(string_left(get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map),4)=="wall")
{
send_reliable(players[index].peer_id,"you may not build a shelter on a wall",2);
return;
}
if(is_staircase(players[index].x,players[index].y,players[index].z,players[index].map))
{
send_reliable(players[index].peer_id,"you may not build a shelter on a staircase.",2);
return;
}
for(uint shi=0; shi<shelters.length; shi++)
{
if(shelters[shi].x==players[index].x&&shelters[shi].y==players[index].y&&shelters[shi].z==players[index].z&&shelters[shi].map==players[index].map)
{
send_reliable(players[index].peer_id,"there is already a shelter here.",2);
return;
}
}
if(players[index].x==storex and players[index].y==storey and players[index].z==storez and players[index].map=="main")
{
send_reliable(players[index].peer_id,"You can not build a shelter on top of the store!",2);
return;
}
if(shelter_exists(name))
{
send_reliable(players[index].peer_id,"error! A shelter with this name already exists",2);
return;
}
if(!filterchar(name,true,"'"))
{
players[index].shelter_building=true;
players[index].buildtimer.restart();
players[index].give("wood",-500);
play("shelter_build",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].sheltername=name;
send_reliable(players[index].peer_id,"stopmoving",0);
}
else
{
send_reliable(players[index].peer_id,"Error! Invalid name!",0);
return;
}
}
}
else if(parsed[0]=="remdisconnect")
{
int index=get_player_index_from(e.peer_id);
if(index>-1) players[index].cremguns=false;
}
else if(parsed[0]=="remconnect")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(has_remgun(players[index].name)==true)
{
send_reliable(players[index].peer_id,"play_s remgun_connect.ogg",0);
send_reliable(e.peer_id,"remcontrol",0);
players[index].cremguns=true;
}
else
{
send_reliable(e.peer_id,"No remote guns connected!",2);
}
}
}
else if(parsed[0]=="firerem")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
for(uint r=0; r<remguns.length(); r++)
{
if(remguns[r].owner==players[index].name)
remguns[r].can_fire=true;
}
}
}
else if(parsed[0]=="destrem")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
for(uint r=0; r<remguns.length(); r++)
{
if(remguns[r].owner==players[index].name)
{
remguns[r].health=-1;
remguns[r].hitby="internal:rg:destruct";
}
}
}
}
else if(parsed[0]=="rbomb" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"canceled",0);
return;
}
players[index].rbombs+=1;
place_remote_timebomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name,stn(parsed[1]));
send_reliable(players[index].peer_id,"Bomb placed at "+players[index].x+" "+players[index].y+" "+players[index].z+" with code "+parsed[1],2);
}
}
else if(parsed[0]=="rtdcode" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Canceled!",0);
return;
}
int code=stn(parsed[1]);
int exploded=0;
send_reliable(players[index].peer_id,"Searching...",0);
play("remote_timebombcode",players[index].x,players[index].y,players[index].z,players[index].map);
for(uint i=0; i<remote_timebombs.length; i++)
{
if(remote_timebombs[i].code==code)
{
exploded++;
remote_timebombs[i].bombtimer.restart();
remote_timebombs[i].d=true;
play("remote_timebombcharge",remote_timebombs[i].x,remote_timebombs[i].y,remote_timebombs[i].z,remote_timebombs[i].map);
}
}
send_reliable(players[index].peer_id,exploded+" detenated!",0);
}
}
else if(parsed[0]=="satcode" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Canceled!",0);
return;
}
int code=stn(parsed[1]);
int exploded=0;
send_reliable(players[index].peer_id,"Searching...",0);
play("sat_bombcode",players[index].x,players[index].y,players[index].z,players[index].map);
for(uint i=0; i<sat_bombs.length; i++)
{
if(sat_bombs[i].code==code)
{
exploded++;
sat_bombs[i].bombtimer.restart();
sat_bombs[i].d=true;
play("sat_bombcharge",sat_bombs[i].x,sat_bombs[i].y,sat_bombs[i].z,sat_bombs[i].map);
}
}
send_reliable(players[index].peer_id,exploded+" detenated!",0);
}
}
else if(parsed[0]=="sheltercheck")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(in_shelter(players[index].name)>-1)
{
int shind=in_shelter(players[index].name);
send_reliable(players[index].peer_id,"entershelter "+shelters[shind].x+" "+shelters[shind].y+" "+shelters[shind].z+" "+shelters[shind].map,0);
}
}
}
else if(parsed[0]=="teamcheck")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string charfolder="chars/"+players[index].name;
if(file_exists(charfolder+"/team.usr"))
{
file tf;
tf.open(charfolder+"/team.usr","rb");
string t=tf.read();
tf.close();
if(team_exists(t))
{
int tx=get_team_index(t);
teams[tx].add_member(players[index].name,false);
send_reliable(players[index].peer_id,"welcome back to the "+t+" team!",2);
if(players[index].hidden==0) send_reliable(0, players[index].name+" is part of the "+t+" team", 2);
}
}
}
}
else if(parsed[0]=="admincheck")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string n=players[index].name;
string charfolder="chars/"+n;
if(file_exists(charfolder+"/master.usr") and players[index].dev==false)
{
send_reliable(e.peer_id,"isadmin",0);
players[index].master=true;
send_reliable(0,"play_s thunder7.ogg",0);
send_reliable(0,"play_s ultrabomb.ogg",0);
send_reliable(0,players[index].name+" is a master of the killer!",2);
if(players[index].adminflag==1) players[index].title="master";
}
else if(file_exists(charfolder+"/admin.usr") and players[index].dev==false)
{
send_reliable(e.peer_id,"isadmin",0);
players[index].is_admin=true;
send_reliable(0,"play_s notify_alert.ogg",0);
send_reliable(0,"play_s dev2.ogg",0);
send_reliable(0,players[index].name+" is administrator of the killer",2);
if(players[index].adminflag==1) players[index].title="administrator";
}
if(file_exists(charfolder+"/mod.usr") and players[index].dev==false)
{
send_reliable(e.peer_id,"isadmin",0);
players[index].is_mod=true;
send_reliable(0,"play_s notify_reboot.ogg",0);
send_reliable(0,"play_s notify.ogg",0);
send_reliable(0,players[index].name+" is a moderator!",2);
if(players[index].adminflag==1) players[index].title="moderator";
}
if(file_exists(charfolder+"/builder.usr") and players[index].masterable()==false)
{
players[index].is_builder=true;
send_reliable(0,"play_s admin.ogg.ogg",0);
send_reliable(0,"play_s admin.ogg",0);
send_reliable(0,players[index].name+" is a builder",2);
if(players[index].adminflag==1) players[index].title="builder";
}
}
}
else if(parsed[0]=="close")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
log("disconnections",players[index].name+" disconnected",true,true);
if(cheatercheck(index)||players[index].cheater==1||file_exists("chars/"+players[index].name+"/cheater.usr"))
{
create_temp_ban(players[index].name);
write_to(players[index].name,"cheater.usr",players[index].name+" is a cheater! They closed the game in "+ms_to_readable_time(players[index].statchangetimer.elapsed)+" of being hit");
send_reliable(0,players[index].name+" is a cheater!",2);
players[index].persisttimer.restart();
players[index].disconnected=true;
}
else
{
remove_player(players[index].name);
}
}
}
else if(parsed[0]=="hidechar" and parsed.length()>1)
{
if(directory_exists("chars/"+parsed[1])==false)
{
send_reliable(e.peer_id,"nochar",0);
return;
}
fl.open("chars/"+parsed[1]+"/hidden.usr","wb");
fl.write("1");
fl.close();
send_reliable(e.peer_id,"hidden",0);
}
else if(parsed[0]=="changeeml" and parsed.length()>2)
{
if(directory_exists("chars/"+parsed[1])==false)
{
send_reliable(e.peer_id,"nochar",0);
return;
}
fl.open("chars/"+parsed[1]+"/eml.usr","wb");
fl.write(parsed[2]);
fl.close();
send_reliable(e.peer_id,"changed",0);
}
else if(parsed[0]=="newplayer" and parsed.length() > 7)
{
bool spawnable=true;
for(uint i=0; i<players.length(); i++)
{
if(players[i].name==parsed[5])
{
spawnable=false;
}
}
if(spawnable==true)
{
int hide=stn(get_char_val(parsed[5],"hidden"));
spawn_player(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), parsed[4], parsed[5], e.peer_id,parsed[6],string_replace(parsed[7],"[spce]"," ",true),n.get_peer_address(e.peer_id),string_replace(get_event_message(),parsed[0]+" "+parsed[1]+" "+parsed[2]+" "+parsed[3]+" "+parsed[4]+" "+parsed[5]+" "+parsed[6]+" "+parsed[7],"",false),hide);
int index=get_player_index(e.peer_id);
if(index>-1)
{
load_char_data(index);
string loc=get_location(e.peer_id);
write_to(parsed[5],"location.usr",loc);
fl.open("chars/"+parsed[5]+"/info.usr","ab");
fl.write(loc);
fl.close();
index=get_player_index_from(parsed[5]);
if(index>-1 and players[index].warnlevel>0)
{
send_reliable(players[index].peer_id,"play_s warn"+players[index].warnlevel+".ogg",0);
send_reliable(players[index].peer_id,"dlg you have a pending warning: "+players[index].warning+". Type /warned to show you have read and understand this warning",0);
}
if(msounds.length()>0)
for(uint i=0; i<msounds.length; i++)
{
send_reliable(players[index].peer_id,"createmsound "+msounds[i].id+" "+msounds[i].soundloop+" "+msounds[i].x+" "+msounds[i].y+" "+msounds[i].z+" "+msounds[i].map+" "+msounds[i].pitch,4);
}
if(sirens.length()>0)
for(uint i=0; i<sirens.length; i++)
{
send_reliable(players[index].peer_id,"createsiren "+sirens[i].id+" "+sirens[i].soundloop+" "+sirens[i].x+" "+sirens[i].y+" "+sirens[i].z+" "+sirens[i].map,4);
}
send_reliable(players[index].peer_id,"weaponlist "+wnames,0);
players[index].oldhealth=players[index].health;
players[index].statchangetimer.force(60000);
players[index].invusetimer.force(60000);
if(beta==true)
{
send_reliable(players[index].peer_id,"Welcome to the killer beta server! Version "+version+ "beta. Type /changes to see what's new, /rules to view rules, and /help to see available commands. Last revision of rules is "+file_get_contents("rules_revision.txt")+". server message: "+motd(),2);
}
else
send_reliable(players[index].peer_id,"Welcome to the killer! Version "+version+". Type /changes to see what's new, /rules to view rules, and /help to see available commands. Last revision of rules is "+file_get_contents("rules_revision.txt")+". server message: "+motd(),2);
send_reliable(players[index].peer_id,"play_s welcome.ogg",0);
if(hide>0)
{
players[index].is_dead=true;
send_reliable(players[index].peer_id,"play_s pm.ogg",0);
send_reliable(players[index].peer_id,"you are currently hiding",2);
}
}
}
}
else if(parsed[0]=="fall")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden==0) send_reliable(0,"fall "+players[index].name+" "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map,0);
}
}
else if(parsed[0]=="hardland")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden>0) return;
int falld=stn(parsed[1]);
players[index].health-=falld*50;
players[index].should_subtract=false;
players[index].hitby="the laws of gravity";
send_reliable(0,"hardland "+players[index].name+" "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map,0);
if(players[index].health>=2500)
{
add_achievement("Survived a fall with 50 percent default health",index,"1 antibiotic_pack");
}
players[index].sitting=1;
send_reliable(players[index].peer_id,"sitstart",0);
}
}
else if(parsed[0]=="land")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
if(players[index].hidden==0) send_reliable(0, "land "+players[index].name+" "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map, 0, index);
}
}
else if(parsed[0]=="shelterfix" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Canceled!",0);
return;
}
double h=stn(parsed[1]);
if(h<0)
{
players[index].sendpacket("Overflow error!",0);
return;
}
double wood=players[index].get_item_count("wood");
if(wood<h)
{
send_reliable(players[index].peer_id,"Not enough wood!",0);
return;
}
int s=in_shelter(players[index].name);
if(s>-1)
{
play("shelterfix",players[index].x,players[index].y,players[index].z,players[index].map);
play("shelterfix",shelters[s].x,shelters[s].y,shelters[s].z,shelters[s].map);
int rep=h*random(50,200);
if((shelters[s].health+rep)>900000)
{
int delta=(shelters[s].health+rep-900000);
int ret=round((delta/120),0);
players[index].give("wood",ret);
}
shelters[s].health+=rep;
send_reliable(players[index].peer_id,"inv wood -"+h,0);
}
}
}
else if(parsed[0]=="draw" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].map=="jail" or players[index].is_dead)
return;
players[index].stun(404,false,false);
play(parsed[1]+"draw", players[index].x, players[index].y, players[index].z, players[index].map);
send_reliable(players[index].peer_id,"weapondata "+dget_string(wdata,parsed[1]),0);
players[index].weapon=parsed[1];
players[index].get_weapon_propperties(players[index].weapon);
players[index].firing=false;
}
}
else if(parsed[0]=="jump")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
int r=random(0,50);
if(r>=45)
{
int sticky=has_stickybomb(players[index].name);
if(sticky>-1)
{
stickybombs[sticky].stickyplayer="";
players[index].playsound("stickybombunstick");
}
}
if(players[index].hidden==0) send_reliable(0, "jump "+players[index].name+" "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map, 0, index);
}
}
else if(parsed[0]=="reload")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].stunned==false and players[index].firing==false and players[index].reloading==false)
{
if(players[index].weapon=="knife" or players[index].weapon=="fists" or players[index].weapon=="sword")
{
send_reliable(players[index].peer_id,"This weapon does not take ammo",0);
return;
}
else if(players[index].weapon=="")
{
send_reliable(players[index].peer_id, "you have no weapon equipped", 0);
return;
}
if(players[index].get_ammo_count_from(players[index].weapon)>0)
{
return;
}
if(players[index].get_item_count("ammo_"+players[index].weapon)<=0)
{
send_reliable(players[index].peer_id,"no ammo left for "+players[index].weapon+"!",0);
return;
}
else
{
players[index].reloadtime=players[index].w.get_reloadtime();
players[index].reloadtimer.restart();
send_reliable(players[index].peer_id, "cannotdraw", 0);
players[index].reloading=true;
players[index].playsound(players[index].weapon+"reload");
}
}
}
}
else if(parsed[0]=="rhealthcheck")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
send_reliable(e.peer_id,"speak "+robots[index].health+" health",0);
}
}
else if(parsed[0]=="healthcheck")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int v=in_vehicle(players[index].name);
int sh=in_shelter(players[index].name);
if(v<0&&sh<0) send_reliable(e.peer_id,"speak "+players[index].health+" health, "+players[index].shieldshots+" shielded shots.",0);
else if(sh>-1&&v<0) send_reliable(players[index].peer_id,"speak this shelter has "+shelters[sh].health+" health, and you have "+players[index].health+" health, with "+players[index].shieldshots+" shielded shots",0);
else if(v>-1) {
int ms=vs[v].fuel*(100/0.1)*(vs[v].fueltime-(vs[v].vfueltime*(vs[v].speed-1)));
send_reliable(players[index].peer_id,"speak your "+vs[v].type+" has "+vs[v].health+" health, and "+vs[v].fuel+"% fuel. Last hit by "+vs[v].hitby,0);
}
}
}
else if(parsed[0]=="shsendstore")
{
int index=get_player_index(e.peer_id);
if(index>-1 and in_shelter(players[index].name)>-1)
{
if(parsed[1]=="back")
{
send_serverbox(players[index].peer_id, 0, -1, 1, 1, "shcommand", "you exit the store screen. \r\nwhat would you like to do?");
return;
}
else if(parsed[1]=="shoppingcart")
{
string cart_items;
int s=in_shelter(players[index].name);
if(s>-1)
{
string[] temp=shelters[s].shopping_cart.get_keys();
for(int i=0; i<temp.length(); i++)
{
cart_items+=shelters[s].get_cart_item_amount(temp[i])+" "+temp[i]+". costs "+get_shelter_price(temp[i], shelters[s].get_cart_item_amount(temp[i]))+" dollars.:"+temp[i]+"[]";
}
cart_items+="total price is "+shelters[s].get_total_cart_price()+" dollars. press enter to checkout:checkout[]";
send_menu(players[index].peer_id, "shopping cart menu", "shcartaction", cart_items);
}
}
else
{
int si=get_store_index_from(parsed[1]);
if(si>-1) stores[si].send(players[index].peer_id, "shcartadding", true);
}
}
}
else if(parsed[0]=="shcartaction")
{
int index=get_player_index(e.peer_id);
if(index>-1 and in_shelter(players[index].name)>-1)
{
int s=in_shelter(players[index].name);
if(parsed.length<3 and parsed[1]=="back" or parsed.length()>=3 and parsed[2]=="[cncel]")
{
send_serverbox(players[index].peer_id, 0, -1, 1, 1, "shcommand", "operation canceled. \r\nwhat would you like to do?");
return;
}
if(parsed[1]=="checkout" and s>-1) shelters[s].checkout(players[index].peer_id);
else
{
if(parsed.length()<3)
{
send_serverbox(players[index].peer_id, 2, -1, -1, -1, "shcartaction "+parsed[1], "how much of "+parsed[1]+"do you want to remove");
return;
}
else
{
int amount=stn(parsed[2]);
if(amount>shelters[s].get_cart_item_amount(parsed[1]))
{
send_serverbox(players[index].peer_id, 0, -1, 1, 1, "shcommand", "you don't have that many of this item on your shopping cart. \r\nwhat would you like to do now?");
return;
}
string result;
if(amount==shelters[s].get_cart_item_amount(parsed[1]))
{
result+="you removed the hole set of "+parsed[1]+"s from the shopping cart";
}
else
{
result+="you removed "+amount+" "+parsed[1];
if(amount>1) result+="s";
result+=" from the shopping cart.";
}
shelters[s].add_to_cart(parsed[1], -amount);
send_serverbox(players[index].peer_id, 0, -1, 1, 1, "shcommand", result+"\r\nwhat would you like to do now?");
}
}
}
}
else if(parsed[0]=="shcartadding")
{
int index=get_player_index(e.peer_id);
if(index>-1 and in_shelter(players[index].name)>-1)
{
if(parsed[1]=="back")
{
send_serverbox(players[index].peer_id, 0, -1, 1, 1, "shcommand", "canceled. \r\nwhat would you like to do?");
return;
}
send_serverbox(players[index].peer_id, 2, -1, -1, -1, "shcartadded "+parsed[1], "how much of this item do you want to add?");
}
}
else if(parsed[0]=="shcartadded")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(s>-1)
{
if(parsed[2]!="[cncel]")
{
shelters[s].add_to_cart(parsed[1], stn(parsed[2]));
int num=stn(parsed[2]);
string result=parsed[2]+" "+parsed[1];
if(num>2) result+="s";
result+=" have been added to the shopping cart";
send_serverbox(players[index].peer_id, 0, -1, 1, 1, "shcommand", result+"\r\nwhat would you like to do now?");
}
else
{
send_reliable(players[index].peer_id, "operation canceled", 0);
return;
}
}
}
}
else if(parsed[0]=="xplay" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1&&players[index].hidden==0) playext(parsed[1],players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
else if(parsed[0]=="track" and parsed.length()>1)
{
int i=get_player_index(e.peer_id);
if(i>-1)
{
int index=get_player_index_from(parsed[1]);
if(index<0)
{
send_reliable(e.peer_id,"Player not found",0);
return;
}
else
{
if(players[index].invisible or players[index].is_dead or players[index].invinsible)
send_reliable(e.peer_id,"This player can not be tracked",0);
else
{
string soundname;
if(are_teamed(players[index].name,players[i].name)==true)
soundname="teambeacon";
else
soundname="track";
send_reliable(e.peer_id,"trackplayer "+players[index].name+" "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map+" "+soundname,0);
}
}
}
}
else if(parsed[0]=="whatnear")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
string s;
if (storex<players[index].x+30 and storex>players[index].x-30 and storey<players[index].y+30 and storey>players[index].y-30 and get_1d_distance(0,players[index].z)<=30 and players[index].map=="main"&&storemovestage<=1)
{
int level=1;
if(storez>players[index].z)
{
level=2;
}
else if(storez<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="The ";
s+="store is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, storex, storey, players[index].facing))+", "+players[index].distancecheck(storex,storey,storez)+" feet away. ";
}
for (uint r=0; r<robots.length(); r++)
{
if (robots[r].x<players[index].x+20 and robots[r].x>players[index].x-20 and robots[r].y<players[index].y+20 and robots[r].y>players[index].y-20 and get_1d_distance(robots[r].z,players[index].z)<=20 and robots[r].map==players[index].map)
{
int level=1;
if(robots[r].z>players[index].z)
{
level=2;
}
else if(robots[r].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="a ";
s+=robots[r].name+" with "+robots[r].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, robots[r].x, robots[r].y, players[index].facing))+", "+players[index].distancecheck(robots[r].x,robots[r].y,robots[r].z)+" feet away. ";
}
}
for (uint i=0; i<helicopters.length(); i++)
{
if (helicopters[i].x<players[index].x+30 and helicopters[i].x>players[index].x-30 and helicopters[i].y<players[index].y+30 and helicopters[i].y>players[index].y-30 and get_1d_distance(helicopters[i].z,players[index].z)<=30 and helicopters[i].map==players[index].map)
{
int level=1;
if(helicopters[i].z>players[index].z)
{
level=2;
}
else if(helicopters[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="a helicopter ";
s+=helicopters[i].id+" with "+helicopters[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, helicopters[i].x, helicopters[i].y, players[index].facing))+", "+players[index].distancecheck(helicopters[i].x,helicopters[i].y,helicopters[i].z)+" feet away. ";
}
}
for (uint i=0; i<shelters.length(); i++)
{
if (shelters[i].x<players[index].x+20 and shelters[i].x>players[index].x-20 and shelters[i].y<players[index].y+20 and shelters[i].y>players[index].y-20 and get_1d_distance(shelters[i].z,players[index].z)<=20 and shelters[i].map==players[index].map)
{
int level=1;
if(shelters[i].z>players[index].z)
{
level=2;
}
else if(shelters[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="The ";
if(shelters[i].broken==true)
s+="broken ";
s+=shelters[i].sheltername+" shelter belonging to "+shelters[i].owner+" with "+shelters[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, shelters[i].x, shelters[i].y, players[index].facing))+", "+players[index].distancecheck(shelters[i].x,shelters[i].y,shelters[i].z)+" feet away. ";
}
}
for (uint i=0; i<vending_machines.length(); i++)
{
if (vending_machines[i].x<players[index].x+20 and vending_machines[i].x>players[index].x-20 and vending_machines[i].y<players[index].y+20 and vending_machines[i].y>players[index].y-20 and get_1d_distance(vending_machines[i].z,players[index].z)<=20 and vending_machines[i].map==players[index].map)
{
int level=1;
if(vending_machines[i].z>players[index].z)
{
level=2;
}
else if(vending_machines[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="a ";
s+="vending machine selling food and drinks is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, vending_machines[i].x, vending_machines[i].y, players[index].facing))+", "+players[index].distancecheck(vending_machines[i].x,vending_machines[i].y,vending_machines[i].z)+" feet away. ";
}
}
for (uint i=0; i<ultrabombs.length(); i++)
{
if (ultrabombs[i].x<players[index].x+20 and ultrabombs[i].x>players[index].x-20 and ultrabombs[i].y<players[index].y+20 and ultrabombs[i].y>players[index].y-20 and get_1d_distance(players[index].z,ultrabombs[i].z)<=20 and ultrabombs[i].map==players[index].map)
{
int level=1;
if(ultrabombs[i].z>players[index].z)
{
level=2;
}
else if(ultrabombs[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+=cn2n(ultrabombs[i].owner)+"'s ultrabomb with "+ultrabombs[i].dollars+" dollars is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, ultrabombs[i].x, ultrabombs[i].y, players[index].facing))+", "+players[index].distancecheck(ultrabombs[i].x,ultrabombs[i].y,ultrabombs[i].z)+" feet away. ";
}
}
for (uint i=0; i<objs.length(); i++)
{
if (objs[i].x<players[index].x+20 and objs[i].x>players[index].x-20 and objs[i].y<players[index].y+20 and objs[i].y>players[index].y-20 and get_1d_distance(players[index].z,objs[i].z)<=20 and objs[i].map==players[index].map)
{
int level=1;
if(objs[i].z>players[index].z)
{
level=2;
}
else if(objs[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+=objs[i].name+" is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, objs[i].x, objs[i].y, players[index].facing))+", "+players[index].distancecheck(objs[i].x,objs[i].y,objs[i].z)+" feet away. ";
}
}
for (uint i=0; i<remguns.length(); i++)
{
if (remguns[i].x<players[index].x+20 and remguns[i].x>players[index].x-20 and remguns[i].y<players[index].y+20 and remguns[i].y>players[index].y-20 and get_1d_distance(players[index].z,remguns[i].z)<=20 and remguns[i].map==players[index].map)
{
int level=1;
if(remguns[i].z>players[index].z)
{
level=2;
}
else if(remguns[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+=remguns[i].owner+"'s remote gun with "+(50-remguns[i].shotsfired)+" remaining bullets is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, remguns[i].x, remguns[i].y, players[index].facing))+", "+players[index].distancecheck(remguns[i].x,remguns[i].y,remguns[i].z)+" feet away. ";
}
}
for (uint i=0; i<remote_timebombs.length(); i++)
{
if (remote_timebombs[i].x<players[index].x+20 and remote_timebombs[i].x>players[index].x-20 and remote_timebombs[i].y<players[index].y+20 and remote_timebombs[i].y>players[index].y-20 and get_1d_distance(players[index].z,remote_timebombs[i].z)<=20 and remote_timebombs[i].map==players[index].map)
{
int level=1;
if(remote_timebombs[i].z>players[index].z)
{
level=2;
}
else if(remote_timebombs[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="a remote timebomb is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, remote_timebombs[i].x, remote_timebombs[i].y, players[index].facing))+", "+players[index].distancecheck(remote_timebombs[i].x,remote_timebombs[i].y,remote_timebombs[i].z)+" feet away. ";
}
}
for (uint i=0; i<lockers.length(); i++)
{
if (lockers[i].x<players[index].x+20 and lockers[i].x>players[index].x-20 and lockers[i].y<players[index].y+20 and lockers[i].y>players[index].y-20 and get_1d_distance(players[index].z,lockers[i].z)<=20 and "store"==players[index].map)
{
int level=1;
if(lockers[i].z>players[index].z)
{
level=2;
}
else if(lockers[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="a locker with "+lockers[i].security_boosts+" added security is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, lockers[i].x, lockers[i].y, players[index].facing))+", "+players[index].distancecheck(lockers[i].x,lockers[i].y,lockers[i].z)+" feet away. ";
}
}
if (s=="")
s="There is nothing around";
if(in_vehicle(players[index].name)<0&&players[index].hidden==0) play("lookaround",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id, s, 2);
}
}
else if(parsed[0]=="whonear")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
string s;
for (uint i=0; i<players.length(); i++)
{
if(players[i].is_dead==true||in_vehicle(players[i].name)>-1||(players[i].invinsible&&!players[index].adminable())) continue;
if (players[i].x<players[index].x+30 and players[i].x>players[index].x-30 and players[i].y<players[index].y+30 and players[i].y>players[index].y-30 and get_1d_distance(players[index].z,players[i].z)<=30 and players[i].map==players[index].map and players[i].name!=players[index].name and players[i].invisible==false)
{
int level=1;
if(players[i].z>players[index].z)
{
level=2;
}
else if(players[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
if(players[i].shielded==true)
s+="shielded with "+players[i].health+" health ";
if(players[i].invinsible==true)
s+="AFK ";
s+=players[i].ttitle+" "+players[i].ptitle+" "+players[i].name+" with "+players[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, players[i].x, players[i].y, players[index].facing))+", "+get_3d_distance(players[index].x, players[index].y, players[index].z, players[i].x, players[i].y, players[i].z)+" feet away. ";
}
}
for(uint i=0; i<vs.length; i++)
{
if(get_3d_distance(players[index].x,players[index].y,players[index].z,vs[i].x,vs[i].y,vs[i].z)<=30&&vs[i].map==players[index].map&&vs[i].owner!=players[index].name)
{
int level=1;
if(vs[i].z>players[index].z) level=2;
if(vs[i].z<players[index].z) level=0;
s+=cn2n(vs[i].owner)+"'s "+vs[i].type+" is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, vs[i].x, vs[i].y, players[index].facing))+", "+get_3d_distance(players[index].x, players[index].y, players[index].z, vs[i].x, vs[i].y, vs[i].z)+" feet away. ";
}
}
if(s=="")
s="There is no one around";
send_reliable(players[index].peer_id,s,2);
if(in_vehicle(players[index].name)<0&&players[index].hidden==0) play("lookaround",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(parsed[0]=="whoonline")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
string s="";
string s2;
string[] outs;
for (uint i=0; i<players.length(); i++)
{
if(players[i].hidden>0)
{
continue;
}
int t2=is_in_team(players[i].name);
if(t2>-1)
{
outs.insert_last(teams[t2].teamname+" "+players[i].title+" "+players[i].ptitle+" "+players[i].nickname+" ("+players[i].name+") with "+players[i].deaths+" deaths and "+players[i].kills+" kills");
}
else
outs.insert_last(players[i].title+" "+players[i].nickname+" ( "+players[i].name+") with "+players[i].deaths+" deaths and "+players[i].kills+" kills");
}
if(players[index].masterable())
{
for(uint i=0; i<players.length; i++)
{
if(players[i].hidden>0) outs.insert_last("hidden "+players[i].nickname+" ("+players[i].name+")");
}
}
if(outs.length>1)
{
for(uint i=0; i<outs.length; i++)
{
if(i==(outs.length-1)) s+="and "+outs[i]+".";
else s+=outs[i]+", ";
}
}
else
s="You're the only one online";
if(outs.length()>1)
s2="There are currently "+outs.length()+" players online. ";
send_reliable(players[index].peer_id, s2+s, 2);
}
}
else if(parsed[0]=="build")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(players[index].masterable() or players[index].adminable())
send_menu(players[index].peer_id,"Build what?","buildobj","tile:tile[]sound source:src[]ambience:amb[]zone:zone[]travelpoint:tpoint");
}
}
else if (parsed[0]=="inv" and parsed.length()>=3)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].give(parsed[1],stn(parsed[2]));
}
}
else if(parsed[0]=="iamdmoving")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].dmoving=true;
}
}
else if(parsed[0]=="iamnotdmoving")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].dmoving=false;
}
}
else if(parsed[0]=="playonmap" and parsed.length()>1)
{
int x=get_player_index(e.peer_id);
if(x>-1)
{
int px=players[x].x;
int y=players[x].y;
int z=players[x].z;
string map=players[x].map;
for(uint i=0; i<players.length(); i++)
{
if(players[i].name!=players[x].name)
{
send_reliable(players[x].peer_id,string_replace(parsed[1],".ogg","",true)+" "+px+" "+y+" "+z+" "+map,3);
}
}
}
}
else if(parsed[0]=="updatezone" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].zone=string_replace(get_event_message(),"updatezone ","",true);
}
}
else if(parsed[0]=="vendingpress" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int vx=get_vending_index(players[index].x,players[index].y,players[index].z,players[index].map);
if(vx>-1)
{
string cmd=string_replace(get_event_message(),"vendingpress ","",false);
if(string_contains(cmd,"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
vending_machines[vx].command(cmd,e.peer_id);
}
}
}
else if(parsed[0]=="lockcode" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"canceled",0);
return;
}
if(string_is_digits(parsed[1])==false)
{
send_reliable(players[index].peer_id,"error with input",0);
send_reliable(players[index].peer_id,"play_s lockererror.ogg",0);
return;
}
int c=stn(parsed[1]);
int l=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(l>-1)
{
if(lockers[l].code==c)
{
lockers[l].lockplay("dooropen");
string stuff="Press g to get something from the locker. Press S to store something in the locker. Make a selection";
send_serverbox(players[index].peer_id,0,-1,1,1,"lockcommand",stuff);
}
else
{
send_reliable(players[index].peer_id,"Incorrect code",0);
return;
}
}
}}
else if(parsed[0]=="lockcommand" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int l=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(l>-1)
{
string cmd=string_replace(get_event_message(),"lockcommand ","",false);
lockers[l].command(cmd,players[index].peer_id);
}
}
}
else if(parsed[0]=="changelockcode" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
int l = get_locker_at(players[index].x, players[index].y, players[index].z, players[index].map);
if(string_is_digits(parsed[1]))
{
lockers[l].code=string_to_number(parsed[1]);
send_reliable(players[index].peer_id, "the code was changed successfully. New code is "+lockers[l].code, 2);
}
else
{
send_reliable(players[index].peer_id, "error", 2);
}
}
else if(parsed[0]=="shcommand" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(s>-1)
{
string command=string_replace(get_event_message(),"shcommand ","",false);
shelters[s].command(command,e.peer_id);
}
}
}
else if(parsed[0]=="shstoragecommand" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(s>-1)
{
string command=string_replace(get_event_message(),"shstoragecommand ","",false);
shelters[s].storage_command(command,e.peer_id);
}
}
}
else if(parsed[0]=="shmoneycommand" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(s>-1)
{
string command=string_replace(get_event_message(),"shmoneycommand ","",false);
shelters[s].sh_money_command(command,e.peer_id);
}
}
}
else if(parsed[0]=="shsendmoneyrequest" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(s<0)
{
send_reliable(players[index].peer_id,"An internal server error happened. Please try your request again",0);
return;
}
if(stn(parsed[1])==shelters[s].compcode)
{
string stuff="Enter shelter ID";
send_serverbox(players[index].peer_id,1,-1,0,-1,"shsendmoney",stuff);
return;
}
else
{
shelters[s].compplay("shelter_computererror");
string information="Incorrect code";
send_serverbox(e.peer_id,0,-1,1,1,"shmoneycommand",information+".\r\nwhat would you like to do");
}
}
}
else if(parsed[0]=="shmoneycashout" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(s<0)
{
send_reliable(players[index].peer_id,"An internal server error happened. Please try your request again",0);
return;
}
if(stn(parsed[1])==shelters[s].compcode)
{
string stuff="enter amount of dollars you want to take out. Amount of dollars in the computer: "+shelters[s].dollars;
send_serverbox(players[index].peer_id,2,-1,0,-1,"shcashid",stuff);
return;
}
else
{
shelters[s].compplay("shelter_computererror");
string information="Incorrect code";
send_serverbox(e.peer_id,0,-1,1,1,"shmoneycommand",information+".\r\nwhat would you like to do");
}
}
}
else if(parsed[0]=="shcashid" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
string stuff="canceled";
send_serverbox(e.peer_id,0,-1,1,1,"shmoneycommand",stuff+".\r\nwhat would you like to do");
return;
}
int s=in_shelter(players[index].name);
if(s<0)
{
send_reliable(players[index].peer_id,"Sorry, an internal error happened",0);
return;
}
double amount=stn(parsed[1]);
if(amount<0)
{
string stuff="Sorry, can't enter negative values";
send_serverbox(e.peer_id,0,-1,1,1,"shmoneycommand",stuff+".\r\nwhat would you like to do");
return;
}
if(shelters[s].dollars<amount)
{
string stuff="Error: this shelter does not have the required funds to do this operation";
send_serverbox(e.peer_id,0,-1,1,1,"shmoneycommand",stuff+".\r\nwhat would you like to do");
return;
}
string stuff="Success! Select an option";
send_serverbox(e.peer_id,0,-1,1,1,"shmoneycommand",stuff+".\r\nwhat would you like to do");
//spawn_timeitem(3,3,0,shelters[s].sheltername,"dollar",amount);
players[index].give("dollar", amount);
shelters[s].dollars-=amount;
}
}
else if(parsed[0]=="shsendmoney" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
string information="canceled";
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+".\r\nwhat would you like to do");
return;
}
int sh=get_shelter_from_id(parsed[1]);
if(sh<0)
{
string information="Error! ID not valid";
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+".\r\nwhat would you like to do");
return;
}
else
{
send_serverbox(players[index].peer_id,1,2,0,-1,"shsendnow "+parsed[1],"Enter amount of dollars you want to send to this shelter");
}
}
}
else if(parsed[0]=="shsendnow" and parsed.length()>2)
{
if(get_player_index(e.peer_id)>-1)
{
int index=get_player_index(e.peer_id);
if(parsed[2]=="[cncel]")
{
string information="canceled.";
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+"\r\nwhat would you like to do");
return;
}
string id=parsed[1];
double amount=stn(parsed[2]);
int s=in_shelter(players[index].name);
if(s<0)
{
send_reliable(players[index].peer_id,"An internal error happened. Please try your request again",0);
return;
}
else
{
if(amount<0)
{
shelters[s].compplay("shelter_computererror");
string information="Can not send a negative amount!";
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+"\r\nwhat would you like to do");
return;
}
if(shelters[s].dollars<amount)
{
shelters[s].compplay("shelter_computererror");
string information="Sorry, this shelter does not have the amount requested";
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+".\r\nwhat would you like to do");
return;
}
int s2=get_shelter_from_id(id);
if(s2<0)
{
shelters[s].compplay("shelter_computererror");
string information="No matching shelters with ID "+id;
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+".\r\nwhat would you like to do");
return;
}
shelters[s].compplay("shelter_money_transfer_sent");
shelters[s2].compplay("shelter_money_transfer_receive");
string information="Transaction completed! Thank you for using SH pay 0.4.1!";
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+"\r\nwhat would you like to do");
shelters[s].dollars-=amount;
shelters[s2].dollars+=amount;
return;
}
}
}
else if(parsed[0]=="air")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
send_reliable(players[index].peer_id,"You have "+players[index].air+" air. This should last you about "+ms_to_readable_time(players[index].air*3500),0);
}
}
else if(parsed[0]=="sitstand")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].sitting=toggle(players[index].sitting);
if(players[index].sitting==1)
{
spawn_bodyfall(players[index].x,players[index].y,players[index].z,players[index].map,500,index);
}
else
{
if(players[index].drunk==true)
{
int r=random(-50, 100);
if(r>49)
{
send_reliable(players[index].peer_id,"you can't stand up!",0);
spawn_bodyfall(players[index].x,players[index].y,players[index].z,players[index].map,500,index);
}
}
players[index].playsound("stand");
spawn_timepacket(players[index].peer_id,"sitstop",0,1000);
}
}
}
else if(parsed[0]=="newlocker" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string a=parsed[1];
if(a=="n" or a=="[cncel]")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
else if(a=="y")
{
send_reliable(players[index].peer_id,"Done! You may now  build a locker with the locker pack that was just added to your inventory",2);
players[index].give("locker_pack",1);
}
else
{
send_reliable(players[index].peer_id,"Invalid input",0);
return;
}
}
}
else if(parsed[0]=="packsomething" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="back")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
string item=parsed[1];
players[index].give(item,-10);
players[index].give("pack_of_10_"+item,1);
players[index].give("empty_pack", -1);
players[index].playsound("pack");
send_reliable(players[index].peer_id,"You put 10 "+item+"s in a box and close it",0);
}
}
else if(parsed[0]=="restartserver")
{
for(uint i=0; i<players.length; i++)
{
scd(i);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_corpses();
writedata();
save_shipments();
writedata();
save_lockers();
send_reliable(0,"notify Server rebooting",0);
send_reliable(0,"reboot",0);
wait(5);
run(get_script_path(),"",false,false);
exit();
}
else if(parsed[0]=="fallstart")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].falling=true;
}
}
else if(parsed[0]=="fallstop")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].falling=false;
}
}
else if(parsed[0]=="lchannel")
{
server_menu menu;
menu.intro="Select a new language channel";
menu.initial_packet="lchannelset";
string[] lc=string_split(file_get_contents("prefs/language_channels.svr"),"\r\n",false);
for(uint i=0; i<lc.length(); i+=1)
{
menu.add(lc[i],lc[i]);
}
menu.send(e.peer_id);
}
else if(parsed[0]=="lchannelset" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="back")
{
players[index].sendpacket("canceled", 0);
return;
}
players[index].langchan=parsed[1];
players[index].sendpacket("Using "+players[index].langchan+" as the new language channel",0);
}
}
else if(parsed[0]=="remgunidset" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="back")
{
players[index].sendpacket("Canceled",0);
return;
}
if(remgun_index(stn(parsed[1]))<0)
{
players[index].sendpacket("speak could not connect to this remgun. It may have been destroyed.",0);
return;
}
players[index].remgunid=stn(parsed[1]);
players[index].playsound("remgun_connect");
send_serverbox(players[index].peer_id,0,-1,1,1,"remguncommand","Connected! What would you like to do? Press H for help");
}
}
else if(parsed[0]=="remguncommand" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].remgunid==-1) return;
int rindex=remgun_index(players[index].remgunid);
if(rindex<0)
{
players[index].sendpacket("speak Could not send command to this remgun. It may have been destroyed.",0);
players[index].remgunid=-1;
return;
}
remguns[rindex].command(parsed[1],e.peer_id);
}
}
else if(parsed[0]=="adminlogcopy" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index<0) return;
if(players[index].adminable()==false) return;
if(parsed[1]=="back")
{
players[index].sendpacket("Canceled",0);
return;
}
if(parsed[1]=="copyall")
{
players[index].sendpacket("Log written to clipboard",0);
players[index].sendpacket("clip "+adminlog,0);
return;
}
string s=string_replace(get_event_message(),parsed[0]+" ","",false);
players[index].sendpacket("copyed",0);
players[index].sendpacket("clip "+s,0);
}
else if(parsed[0]=="movedir" and parsed.length() > 1)
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
if(players[index].stunned||in_vehicle(players[index].name)>-1||players[index].warping||(players[index].is_dead&&players[index].hidden==0)) return;
players[index].pmove(parsed[1],index);
}
}
else if(parsed[0]=="giveitem" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string item=parsed[1];
int itemamount=players[index].get_item_count(item);
if(itemamount<=0)
{
players[index].sendpacket("You dont' have any "+item+"s",0);
return;
}
string[] names;
for(uint px=0; px<players.length(); px+=1)
{
if(index==px) continue;
if(players[px].distancecheck(players[index].x,players[index].y,players[index].z)<=5 and players[px].map==players[index].map) names.insert_last(players[px].name);
}
if(names.length()<=0)
{
players[index].sendpacket("There are no players near you",0);
return;
}
server_menu m;
m.initial_packet="playergive/"+item;
m.intro="players menu";
for(uint i=0; i<names.length(); i++)
{
m.add(names[i],names[i]);
}
m.send(players[index].peer_id);
}
}
else if(string_left(parsed[0],11)=="playergive/" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
parsed.insert_last(parsed[1]);
parsed[1]=string_trim_left(parsed[0],11);
string n=parsed[2];
if(n=="back") return;
int index2=get_player_index_from(parsed[2]);
if(index2<0)
{
players[index].sendpacket("Player not found",0);
return;
}
int dist=players[index2].distancecheck(players[index].x,players[index].y,players[index].z);
if(dist>5 or players[index2].map!=players[index].map)
{
players[index].sendpacket("This player is too far away",0);
return;
}
send_serverbox(players[index].peer_id,2,-1,1,-1,"transferinv/"+n+"/"+parsed[1],"How many "+parsed[1]+"s would you like to give to "+n+"?");
}
}
else if(parsed[0]=="auctionitem" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].paid==0) send_reliable(e.peer_id,"speak this is only available to paid accounts",0);
else if(auction==true) send_reliable(e.peer_id,"speak there is already an auction in progress",0);
else if(parsed[1]=="bitcoin" or parsed[1]=="dollar" or parsed[1]=="dollar_pack") send_reliable(e.peer_id,"speak You cannot auction money for money, sir.",0);
else send_serverbox(players[index].peer_id,2,-1,1,-1,"auctioning/"+parsed[1],"How many "+parsed[1]+"s would you like to auction?");
return;
}
}
else if(string_left(parsed[0],11)=="auctioning/" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string[] inp=string_split(parsed[0],"/",false);
inp.insert_last(parsed[1]);
if(inp.length==3)
{
if(inp[2]=="[cncel]") send_reliable(e.peer_id,"speak canceled",0);
else if(stn(inp[2])<=0) send_reliable(e.peer_id,"speak you must auction at least 1 of an item!",0);
else if(players[index].get_item_count(inp[1])<stn(inp[2])) send_reliable(e.peer_id,"speak You don't have enough. You wanted to auction "+stn(inp[2])+" "+inp[1]+"s and you only have "+players[index].get_item_count(inp[1]),0);
else
{
string jerk;
for(uint i=0; i<inp.length; i++)
{
jerk+=inp[i]+"/";
}
jerk=string_trim_right(jerk,1);
send_serverbox(e.peer_id,2,-1,1,-1,jerk,"Minimum bid for this auction?");
}
}
else if(inp.length==4)
{
if(inp[3]=="[cncel]") send_reliable(e.peer_id,"speak canceled",0);
else if(stn(inp[2])<=0) send_reliable(e.peer_id,"speak bid must be greator than 0!",0);
else if(auction) send_reliable(e.peer_id,"speak there is already an auction in progress",0);
else
{
string what=inp[1];
int amount=stn(inp[2]);
int minbid=stn(inp[3]);
if (inv_item_exists(players[index].get_inv(),what))
{
if (players[index].get_item_count(what)>=amount)
{
auctionitem=what;
auctionbid=minbid;
auctionamount=amount;
auctionwho=players[index].name;
send_reliable(0,"New auction from "+players[index].nickname+"! "+amount+" "+auctionitem+", minimum bid "+minbid+" dollars.",2);
send_reliable(0,"play_s auction.ogg",0);
auctiontimer.restart();
auction=true;
auctionbidder=false;
}
else
{
send_reliable(e.peer_id,"You don't have this many.",2);
}
}
else
{
send_reliable(e.peer_id,"You don't have this item.",2);
}
}
}
}
}
else if(parsed[0]=="reginfo")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
write_to(players[index].name,"reginfo.usr",string_replace(get_event_message(),"reginfo ","",false));
}
}
else if(parsed[0]=="regstatus")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].registered=stn(parsed[1]);
if(players[index].registered>0)
{
//send_reliable(0,players[index].name+" is a registered user",0);
if(players[index].dev==false) players[index].title="*";
}
}
}
else if(parsed[0]=="move_to" and parsed.length() > 3)
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
if(players[index].stunned||in_vehicle(players[index].name)>-1||players[index].warping||(players[index].is_dead&&players[index].hidden==0)) return;
string name=players[index].name;
players[index].x=string_to_number(parsed[1]);
players[index].y=string_to_number(parsed[2]);
players[index].z=string_to_number(parsed[3]);
players[index].activitytimer.restart();
if(players[index].active==false) players[index].active=true;
if(players[index].bleedsound!=""||players[index].lowhealth||players[index].bleeding) update_moving_sound(players[index].bleedsound,players[index].x,players[index].y,players[index].z);
int v=in_vehicle(players[index].name);
if(v>-1)
{
vs.remove_at(v);
send_reliable(players[index].peer_id,"veunspawn",0);
}
string gpt=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
int a=string_contains(gpt,"glass",1);
int isair=string_contains(gpt,"underwater",1);
if(isair>-1 and players[index].dmoving==false and players[index].is_dead==false)
{
if(players[index].underwater==false) { players[index].airwarntimer.restart();players[index].airlifetimer.restart();
players[index].underwater=true;
}
}
if(isair<0 and players[index].dmoving==false)
{
if(players[index].underwater==true) players[index].underwater=false;
}
if(a>-1and players[index].dmoving==false and players[index].is_dead==false) {
players[index].health-=random(10,25);
players[index].hitby="shards of glass";
}
//if(gpt!="" and players[index].dmoving==false and in_vehicle(players[index].name)<0)
//players[index].playobjs();
if(players[index].dmoving==false and players[index].hidden==0 and gpt!="")
{
int sh=in_shelter(players[index].name);
if(sh>-1)
play("shelterstep"+random(1,5),players[index].x,players[index].y,players[index].z,players[index].map,index,true,false);
else
play(gpt+"step"+random(1,5),players[index].x,players[index].y,players[index].z,players[index].map,index,true,false);
}
}
}
}
}
}
void send_unreliable_x(uint peer, string mess, uint channel, int tx, int ty, int tz, string tmap)
{
mess=string_encrypt(mess, "stupdengoanddeniz");
for(uint i=0; i<players.length(); i++)
{
if(players[i].x > tx-50 and players[i].x < tx+50 and players[i].y > ty-50 and players[i].y < ty+50 and players[i].z > tz-50 and players[i].z < tz+50 and players[i].map==tmap)
{
n.send_unreliable(players[i].peer_id, mess, channel);
}
}
}
void send_reliable_x(uint peer, string mess, uint channel, int tx, int ty, int tz,string tmap,int range=50)
{
mess=string_encrypt(mess, "stupdengoanddeniz");
for(uint i=0; i<players.length(); i++)
{
if(players[i].x > tx-range and players[i].x < tx+range and players[i].y > ty-range and players[i].y < ty+range and players[i].z > tz-range and players[i].z < tz+range and players[i].map==tmap)
{
n.send_reliable(players[i].peer_id, mess, channel);
}
}
}
void send_reliable(uint peer, string mess, uint channel, int index=-1)
{
mess=string_encrypt(mess, "stupdengoanddeniz");
if(index>-1)
{
int x=players[index].x;
int y=players[index].y;
int z=players[index].z;
for(uint i=0; i<players.length(); i++)
{
if(players[i].x > x-50 and players[i].x < x+50 and players[i].y > y-50 and players[i].y < y+50 and players[i].z > z-50 and players[i].z < z+50 and players[i].map==players[index].map and i!=index)
{
n.send_reliable(players[i].peer_id, mess, channel);
}
}
}
else
{
n.send_reliable(peer, mess, channel);
}
}
void send_unreliable(uint peer, string mess, uint channel, int index=-1)
{
mess=string_encrypt(mess, "stupdengoanddeniz");
if(index>-1)
{
int x=players[index].x;
int y=players[index].y;
int z=players[index].z;
for(uint i=0; i<players.length(); i++)
{
if(players[i].x > x-50 and players[i].x < x+50 and players[i].y > y-50 and players[i].y < y+50 and players[i].z > z-50 and players[i].z < z+50 and players[i].map==players[index].map and i!=index)
{
n.send_unreliable(players[i].peer_id, mess, channel);
}
}
}
else
{
n.send_unreliable(peer, mess, channel);
}
}
string get_event_message()
{
string r=e.message;
if(r=="")
{
return "";
}
r=string_decrypt(r, "stupdengoanddeniz");
return r;
}
void mapupdate(string map)
{
init_mapsystem();
int mi=get_map_index(map);
if(mi<0) return;
string mdata=maps[mi].rawdata;
string ite;
for(uint i=0; i<sources.length(); i++)
{
if(sources[i].map==map)
ite+="src:"+sources[i].lx+":"+sources[i].rx+":"+sources[i].miny+":"+sources[i].maxy+":"+sources[i].minz+":"+sources[i].maxz+":"+sources[i].soundfile+":"+sources[i].id+"\r\n";
}
for(uint i=0; i<robots.length(); i++)
{
if(robots[i].map==mi) {
destroy_moving_sound(robots[i].voice);
robots.remove_at(i);
}
}
maps[mi].currobots=0;

for(uint i=0; i<players.length(); i++)
{
if(players[i].map==map)
{
players[i].map=map;
send_reliable(players[i].peer_id, "m_data "+mdata+"\r\n"+ite+"\r\nx:"+players[i].x+"\r\ny:"+players[i].y+"\r\nz:"+players[i].z+"\r\n", 0);
}
}
}
void playermapupdate(string map, int x, int y, int z, player@ p)
{
string mdata=get_map_text(map);
string ite;
for(uint i=0; i<sources.length(); i++)
{
if(sources[i].map==map)
ite+="src:"+sources[i].lx+":"+sources[i].rx+":"+sources[i].miny+":"+sources[i].maxy+":"+sources[i].minz+":"+sources[i].maxz+":"+sources[i].soundfile+":"+sources[i].id+"\r\n";
}
p.x=0;
p.y=0;
p.z=0;
send_reliable(p.peer_id,"mapname "+map,0);
p.map=map;
send_reliable(p.peer_id, "m_data "+mdata+"\r\n"+ite+"\r\nx:"+x+"\r\ny:"+y+"\r\nz:"+z+"\r\n", 0);
}
string motd()
{
string fmotd=file_get_contents("prefs/motd.svr");
if(fmotd=="")
fmotd="No server message";
return fmotd;
}
void login(string u, string p, string yv, uint id, string compid)
{
bool can_login=true;
string ip=n.get_peer_address(id);
if(is_compbanned(compid,u) or is_ipbanned(ip,u))
{
send_reliable(id,"banned",0);
can_login=false;
}
if(tempbancheck(u))
{
int t=get_tempban_index(u);
can_login=false;
send_reliable(id,"block Your account is currently disabled. Please try again in "+ms_to_readable_time(tempbans[t].ms-tempbans[t].tempbantimer.elapsed),0);
}
multiversion yver(yv);
multiversion minver(minverstring);
if(yver<minver)
{
send_reliable(id,"block your client is out of date. Your version: "+yv+". Minimum required version is "+minverstring,0);
can_login=false;
}
if(can_login==true)
{
if(!compid_handlercheck(compid))
{
add_compid(compid,u);
}
string charfolder="chars/"+u;
file f, chardata;
if(directory_exists("chars/"+u)==false)
{
send_reliable(id,"nochar",0);
}
else
{
file charfile;
charfile.open("chars/"+u+"/password.usr","rb");
string charpass=charfile.read();
charfile.close();
if(charpass!=string_hash(p,2,false))
{
send_reliable(id,"wrongpass",0);
}
else
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].name==u)
{
 if(players[i].hidden==0) send_reliable(0,u+" has been overwritten",2);
remove_player(u);
}
}
if(file_get_contents(charfolder+"/map.usr")=="")
{
file_put_contents(charfolder+"/map.usr","main",FILE_WRITE);
}
f.open(charfolder+"/map.usr","rb");
string m=f.read();
f.close();
send_reliable(id,"mapname "+m,0);
if(file_get_contents(charfolder+"/facing.usr")=="") file_put_contents(charfolder+"/facing.usr","0",FILE_WRITE);
if(file_get_contents(charfolder+"/x.usr")=="") file_put_contents(charfolder+"/x.usr",""+random(0,500),FILE_WRITE);
if(file_get_contents(charfolder+"/y.usr")=="") file_put_contents(charfolder+"/y.usr",""+random(0,500),FILE_WRITE);
if(file_get_contents(charfolder+"/z.usr")=="") file_put_contents(charfolder+"/z.usr","0",FILE_WRITE);
f.open(charfolder+"/facing.usr","rb");
send_reliable(id,"facing "+f.read(),0);
f.close();
f.open(charfolder+"/x.usr","rb");
send_reliable(id,"x "+f.read(),0);
f.close();
f.open(charfolder+"/y.usr","rb");
send_reliable(id,"y "+f.read(),0);
f.close();
f.open(charfolder+"/z.usr","rb");
send_reliable(id,"z "+f.read(),0);
f.close();
send_reliable(id, "motd "+motd(), 0);
log("connections",u+" logged in.",true,true);
send_reliable(id, "loggedin", 0);
}
}
}
}
int get_player_index(uint id)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].peer_id==id)
{
return i;
}
}
return -1;
}
int get_player_index_from(string name, bool evenhidden=true)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].name==name)
{
if(!evenhidden&&players[i].hidden>0) continue;
 return i;
}
}
return -1;
}
int get_item_index(string name)
{
string[] items;
for(int i=0; i<stores.length; i++)
{
for(int i2=0; i2<stores[i].item_names.length(); i2++)
{
items.insert_last(stores[i].item_names[i2]);
}
}
for(int i=0; i<items.length(); i++)
{
if(items[i]==name) return i;
}
return -1;
}
void create_char(string username, string password, string email,uint id, string compid)
{
if(filter(username))
{
send_reliable(id,"Error: this username contains eloquence crash codes",0);
return;
}
if(filterchar(username,true))
{
send_reliable(id,"Error: this username contains invalid characters",0);
return;
}
/*
int cindex=get_compid_handler_index(compid);
if(cindex>-1)
{
send_reliable(id,"Error: it seems as though you have created an other account ("+comphandles[cindex].playername+") if you get this message and you have not created an account, contact the developers",0);
return;
}
*/
string ip=n.get_peer_address(id);
if(is_compbanned(compid,"") or is_ipbanned(ip,""))
{
send_reliable(id,"Error: This client is banned",0);
return;
}
string charfolder="chars/"+username;
if(!directory_exists("chars"))
directory_create("chars");
if(directory_exists(charfolder)==false)
{
directory_create(charfolder);
file c;
c.open(charfolder+"/level.usr","w");
c.write("1");
c.close();
c.open(charfolder+"/health.usr","wb");
c.write("10000000");
c.close();
c.open(charfolder+"/newb.usr","wb");
c.close();
c.open(charfolder+"/password.usr","wb");
c.write(string_hash(password,2,false));
c.close();
c.open(charfolder+"/facing.usr","wb");
c.write("0");
c.close();
c.open(charfolder+"/x.usr","wb");
c.write(random(0,500));
c.close();
c.open(charfolder+"/y.usr","wb");
c.write(random(0,500));
c.close();
c.open(charfolder+"/z.usr","wb");
c.write("0");
c.close();
c.open(charfolder+"/eml.usr","wb");
c.write(email);
c.close();
add_compid(compid,username);
send_reliable(id,"createdchar",0);
send_reliable(0,"play_s notify_reboot.ogg",0);
send_reliable(0,"the player "+username+" has been created!",2);
}
else
send_reliable(id,"alreadyexists",0);
}
void play(string sound, double x, double y, double z, string map, int index=-1, bool onlynear=true, bool reliable=true, int channel=3)
{
if(onlynear==true)
{
if(index>-1)
{
if(reliable)
send_reliable(0, sound+" "+x+" "+y+" "+z+" "+map, channel, index);
else
send_unreliable(0, sound+" "+x+" "+y+" "+z+" "+map, channel, index);
}
else
{
if(reliable)
send_reliable_x(0, sound+" "+x+" "+y+" "+z+" "+map, channel, x, y, z,map);
else
send_unreliable_x(0, sound+" "+x+" "+y+" "+z+" "+map, channel, x, y, z,map);
}
}
else
send_reliable(0, sound+" "+x+" "+y+" "+z+" "+map, channel);
}
string read_from(string name,string val)
{
string ret;
file f;
int index=get_player_index_from(name);
if(index>-1)
{
string charfolder="chars/"+players[index].name;
f.open(charfolder+"/"+val+".usr","rb");
ret=f.read();
f.close();
return ret;
}
else
return "error";
}
void write_to(string name, string fn, string c)
{
fl.open("chars/"+name+"/"+fn, "wb");
fl.write(c);
fl.close();
}

void write_to(string name, string fn, double c)
{
file f;
f.open("chars/"+name+"/"+fn, "wb");
f.write(c);
f.close();
}
void respawn(int index)
{
move_player(players[index],players[index].map,players[index].x,players[index].y,players[index].z);
players[index].is_dead=false;
players[index].storetimer.restart();
players[index].storestage=1;
players[index].oldhealth=players[index].health;
players[index].sitting=1;
send_reliable(players[index].peer_id,"sitstart",0);
players[index].statchangetimer.force(60000);
}
void move_player(player@p, string map, int x, int y, int z, bool sound=true,bool command=false,int sindex=-1)
{
if(p.hidden>0 or p.invinsible) sound=false;
if(sound==true)
play("unspawn",p.x,p.y,p.z,p.map);
p.x=x;
p.y=y;
p.z=z;
bool mapchanged=false;
if(map!=p.map or command==false) mapchanged=true;
if(map!=p.map)
{
if(in_shelter(p.name)>-1 or p.map=="store") send_reliable(p.peer_id,"exitshelter",0);
else if(shelter_exists(map))
{
int x2=get_shelter_index(map);
if(x2>-1) send_reliable(p.peer_id,"entershelter "+shelters[x2].x+" "+shelters[x2].y+" "+shelters[x2].z+" "+shelters[x2].map,0);
}
else if(map=="store") send_reliable(p.peer_id,"entershelter "+storex+" "+storey+" "+storez+" main",0);
}
if(mapchanged)
{
p.map=map;
string ite;
for(uint i=0;i<sources.length();i++)
{
if(sources[i].map==map)
ite+="src:"+sources[i].lx+":"+sources[i].rx+":"+sources[i].miny+":"+sources[i].maxy+":"+sources[i].minz+":"+sources[i].maxz+":"+sources[i].soundfile+":"+sources[i].id+"\r\n";
}
send_reliable(p.peer_id,"mapname "+map,0);
if(sindex>-1)
send_reliable(p.peer_id, "m_data "+shelters[sindex].generate_map()+ite, 0);
else
send_reliable(p.peer_id, "m_data "+get_map_text(map)+ite, 0);
if(p.bleedsound!="" or p.bleeding)
{
destroy_moving_sound(p.bleedsound);
p.bleedsound=spawn_moving_sound("bleeding.ogg",p.x,p.y,p.z,p.map);
}
}
send_reliable(p.peer_id,"move "+p.x+" "+p.y+" "+p.z,0);
if(mapchanged==false and p.bleedsound!="") update_moving_sound(p.bleedsound,p.x,p.y,p.z);
if(sound==true)
{
send_reliable(0,"distsound movedist "+p.x+" "+p.y+" "+p.z+" "+p.map,0);
play("move",p.x,p.y,p.z,p.map);
}
}
void updatesvr()
{
bool updating=false;
send_reliable(0,"updatesvr",0);
wait(5);
send_reliable(0,"updatesvr",0);
bool result=run("updater.exe","",false,false);
exit();
}
void setmotd(string newmotd,bool public=true)
{
file mfile;
mfile.open("prefs/motd.svr","wb");
mfile.write(newmotd);
mfile.close();
if(public==true) send_reliable(0,"server message has been changed  "+newmotd,2);
}
string get_location(int id)
{
if(geo==0) return "geolocating is disabled";
l.set_ip(n.get_peer_address(id));
l.request();
string data="from: "+l.get_city()+", "+l.get_state()+" "+l.get_country_name()+" "+l.get_zipcode()+". \r\ntimezone: GMT "+l.get_time_zone()+". \r\n";
return data;
}
void send_inv(int index)
{
if(index>-1)
{
if(!file_exists("chars/"+players[index].name+"/inv.usr") and has_shelter(players[index])==false)
file_copy("prefs/default_inv.svr","chars/"+players[index].name+"/inv.usr",true);
file f;
f.open("chars/"+players[index].name+"/inv.usr","rb");
string inv=f.read();
string[] invvalues=string_split(inv,"\r\n",false);
for(uint i=0; i<invvalues.length(); i++)
{
string[] invparser=string_split(invvalues[i],"=",true);
players[index].give(invparser[0],stn(invparser[1]),false);
}
send_reliable(players[index].peer_id,"invstring "+string_compress(players[index].get_inv(false)),0);
}
}
bool has_remgun(string name)
{
for(uint i=0; i<remguns.length(); i++)
{
if(remguns[i].owner==name)
{
return true;
}
}
return false;
}
int select_random_player(string noname="")
{
int[] indexs;
for(uint i=0; i<players.length(); i++)
{
if(players[i].invinsible==true or players[i].is_dead==true or players[i].invisible==true or players[i].name==noname) continue;
indexs.insert_last(get_player_index(players[i].peer_id));
}
if(indexs.length<=0)
{
return -1;
}
else
return indexs[random(0,indexs.length()-1)];
}

void exitsvr()
{
for(uint i=0; i<players.length(); i++)
{
scd(i);
}
wait(5);
send_reliable(0,"killclient",0);
wait(5);
destroy_all_canisters();
destroy_all_mines();
destroy_all_timebombs();
destroy_all_motion_bombs();
destroy_all_wirebombs();
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_corpses();
writedata();
save_lockers();
writedata();
save_shipments();
exit();
}
string killmsg(string player1, string player2, string player1weapon)
{
string temp=killmsgs[random(0,killmsgs.length()-1)];
if(string_contains(player1,"'",1)>-1)
{
string pn=string_left(player1,string_contains(player1,"'",1));
player1=string_replace(player1,pn,cn2n(pn),false);
}
else player1=cn2n(player1);
if(string_contains(player2,"'",1)>-1)
{
string pn=string_left(player2,string_contains(player2,"'",1));
player2=string_replace(player2,pn,cn2n(pn),false);
}
else player2=cn2n(player2);
if(string_left(player2,9)=="internal:") temp=internal_killmsg(string_trim_left(player2,9));
temp=string_replace(temp,"%1",player1,true);
temp=string_replace(temp,"%2",player2,true);
temp=string_replace(temp,"%3",player1weapon,true);
log("eventstream","death: "+temp);
return temp;
}
void givegift() {
int gifted=random(0,players.length()-1);
string gift=gifts[random(0,gifts.length()-1)];
players[gifted].give(gift,1);
send_reliable(0,"A random gift has been given out. The recipient, randomly chosen, was "+players[gifted].name+", and they have received "+gift,2);
send_reliable(players[gifted].peer_id,"the server has given you a gift! The item is "+gift,2);
play("gift",players[gifted].x,players[gifted].y,players[gifted].z,players[gifted].map);
}
void giftloop()
{
if(gifttimer.elapsed>=300000 and gifting==1 and players.length()>0)
{
gifttimer.restart();
givegift();
}
}
double stn(string the_string)
{
return string_to_number(the_string);
}
string randomstring(uint length=10,int mode=1)
{
string lets="abcdefghijklmnopqrstuvwxyz";
string nums="1234567890";
string temp;
if(mode==1)
temp=lets+nums;
else if(mode==2)
temp=nums;
else if(mode==3)
temp=lets;
string ret;
for(uint i=0; i<length; i++)
{
ret=ret+temp[random(0,(temp.length()-1))];
}
return ret;
}
/*
void add_to_store(string item_name, string item_description, int amount) {
store_items.insert_last(item_name);
descriptions.insert_last(item_description);
amounts.insert_last(amount);
}
*/
void send_store(int playerindex) {
if(playerindex>-1)
{
int dollars=players[playerindex].get_item_count("dollar");
server_menu menu;
menu.initial_packet="buysomething";
menu.intro="What do you wish to buy";
for(uint i=0; i<store_items.length(); i++)
{
int canbuy=dollars/amounts[i];
menu.add(store_items[i]+" for "+amounts[i]+" dollars. Description, "+descriptions[i]+". You can buy "+canbuy,store_items[i]);
}
menu.send(players[playerindex].peer_id);

/*
string packet="store ";
for(uint i=0; i<store_items.length(); i++)
{
packet+=store_items[i]+". Price: "+amounts[i]+" dollars. "+descriptions[i]+"\r\n";
}
send_reliable(players[playerindex].peer_id,packet,0);
*/
}
}
void purchase(string name, int amount, int index)
{
if(index>-1)
{
if(amount<=0)
{
send_reliable(players[index].peer_id,"you must buy at least 1 of any item to buy anything!",2);
play("store_error",players[index].x,players[index].y,players[index].z,players[index].map);
return;
}
int itemindex=get_item_index(name);
if(itemindex>-1)
{
int[] a=get_amounts();
double totalamount=amount*a[itemindex];
if(totalamount<=0)
{
send_reliable(players[index].peer_id,"overflow error.",2);
play("store_error",players[index].x,players[index].y,players[index].z,players[index].map);
return;
}
int dollar=players[index].get_item_count("dollar");
if(dollar<totalamount)
{
send_reliable(players[index].peer_id,"Error. Not enough dollars. You need "+totalamount+" dollars and you only have "+players[index].get_item_count("dollar")+".",0);
play("store_error",players[index].x,players[index].y,players[index].z,players[index].map);
}
else
{
players[index].give("dollar",-totalamount);
players[index].give(name,amount);
if(amount==1) send_reliable(players[index].peer_id,"1 "+name+" purchased",2);
else send_reliable(players[index].peer_id,""+amount+" "+name+"s purchased",2);
players[index].add_log_entry("player_actions","bought "+amount+" "+name+"s");
storeplay("purchase",3,index);
play("store_purchase_success",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
}
}
int inv_item_number(string inv, string item)
{
string content=inv;
string[] invvalues=string_split(content,"\r\n",false);
int res;
for(uint i=0; i<invvalues.length(); i++)
{
string[] parsed=string_split(invvalues[i],"=",false);
if(parsed[0]==item)
{
res=stn(parsed[1]);
}
}
return res;
}
bool inv_item_exists(string inv, string itemname)
{
string content=inv;
string[] peramitors=string_split(content, "\r\n", true);
string[] values;
for(uint i=0; i<peramitors.length(); i++)
{
values.insert_at(i,string_replace(peramitors[i], string_left(peramitors[i], string_contains(peramitors[i], "=", 1)+1), "", true));
peramitors[i]=string_replace(peramitors[i], "="+values[i], "", true);
}
for(uint i=0; i<peramitors.length(); i++)
{
if(peramitors[i]==itemname)
{
return true;
}
}
return false;
}
void send_serverbox(int peerid, int mode=0, int maxlength=-1, int autosend=0, int keypresses=-1, string sendtext="server_box", string text="enter text")
{
send_reliable(peerid,"input ++"+mode+"++"+maxlength+"++"+autosend+"++"+keypresses+"++"+sendtext+"++"+text,0);
}
void send_menu(int id, string menuintro, string text, string items)
{
menuintro=string_replace(menuintro," ","[SPCE]",true);
text=string_replace(text, " ", "[SPCE", true);
send_reliable(id,"launchmenu "+menuintro+" "+text+" "+items,0);
}
void updateloop()
{
if(updatingsvr==false) return;
if(updatenotified==false)
{
updatenotified=true;
send_reliable(0,"notify the server is being updated. All vehicles are now being controled. Please wait for termination.",0);
}
if(updatevstopped==false)
{
updatevstopped=true;
for(uint i=0; i<vs.length; i++)
{
if(vs[i].speed>0) vs[i].command("enter",true);
}
for(int i=0; i<players.length(); i++)
{
int e=is_part_of_event(players[i].name);
if(e>-1) events[e].leave(players[i], true, true);
}
}
if(updatevstopped&&!updatevkilled&&updatingtimer.elapsed>=4500)
{
updatevkilled=true;
for(uint i=0; i<vs.length; i++)
{
vs[i].command("escape",true);
}
}
if(updatingtimer.elapsed>=10000)
{
send_reliable(0,"notify The server is updating! Reconnecting to server",0);
for(uint i=0; i<players.length; i++)
{
scd(i);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_corpses();
writedata();
save_lockers();
writedata();
save_shipments();
writedata();
save_bombs();
file_delete("update.txt");
updatesvr();
}
}
string get_day()
{
string ret;
if(day==1)
{
ret="Monday";
}
else if(day==2)
{
ret="Tuesday";
}
else if(day==3)
{
ret="Wednesday";
}
else if(day==4)
{
ret="Thursday";
}
else if(day==5)
{
ret="Friday";
}
else if(day==6)
{
ret="Saturday";
}
else if(day==7)
{
ret="Sunday";
}
else
{
ret="unknown";
}
return ret;
}
string convert_month(int m)
{
string ret;
if(m==1)
ret="january";
else if(m==2)
ret="Febuary";
else if(m==3)
ret="March";
else if(m==4)
ret="April";
else if(m==5)
ret="May";
else if(m==6)
ret="June";
else if(m==7) ret="July";
else if(m==8)
ret="Augast";
else if(m==9)
ret="September";
else if(m==10)
ret="October";
else if(m==11)
ret="november";
else if(m==12)
ret="december";
else
ret="Unknown";
return ret;
}

bool toggle(bool b)
{
bool br=(b==true ? false : true);
return br;
}
int toggle(int intt)
{
if(intt==0) return 1;
else return 0;
}
string[] get_registered_users()
{
string[] pls;
for(uint i=0; i<players.length(); i++)
{
if(players[i].registered>0) pls.insert_last(i);
}
return pls;
}
string get_registered_names()
{
string[] chars=find_directories("chars/*");
string info;
int reg=0;
for(uint i=0; i<chars.length(); i++)
{
if(file_exists("chars/"+chars[i]+"/reginfo.usr"))
{
reg++;
info+=chars[i]+", ";
}
}
return "There are "+chars.length()+" characters on the server. Out of all of them, "+reg+" are registered. They are: "+info;
}
void storeplay(string what, int max,int x,bool custom=false, int xx=0, int y=0, int z=0)
{
if(x>-1 and announcertimer.elapsed>=25000)
{
announcertimer.restart();
string soundfile="store_v_"+what+random(1,max);
if(custom==false)
{
playint(soundfile,players[x].name);
playext(soundfile,players[x].x,players[x].y,players[x].z,"store",players[x].name);
}
else
{
playint(soundfile,players[x].name);
playext(soundfile,xx,y,z,"store",players[x].name);
}
}
}
void intercept(int x,int y, int z, string map, int index=-1)
{
if(index>-1)
{
for(uint j=0; j<carrier_missiles.length(); j++)
{
int dist=get_3d_distance(carrier_missiles[j].x,carrier_missiles[j].y,carrier_missiles[j].z,x,y,z);
if(dist<=10 and carrier_missiles[j].map==map and carrier_missiles[j].intercepted==false)
{
int index2=get_player_index_from(carrier_missiles[j].owner.name);
if(index2>-1)
{
send_reliable(players[index2].peer_id,"Your carrier missile was just intercepted by "+players[index].name+"!",2);
send_reliable(players[index].peer_id,"You're interceptor just intercepted "+players[index2].name+"'s carrier missile!",2);
play("missile_interceptor_hit",carrier_missiles[j].x,carrier_missiles[j].y,carrier_missiles[j].z,map);
destroy_moving_sound(carrier_missiles[j].mid);
carrier_missiles[j].intercepted=true;
carrier_missiles[j].intercepttimer.restart();
}
}
}
for(uint j=0; j<missiles.length(); j++)
{
int dist=get_3d_distance(missiles[j].x,missiles[j].y,missiles[j].z,x,y,z);
if(dist<=7 and missiles[j].map==map and missiles[j].intercepted==false)
{
int index2=get_player_index_from(missiles[j].owner.name);
if(index2>-1)
{
send_reliable(players[index2].peer_id,"Your missile was just intercepted by "+players[index].name+"!",2);
send_reliable(players[index].peer_id,"You're interceptor just intercepted "+players[index2].name+"'s missile!",2);
play("missile_interceptor_hit",missiles[j].x,missiles[j].y,missiles[j].z,map);
destroy_moving_sound(missiles[j].mid);
missiles[j].intercepted=true;
missiles[j].intercepttimer.restart();
}
}
}
}
}
void validate_server()
{
tts_voice vo;
string mode=url_ret("http://enes-productions.tr.ht/tk/svrm.dat");
if(get_last_error()!=0)
{
vo.speak_wait("There was an error. The server could not be validated at this moment. Please try again later");
exit();
}
if(mode!="success")
{
vo.speak_wait("The server could not be validated. Version not authorized. Exiting now...");
exit();
}
}
/*
void versioncheck()
{
string v=url_ret("http://enes-productions.tr.ht/tk/svrv.dat");
bool versionfound=false;
if(get_last_error()==0)
versionfound=true;
double newver=stn(v);
if(newver>version and versionfound==true and newver!=0)
{
speak("A new update to the server was found. Downloading new version now, and updating");
send_reliable(0,"The server has detected a new version. This upgrade will be applied in 1 minute. Please do not restart the server.",2);
string filenew=dl_file("http://enes-productions.tr.ht/tk/server.exe","server1.exe");
if(filenew=="finished")
speak("Downloading extra update tools");
filenew=dl_file("http://enes-productions.tr.ht/tk/server_updater.exe","updater.exe");
if(filenew=="finished")
updatingsvr=true;
updatingtimer.restart();
}
}

*/
string random_string_from_array(string[] arraystring)
{
string retval=arraystring[random(0,arraystring.length()-1)];
return retval;
}
bool filter(string message)
{
if(filterstuff==0) return false;
message=string_to_lower_case(message);
string[] filter;
filter.insert_last("re=\\b(\\w+[bdflmnrvzqh])hes([bcdfgjklmnprtw]\\w+)\\b");
filter.insert_last("re=(\\d):(\\d\\d[snrt][tdh])");
filter.insert_last("re=([hH])'([bBdDfFjJkKpPtTvVxX]+)'([rR][aAeEiIoOuU]?)");
filter.insert_last("re=(re|un|non|anti)cosp");
filter.insert_last("re=(t+)zsche");
filter.insert_last("re=(anti|non|re|un)caesure");
filter.insert_last("re=(EUR[A-Z]+)(\\d+)");
for(int counter=0; counter<filter.length(); counter++)
{
string banned=filter[counter];
if(string_left(banned, 3)=="re=")
{
banned=string_trim_left(banned, 3);
if(regexp(message, banned))
{
return true;
}
}
if(string_contains(message, filter[counter], 1)>-1)
{
return true;
}
}
return false;
}

bool filterchar(string message,bool strict=false,string additional="")
{
string filter;
if(!strict) filter="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 !\"£$%^&*()-_=+[]{};:'@#\\|,./<>?`~\t\r\n";
else filter="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_";
filter+=additional;
bool found=false;
for(int counter=0; counter<message.length(); counter++)
{
found=false;
for(int search=0; search<filter.length(); search++)
{
if(message[counter]==filter[search])
{
found=true;
break;
}
}
if(!found)
{
return true;
}
}
return false;
}

bool regexp(string message, string pattern)
{
library re;
if(!re.load("filter.dll"))
{
return false;
}
int handle=-1;
int rex=-1;
int matches=-1;
dictionary@ result=re.call("int regexp_create();");
result.get("0", handle);
@result=re.call("int result_create();");
result.get("0", rex);
re.call("void regexp_compile(int, char*, int);", handle, pattern, 0);
re.call("void regexp_match(int, char*, int, int);", handle, message, -1, rex);
@result=re.call("int result_ismatched(int);", rex);
result.get("0", matches);
re.call("void result_free(int);", rex);
re.call("void regexp_free(int);", handle);
if(matches>0)
{
return true;
}
return false;
}
bool actually_change_password(string name, string newpassword)
{
if(!file_exists("chars/"+name+"/password.usr")) return false;
else
{
file f;
bool ret;
ret=f.open("chars/"+name+"/password.usr","wb");
if(!ret) return false;
f.write(string_hash(newpassword,2,false));
f.close();
return true;
}
}
void change_password(string name, string oldpass, string newpass, uint id)
{
if(oldpass==newpass)
{
send_reliable(id,"You cannot change your password to what it already is.",2);
return;
}
else if(unencrypt_password(name)!=oldpass)
{
send_reliable(id,"Error: Given old password is invalid.",2);
return;
}
else if(oldpass==unencrypt_password(name))
{
bool retthing=actually_change_password(name,newpass);
if(!retthing)
{
send_reliable(id,"Something went wrong.",2);
}
else
{
send_reliable(id,"Your password has been changed.",2);
}
}
}
string internal_killmsg(string act)
{
if(act=="drown") return "%1 has drowned!";
if(act=="rg:expire") return "%1 has expired!";
else if(act=="rg:destruct") return "%1 just self destructed!";
else if(string_left(act,8)=="vehicle:") return "%1 was obliterated by the explosion of their "+string_trim_left(act,8);
else return "%1 was terminated by "+act;
}
void instant_notify(string event,string name=" ")
{
log("events",event,false,true);
string result=p.post("tk server"+(beta ? " beta" : ""),name,event);
//result=p2.post("tk server"+(beta ? " beta" : ""),name,event);
}
dictionary wdata;
void setupserver()
{
/*
string[] wpn=string_split(wnames," ",false);
for(uint i=0; i<wpn.length(); i++)
{export_weapon(wpn[i]);
}
*/
wdata.set("fists","1 norm");
wdata.set("knife","280 norm");
wdata.set("feet","20 norm");
wdata.set("admingun","800 norm");
wdata.set("m2browning","200 auto");
wdata.set("ML420HuntingRifle","2000 norm");
wdata.set("mp5_machine_pistol","500 auto");
wdata.set("s&w_model66_revolver","1 norm");
wdata.set("mlk_203_combat_pistol","100 norm");
wdata.set("crossbow","600 norm");
wdata.set("famas","100 auto");
wdata.set("rocketlauncher","5000 norm");
wdata.set("rpg7","3000 norm");
wdata.set("bazooka","500 norm");
wdata.set("beretta_m9_pistol","400 norm");
wdata.set("beretta_m1951_machine_pistol","200 auto");
wdata.set("mp5","300 auto");
wdata.set("beretta_nano_pocket_pistol","300 norm");
wdata.set("blz83_portable_machine_gun","200 auto");
wdata.set("brass_knuckles","500 norm");
wdata.set("broken_rifle","700 norm");
wdata.set("browning_high_power_bda_handgun","150 norm");
wdata.set("browning_m2_heavy_50_cal_machinegun","200 auto");
wdata.set("colt_ar_15_assault_rifle","100 norm");
wdata.set("colt_python_revolver","400 norm");
wdata.set("cop_357_derringer_pistol","1000 norm");
wdata.set("crow_bar","700 norm");
wdata.set("crt17_combat_knife","100 norm");
wdata.set("crt43_automatic_shotgun","200 norm");
wdata.set("glock_17_pistol","200 norm");
wdata.set("golden_war_axe","600 norm");
wdata.set("hammer","250 norm");
wdata.set("dart_launcher","2000 norm");
wdata.set("revolver","500 norm");
wdata.set("taser","8000 norm");
wdata.set("iron_shovel","1000 norm");
wdata.set("large_iron_club","600 norm");
wdata.set("m4a1_assault_rifle","400 auto");
wdata.set("m16_assault_rifle","200 auto");
wdata.set("m24_sniper_rifle","2000 norm");
wdata.set("m134_minigun","150 auto");
wdata.set("m1208_shotgun","2000 norm");
wdata.set("machete","400 norm");
wdata.set("svd","1000 norm");
wdata.set("mlk_207_combat_rifle","150 norm");
wdata.set("modern_sub_machine_gun_carbine","100 auto");
wdata.set("nak_nk1000_decimater","2000 norm");
wdata.set("nunchaku","200 norm");
wdata.set("ruger_security_6_revolver","150 norm");
wdata.set("rusty_axe","300 norm");
wdata.set("saiga_12_5_round_shotgun","2000 norm");
wdata.set("sig_p226_combat_pistol","150 norm");
wdata.set("sky_28_laser","250 norm");
wdata.set("sky_127_laser_handgun","500 norm");
wdata.set("sky_286_laser_pistol","500 norm");
wdata.set("sky_372_laser_machinegun","200 norm");
wdata.set("sky_386_laser_assault_rifle","500 norm");
wdata.set("sky_429_laser_shotgun","600 norm");
wdata.set("stp_s84q_automatic_suppressed_pistol","200 auto");
wdata.set("stp21_handgun","250 norm");
wdata.set("str_32_pump_action_shotgun","1000 norm");
wdata.set("str_301_long_barreled_machine_pistol","150 auto");
wdata.set("walther_p99_handgun","200 norm");
wdata.set("ml_Automatic_machinegun","150 auto");
wdata.set("stp106_long_barreled_pistol","100 norm");
wdata.set("ak47_assault_rifle","200 auto");
wdata.set("barrett_m82_sniper_rifle","3000 norm");
wdata.set("dragunovp_sniper","2500 norm");
wdata.set("cannon","5000 norm");
wdata.set("FRNTAssaultRifle","200 norm");
wdata.set("m29_sniper_rifle","2000 norm");
wdata.set("shotgun","2000 norm");
wdata.set("glock","300 norm");
wdata.set("sks","1000 norm");
wdata.set("sniper","1000 norm");
wdata.set("m4","150 auto");
wdata.set("m8a7","100 auto");
wdata.set("m16","200 auto");
wdata.set("m1891","200 auto");
wdata.set("m1921a1","200 auto");
wdata.set("strong_machinegun","500 norm");
wdata.set("pistol","200 norm");
wdata.set("glock","2500 norm");
wdata.set("grenade_launcher","1400 norm");
wdata.set("kalashnikov_rifle","2000 norm");
wdata.set("ml7tinymg","150 auto");
wdata.set("mossberg500","700 norm");
animaltypes.insert_last("hog");
animaltypes.insert_last("monster");
animaltypes.insert_last("giant");
gifts.insert_last("small_projectile");
gifts.insert_last("tasing_small_projectile");
gifts.insert_last("poisoned_small_projectile");
gifts.insert_last("item_grabber");
gifts.insert_last("enes-productions.tr.ht_pack");
gifts.insert_last("police_car_super");
gifts.insert_last("pack_of_50_cola");
gifts.insert_last("wood_pack");
gifts.insert_last("bike");
gifts.insert_last("pack_of_10000_dollar");
gifts.insert_last("dogan_slx");
gifts.insert_last("Truck");
gifts.insert_last("grenade_pack");
gifts.insert_last("antibiotic_pack");
gifts.insert_last("hand_grenade_pack");
gifts.insert_last("tk_shelter_pack");
gifts.insert_last("pack_of_3_guided_missile");
gifts.insert_last("helicopter");
gifts.insert_last("item_grabber");
gifts.insert_last("bitcoin_pack");
gifts.insert_last("antibiotic");
gifts.insert_last("invisibility_shield");
gifts.insert_last("timebomb");
gifts.insert_last("remote_gun");
gifts.insert_last("remote_timebomb");
gifts.insert_last("tk_ultra_health_potion");
add_snack_item("chips",20);
add_snack_item("apple",20);
add_snack_item("berry",20);
add_snack_item("biscuit",20);
add_snack_item("",20);
add_snack_item("candy",20);
add_snack_item("cola",20);
add_snack_item("cracker",20);
add_snack_item("juce_box",20);
add_snack_item("meat",20);
add_snack_item("melon",20);
add_snack_item("mint",20);
add_snack_item("nut",20);
add_snack_item("popcorn",20);
add_snack_item("pretzel",20);
add_snack_item("protein_bar",20);
add_snack_item("water_bottle",20);
add_snack_item("chocolate_bar",30);
add_snack_item("health_potion",1000);
add_snack_item("health_drink",100);
add_snack_item("banana_bread",50);
add_snack_item("food",100);
add_snack_item("syringe",100);
add_drink_item("raki_bottle",20);
add_drink_item("health_drink",150);
add_drink_item("beer_bottle",200);
spawn_jplayer(20, 20,2,"hotel");
spawn_jplayer(13, 20,0,"store");
if(!load_store_registers())
{
create_store(0, 0, 0, "store", "weapon_store");
create_store(0, 5, 0, "store", "ammo_store");
create_store(0, 10, 0, "store", "misc_store");
create_store(10, 20, 0, "store", "medical_store");
create_store(10, 10, 0, "store", "explosive_store");
create_store(20, 10, 0, "store", "vehicle_store");
}
if(!load_stores())
{
add_to_store("aircraft","An airborn vehicle with a high powered lazer and capable of very high speeds",500);
add_to_store("tank","A massive ground vehicle equipped with a very powerful cannon",400);
add_to_store("fuel_tank","A fuel tank for both the aircraft and tank",120);
add_to_store("wirebomb","A bomb with wires sticking out of them. Good for trapping!",300, "explosive_store");
add_to_store("carrier_missile","A missile that can send items and deploy them if possible",600);
add_to_store("mini_antibiotic_pack","A pack of 5 antibiotics",20, "medical_store");
add_to_store("antibiotic_pack","A normal pack of 20 antibiotics",120, "medical_store");
add_to_store("ultra_antibiotic_pack","A pack of antibiotics containing 50 antibiotics",800, "medical_store");
add_to_store("stun_dart","a throwing dart that will stun a player for five seconds if hit",10, "weapon_store");
add_to_store("timebomb","a bomb with a beeping timer on it.",15, "explosive_store");
add_to_store("remote_gun","a gun that can be placed and remote controlled from a distance, good for protection of a certain area.",30, "weapon_store");
add_to_store("mine","A bomb that activates if a player steps on it",75, "explosive_store");
add_to_store("remote_timebomb","a remote controlled timebomb that can be detinated from anywhere with a keystroke. Packs a decent range and damage, as well as a very short time pre explosion.",30, "explosive_store");
add_to_store("security_bomb","A bomb that detects players and vehicles and can inflict some serious damage. Good for shelter protection!",450, "explosive_store");
add_to_store("toolbox","A very useful item needed for repairing vehicles",1000);
add_to_store("guided_missile","A powerful missile that you can send after a player or to a set of coordinates",600, "weapon_store");
add_to_store("missile_interceptor","A device you can use to intercept incoming missiles",60, "weapon_store");
add_to_store("warp_box","a smart little device that will allow you to fly ahead an catch a running coward",90);
add_to_store("motion_bomb","A powerful bomb that detects motion",100, "explosive_store");
add_to_store("grenade_pack","a pack of 10 grenades",200, "explosive_store");
add_to_store("shield","a good layer of protection. Not fool proof though!",60);
add_to_store("wood_pack","A pack of wood for shelters",100);
add_to_store("metal_pack","a pack full of metal for vehicle repairs",150);
add_to_store("impact_bomb","a bomb that will explode if hit enough, great in chains!",75, "explosive_store");
add_to_store("ultrabomb","A very powerfull bomb that can be detenated with dollars. Packs lots of range",350, "explosive_store");
add_to_store("ultrabomb_silencer","a device used to remove the noticeable buzzing from an active ultrabomb",70);
add_to_store("team_member_booster","These devices will open 1 slot for a member in your team",5000);
}
if(!load_sell())
{
sellitems.set("aircraft",500);
sellitems.set("tank",400);
sellitems.set("fuel_tank",120);
sellitems.set("antibiotic",5);
sellitems.set("wirebomb",150);
sellitems.set("carrier_missile",300);
sellitems.set("mini_antibiotic_pack",20);
sellitems.set("antibiotic_pack",120);
sellitems.set("ultra_antibiotic_pack",800);
sellitems.set("stun_dart",10);
sellitems.set("timebomb",15);
sellitems.set("remote_gun",30);
sellitems.set("mine",75);
sellitems.set("remote_timebomb",25);
sellitems.set("security_bomb",450);
sellitems.set("toolbox",1000);
sellitems.set("guided_missile",600);
sellitems.set("missile_interceptor",60);
sellitems.set("motion_bomb",100);
sellitems.set("grenade",20);
sellitems.set("grenade_pack",200);
sellitems.set("impact_bomb",75);
sellitems.set("ultrabomb",350);
sellitems.set("ultrabomb_silencer",70);
sellitems.set("ultrabomb_locator",20);
sellitems.set("shield",1500);
sellitems.set("metal_pack",150);
sellitems.set("metal",5);
sellitems.set("wood_pack",100);
sellitems.set("wood",2);
sellitems.set("fire_extinguisher",40);
sellitems.set("invisibility_shield",90);
}
string[] temparray=sellitems.get_keys();
temparray.sort_ascending();
for(uint i=0; i<temparray.length; i++)
{
int tempkey;
sellitems.get(temparray[i],tempkey);
tempkey=round(tempkey*0.75,0);
sellsend+=temparray[i]+" for "+tempkey+" dollars a piece:"+temparray[i]+"[]";
}
sellsend=string_trim_right(sellsend,2);
}

void add_achievement(string achievement, int index,string reward="",bool public=false)
{
bool stuff=false;
stuff=players[index].a.add(achievement);
if (stuff==true)
{
send_reliable(players[index].peer_id,"play_s achievement.ogg",0);
if(reward=="")
send_reliable(players[index].peer_id,"New achievement! "+achievement,2);
else
send_reliable(players[index].peer_id,"New achievement! "+achievement+". Reward: "+reward,2);
if(public==true)
{
send_plus(players[index].peer_id,"play_s achievement_complete.ogg",0);
send_plus(players[index].peer_id,"alert: "+players[index].name+" completed the achievement "+achievement+"!",2);
}
if(reward!="")
{
string[] rw=string_split(reward," ",true);
players[index].give(rw[1],stn(rw[0]));
}
}
}
bool hasammo(string w)
{
if(guns.find(w)>-1)
return true;
return false;
}
void loops()
{
netloop();
shipmentloop();
playerloop();
weaponloop();
treeloop();
tempbanloop();
lockerloop();
timeloop();
gameeventloop();
weaponloop();
canisterloop();
jplayerloop();
vendingloop();
maploop();
objloop();
horbloop();
sbombloop();
rocketloop();
stun_grenadeloop();
mass_bombloop();
concussive_grenadeloop();
ultrabombloop();
robotsloop();
impactbombloop();
suicide_bombloop();
shotgunloop();
revolverloop();
bazookaloop();
bottle_bombloop();
sound_grenadeloop();
nuclear_bombloop();
timeitemloop();
rpgloop();
cannonballloop();
timebombloop();
grenadeloop();
weaponloop();
mineloop();
poison_daggerloop();
hand_grenadeloop();
pipe_bombloop();
wirebombloop();
stp429loop();
cmloop();
missileloop();
fireloop();
motionbombloop();
remgunloop();
timepacketloop();
bodyfallloop();
giftloop();
remote_timebombloop();
shelterloop();
weaponloop();
sat_bombloop();
teamloop();
extrafuncs();
vloop();
helicopterloop();
bbombloop();
pprojectileloop();
tprojectileloop();
projectileloop();
bulletbombloop();
storeloop();
}
//this function will make it a lot easier for me to make the new store system!
void print_store()
{
string printout;
for(uint i=0; i<stores.length(); i++)
{
for(int i2=0; i2<stores[i].item_names.length(); i2++)
{
printout+=stores[i].item_names[i2]+"="+stores[i].prices[i2]+"="+stores[i].descriptions[i2]+"="+stores[i].name+"\r\n";
}
}
fl.open("prefs/store.svr","wb");
fl.write(printout);
fl.close();
printout="";
string[] k=sellitems.get_keys();
for(uint i=0; i<k.length; i++)
{
int val;
sellitems.get(k[i],val);
printout+=k[i]+"="+val+"\r\n";
}
fl.open("prefs/sell.svr","wb");
fl.write(printout);
fl.close();
}
string url_ret(string url, string data="")
{
string what;
if(data=="") what=httpn.get(url);
else what=httpn.post(url,data);
while(httpn.progress)
{
what+=httpn.request();
if(get_last_error()<0) return get_last_error_text();
netloop();
}
return what;
}
string[] delete_array_item(string[] array,string value)
{
string inv=linear(array);
string itemname=value;
string[] peramitors=array;
string[] values;
string srt;
for(uint i=0; i<peramitors.length(); i++)
{
values.insert_at(i,string_replace(peramitors[i], string_left(peramitors[i], string_contains(peramitors[i], "=", 1)+1), "", true));
peramitors[i]=string_replace(peramitors[i], "="+values[i], "", true);
}
for(uint i=0; i<peramitors.length(); i++)
{
if(peramitors[i]==itemname)
{
inv=string_replace(inv, itemname+"="+values[i]+"\r\n", "", false);
}
}
return delinear(inv);
}
string keycheck(string activation_key)
{
string ret="";
string keys=url_ret("http://enes-productions.tr.ht/tk/activation_payments.plist");
if(keys=="")
{
return "";
}
string[] k=string_split(keys,"\r\n",false);
for(uint i=0; i<k.length(); i++)
{
string[] p=string_split(k[i],"=",false);
if(p.length>1 and p[0]==activation_key)
{
ret =p[1];
keys=linear(delete_array_item(delinear(keys),activation_key));
url_ret("http://enes-productions.tr.ht/tk/keywrite.php","password=item33&value="+keys);
}
}
return ret;
}
void send_plus(uint excluding_peer_id, string packet, int channel)
{
for(uint i=0; i<players.length(); i++)
{
if(excluding_peer_id!=players[i].peer_id)
{
send_reliable(players[i].peer_id,packet,channel);
}
}
}

void playmap(string sound,string map)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].map==map)
send_reliable(players[i].peer_id,"play_s "+sound+".ogg",0);
}
}
void sendmap(string packet,string map,int channel=0,bool reliable=true)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].map==map)
{
if(reliable) send_reliable(players[i].peer_id,packet,channel);
else send_unreliable(players[i].peer_id,packet,channel);
}
}
}
bool int_to_bool(int i)
{
if(i==1)
return true;
return false;
}
int bool_to_int(bool b)
{
if(b==true)
return 1;
return 0;
}
string localgrab_url(string filename)
{
return file_get_contents("../../var/www/html/"+filename);
}

bool automatic(string w)
{
string[] aut={"FRNTAssaultRifle","ml_Automatic_machinegun","machinegun","famas","m2browning","mp5_machine_pistol","strong_machinegun","beretta_m1951_machine_pistol","blz83_portable_machine_gun","browning_high_power_bda_handgun","browning_m2_heavy_50_cal_machinegun","m4a1_assault_rifle","m16_assault_rifle","m134_minigun","modern_sub_machine_gun_carbine","nunchaku","sky_372_laser_machinegun","stp_s84q_automatic_suppressed_pistol","str_301_long_barreled_machine_pistol","ak47_assault_rifle","m4","m8a7","m16","m1891","m1921a1","ml7tinymg"};
if(aut.find(w)>-1)
return true;
return false;
}
string get_store_hint(int x, int y, int z, string map,bool &out direction)
{
if(map!="main"&&map!="store")
{
direction=false;
return "You are not on the same map";
}
else if(map=="store")
{
direction=false;
return "you are already inside";
}
int dist=get_3d_distance(storex,storey,storez,x,y,z);
if(dist<=0)
{
direction=false;
return "You are standing on the store's tile";
}
if(dist>0 and dist<=30)
return "Close enough to here it";
if(dist>30 and dist<=75)
return "You are really close";
if(dist>75 and dist<=150)
return "You are kind of close";
if(dist>150 and dist<=250)
return "You are far away";
if(dist>250 and dist<=350)
return "You are very far away";
else
return "You are extremely far away";
}
bool write_to_webfile(string filename,string content)
{
return file_put_contents("../../var/www/html/"+filename,content,250);
}
void admintell(string msg)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].modable())
{
send_reliable(players[i].peer_id,"admintell "+msg,1);
}
}
}
void devtell(string msg)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].masterable())
{
send_reliable(players[i].peer_id,"play_s favor.ogg",0);
send_reliable(players[i].peer_id,"devtell "+msg,1);
}
}
}
void admintalk(string msg) {
for(uint i=0; i<players.length(); i++)
{
if(players[i].adminable())
{
send_reliable(players[i].peer_id,"play_s chat.ogg",0);
send_reliable(players[i].peer_id,"admintell "+msg,1);
}
}
}
void timeloop()
{
if(timetimer.elapsed > timetime)
{
timetimer.restart();
minute++;
foodcheck();
}
if(minute>59)
{
minute=0;
hour++;
checktime();
alerttime();
foodcheck();
}
if(hour>23)
{
hour=0;
minute=0;
day+=1;
if (day>31)
{
day=1;
month+=1;
if (month>12)
{
month=1;
year+=1;
}
}
}
}
void foodcheck()
{
/*
if (hour==6 and minute==30)
{
send_reliable(0,"play_s notify2.ogg",0);
send_reliable(0,"Food alert: Breakfast will give to you in 30 minutes!",2);
}
if (hour==7 and minute==0)
{
string chocolate;
string what=chocolate;
send_reliable(0,"play_s objget.ogg",0);
send_reliable(0,"Food alert: Breakfast was gave to you! It was "+what,2);
for(uint i=0; i<players.length(); i++)
{
players[i].give("chocolate","+random(1,5)");
}
}
if (hour==12 and minute==10)
{
send_reliable(0,"play_s notify2.ogg",0);
send_reliable(0,"Food alert: Lunch will be give to you in 50 minutes!",2);
}
if (hour==13 and minute==0)
{
string dead_rabit;
string what=dead_rabit;
send_reliable(0,"play_s objget.ogg",0);
send_reliable(0,"Food alert: Lunch was gave to you! It was "+what,2);
for(uint i=0; i<players.length(); i++)
{
players[i].give("dead_rabit","+random(1,1)");
}
}
if (hour==19 and minute==30)
{
send_reliable(0,"play_s notify2.ogg",0);
send_reliable(0,"Food alert: Dinner will be give to you in 1 hours and 30 minutes!",2);
}
if (hour==21 and minute==0)
{
string dead_goat;
string what=dead_goat;
send_reliable(0,"play_s objget.ogg",0);
send_reliable(0,"Food alert: Dinner was gave to you! It was "+what,2);
for(uint i=0; i<players.length(); i++)
{
players[i].give("dead_goat","+random(1,1)");
}
}
*/
}
void checktime()
{
if (hour==6 and minute==0)
{
send_reliable(0,"play_s notify_magicbell.ogg",0);
send_reliable(0,"The sun is rising from the back of the mountain, since it is 6 o'clock in the morning",2);
}
if (hour==5 and minute==0)
{
send_reliable(0,"play_s notify.ogg",0);
send_reliable(0,"the day is starting!",2);
}
if (hour==1 and minute==0)
{
send_reliable(0,"play_s notify_dingdong.ogg",0);
send_reliable(0,"it's night, the time is 1 o clock!",2);
}
if (hour==12 and minute==0)
{
send_reliable(0,"play_s notify_trumpet.ogg",0);
send_reliable(0,"The sun has reached the middle of the sky, indicating that it is noon!",2);
}
if (hour==18 and minute==0)
{
send_reliable(0,"play_s notify_woosh.ogg",0);
send_reliable(0,"The sun is drowning. Yes! time is 6 pm!",2);
}
if (hour==23 and minute==59)
{
send_reliable(0,"play_s notify_news2.ogg",0);
send_reliable(0,"It's midnight, and a new day begins",2);
}
}
void alerttime()
{
if (hour==15 and minute==0)
{
send_reliable(0,"play_s notifyalert.ogg",0);
send_reliable(0,"enes-productions.tr.ht",2);
}
if (hour==1 and minute==0)
{
send_reliable(0,"play_s notifybleeps.ogg",0);
send_reliable(0,"please donate me paypal! paypal.me/enesozcaniskol2005",2);
}
}
string email(string address,string from,string subject,string message)
{
string n="tk server"; //change name if other game!
return url_post("http://enes-productions.tr.ht/mail.php","who="+address+"&name="+n+"&from="+from+"&sub="+subject+"&mess="+message);
}
double get_best_number_from(double[] numbers)
{
int temp=0;
for(uint i=0; i<numbers.length(); i++)
{
if(temp==0) temp=numbers[i];
else
{
if(numbers[i]>temp) temp=numbers[i];
}
}
return temp;
}
double  get_closest_value(double num, int[] arr) {
double diff=0;
double result;
for(uint i=0; i<arr.length(); i++) {
int d=absolute(num-arr[i]);
if(d<diff || diff==0) {
diff=d;
result=arr[i];
}
}
return result;
}
//this function starts the guess the number game, resetting all values.
void gnstart() {
guessthenumber_guesses.resize(0);
guessthenumber_minutes=0;
guessthenumbertimer.restart();
gntarget=random(1,50);
guessthenumber_active=1;
}
string gettime()
{
int newhour;
string newminute;
string ampm;
if (hour<=12 and hour>0)
{
newhour=hour;
ampm="AM";
}
else if (hour==0)
{
newhour=12;
ampm="AM";
}
else
{
ampm="PM";
newhour=hour-12;
}
if (minute<10)
newminute="0"+minute;
else
newminute=minute;
return newhour+":"+newminute+" "+ampm+", "+convert_month(month)+" "+day+", "+year;
}
string get_script_path()
{
string scriptpath;
if(SCRIPT_COMPILED==false)
{
scriptpath=SCRIPT_CURRENT_FILE;
}
else
{
scriptpath=SCRIPT_EXECUTABLE;
}
return scriptpath;
}
string convert_to_list(string[] arr)
{
string list;
if(arr.length()==0) return "";
if(arr.length()==1) return arr[0];
for(uint i=0; i<arr.length(); i++)
{
if(i==arr.length()-1)
list+=" and "+arr[i];
else
list+=arr[i]+", ";
}
return list;
}
string convert_to_list(int[] arr)
{
string list;
if(arr.length()==0) return "";
if(arr.length()==1) return arr[0];
for(uint i=0; i<arr.length(); i++)
{
if(i==arr.length()-1)
list+=" and "+arr[i];
else
list+=arr[i]+", ";
}
return list;
}
bool dm(string username,string mess)
{
return run("dm.exe","--username "+username+" --message \""+mess+"\"",true,true);
}
double calculate_movetime_per_tile(int ms,int tiles_to_move)
{
return (ms/tiles_to_move);
}

int[] get_amounts()
{
int[] a;
for(int i=0; i<stores.length(); i++)
{
for(int i2=0; i2<stores[i].prices.length(); i2++)
{
a.insert_last(stores[i].prices[i2]);
}
}
return a;
}

bool load_stores()
{
string sdata;
bool s=fl.open("prefs/store.svr", "rb");
if(!s) return false;
sdata=fl.read();
fl.close();
string[] items=string_split(sdata, "\r\n", false);
if(items.length<=1) return false;
for(int i=0; i<items.length(); i++)
{
string[] parsed=string_split(items[i], "=", true);
if(parsed.length>=4) add_to_store(parsed[0], parsed[2], stn(parsed[1]), parsed[3]);
}
return true;
}
bool load_sell()
{
bool s=fl.open("prefs/sell.svr","rb");
if(!s) return false;
string[] data=string_split(fl.read(),"\r\n",false);
fl.close();
if(data.length<=1) return false;
for(uint i=0; i<data.length; i++)
{
string[] parsed=string_split(data[i],"=",false);
if(parsed.length==2)
{
int val=stn(parsed[1]);
sellitems.set(parsed[0],val);
}
}
return true;
}
bool load_store_registers()
{
file f;
if(!f.open("prefs/store_registers.svr", "rb")) return false;
string stuff=f.read();
f.close();
string[] store_registers=string_split(stuff, "\r\n", false);
if(store_registers.length<1) return false;
for(int i=0; i<store_registers.length(); i++)
{
string[] parsed=string_split(store_registers[i], "=", false);
create_store(stn(parsed[1]), stn(parsed[2]), stn(parsed[3]), parsed[4], parsed[0]);
}
return true;
}
void save_store_registers()
{
file f;
f.open("prefs/store_registers.svr", "wb");
string final;
for(int i=0; i<stores.length(); i++)
{
final+=stores[i].name+"="+stores[i].x+"="+stores[i].y+"="+stores[i].z+"="+stores[i].map+"\r\n";
}
f.write(final);
f.close();
}
void storeloop() {
if(storemovestage==0&&storemovetimer.elapsed>=storemovetime) {
storemovestage=1;
storemovetimer.restart();
play("store_porting",storex,storey,storez,"main");
playmap("store_porting_int","store");
storemoving=true;
}
else if(storemovestage==1&&storemovetimer.elapsed>=3600) {
storemovetimer.restart();
destroy_source(115111);
play("store_port",storex,storey,storez,"main");
for(uint i=0; i<players.length; i++) {
if(players[i].map!="store") send_reliable(players[i].peer_id,"distsound store_portdist "+storex+" "+storey+" "+storez+" main",0);
}
playmap("store_port_int","store");
storemovestage=2;
}
else if(storemovestage==2&&storemovetimer.elapsed>=4000) {
storemove();
destroy_source(115105);
play("store_spawn",storex,storey,storez,"main");
for(uint i=0; i<players.length; i++) {
if(players[i].map!="store") send_reliable(players[i].peer_id,"distsound store_spawndist "+storex+" "+storey+" "+storez+" main",0);
}
playmap("store_spawn_int","store");
storespawn();
storemovestage=0;
storemoving=false;
storemovetimer.restart();
}
}
void storemove() {
if(fstorecoords) {storex=fstorex;storey=fstorey;storez=fstorez;}
else {
int x,y,z;
string tile;
vector max=get_max_values("main");
do
{
x=random(0,max.x);
y=random(0,max.y);
z=0;
tile=get_tile_at(x,y,z,"main");
}
while(tile==""||string_left(tile,4)=="wall");
storex=x;storey=y;storez=z;
}
fstorex=-1;fstorey=-1;fstorez=-1;fstorecoords=false;
}
void storespawn() {
spawn_source(storex,storex,storey,storey,storez,storez,"shelter_generator.ogg","main",0,1);
}