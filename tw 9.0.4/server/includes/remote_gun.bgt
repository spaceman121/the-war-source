remgun@[]remguns(0);
class remgun {
bool can_fire=false;
double x,y,z;
string hitby="no one";
int lifetime=300000;
int mindammage=300000;
int maxdammage=700000;
int health=5000000;
int id=random(1,19999);
timer usetimer;
timer lifetimer;
int usetime=1000;
int shotsfired=0;
string map;
string owner;
int dir=0;
remgun(double bx, double by, double bz, string bmap, string bowner)
{
x=bx;
y=by;
z=bz;
map=bmap;
owner=bowner;
}
void command(string cmd,int peer)
{
int index=get_player_index(e.peer_id);
if(index<0) return;
players[index].playsound("remgun_keypress");
string packet;
if(cmd=="[cncel]")
{
players[index].sendpacket("Remote gun disconnected",0);
players[index].remgunid=-1;
players[index].playsound("remgun_disconnect");
return;
}
else if(cmd=="f")
{
packet="fire!";
can_fire=true;
}
else if(cmd=="s")
{
health=-1;
hitby="internal:rg:destruct";
int index=get_player_index_from(owner);
players[index].remgunid=-1;
send_reliable(peer,"speak self destruct!",0);
}
else if(cmd=="h")
{
packet="Press F to fire this remgun. Press H to access this message. Press i to access information. Press P for a scan of players and hittable objects. Press S to overload the remote gun's batteries and explode";
}
else if(cmd=="i")
{
packet="Information for remgun "+id+": Owner "+owner+". This remgun has been fired "+shotsfired+" times, and has "+ms_to_readable_time(lifetime-lifetimer.elapsed)+" of uptime remaining. It is located on "+map+" at "+x+", "+y+", "+z+", and has "+health+" health left";
}
else if(cmd=="p")
{
string s;
for (uint i=0; i<players.length(); i++)
{
if(players[i].is_dead==true||in_vehicle(players[i].name)>-1||players[i].invinsible) continue;
if (players[i].x<this.x+20 and players[i].x>this.x-20 and players[i].y<this.y+20 and players[i].y>this.y-20 and get_1d_distance(this.z,players[i].z)<=20 and players[i].map==this.map and players[i].invisible==false)
{
int level=1;
if(players[i].z>this.z)
{
level=2;
}
else if(players[i].z<this.z)
{
level=0;
}
else
{
level=1;
}
if(players[i].shielded==true)
s+="shielded ";
if(players[i].teamname!="") s+=players[i].teamname+" ";
s+=players[i].nickname+" is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(this.x, this.y, players[i].x, players[i].y, 0))+", "+get_3d_distance(this.x, this.y, this.z, players[i].x, players[i].y, players[i].z)+" feet away. ";
}
}
for(uint i=0; i<vs.length; i++)
{
if(get_3d_distance(this.x,this.y,this.z,vs[i].x,vs[i].y,vs[i].z)<=30&&vs[i].map==this.map)
{
int level=1;
if(vs[i].z>this.z) level=2;
if(vs[i].z<this.z) level=0;
s+=cn2n(vs[i].owner)+"'s "+vs[i].type+" is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(this.x, this.y, vs[i].x, vs[i].y, 0))+", "+get_3d_distance(this.x, this.y, this.z, vs[i].x, vs[i].y, vs[i].z)+" feet away. ";
}
}
if(s=="")
s="nothing around";
packet=s;
}
else
{
packet="Invalid command";
}
if(packet!="")
send_serverbox(peer,0,-1,1,1,"remguncommand",packet);
}
void firegun()
{
bool hit=false;
for(uint x=0; x<players.length(); x++)
{
if(get_3d_distance(x, y, z, players[x].x, players[x].y, players[x].z)<=15 and owner!=players[x].name and players[x].map==map and players[x].invinsible==false and players[x].is_dead==false and in_vehicle(players[x].name)<0 and !are_teamed(owner,players[x].name))
{
int index=get_player_index_from(owner);
if(index>-1)
{
hit=true;
players[x].hit(mindammage,maxdammage);
players[x].should_subtract=false;
players[x].hitby=owner+"'s remote gun"+id;
send_reliable(players[index].peer_id,"play_s weaponping.ogg",0);
}
}
for(uint x=0; x<vs.length; x++)
{
if(are_teamed(owner,vs[x].owner)) continue;
if(get_2d_distance(vs[x].x,vs[x].y,x,y)<=15&&get_1d_distance(z,vs[x].z)<=15&&vs[x].map==map&&vs[x].owner!=owner)
{
vs[x].hit(random(mindammage, maxdammage),owner+"'s remote gun"+id);
playint("weaponping",owner);
}
}
for(uint x=0; x<impact_bombs.length(); x++)
{
if(get_3d_distance(x,y,z,impact_bombs[x].x,impact_bombs[x].y,impact_bombs[x].z)<=20 and map==impact_bombs[x].map)
{
play("ibombhit"+random(1,3),impact_bombs[x].x,impact_bombs[x].y,impact_bombs[x].z,impact_bombs[x].map);
impact_bombs[x].health-=random(mindammage,maxdammage);
}
}
}
}
}
void remgunloop()
{
for(uint j=0; j<remguns.length(); j++)
{
if(remguns[j].lifetimer.elapsed>remguns[j].lifetime or remguns[j].shotsfired>=50)
{
int index=get_player_index_from(remguns[j].owner);
if(index>-1) send_reliable(players[index].peer_id,"play_s remgun_disconnect.ogg",0);
remguns[j].health=-1;
remguns[j].hitby="internal:rg:expire";
}
if(remguns[j].health<=0)
{
play("remgun_death",remguns[j].x,remguns[j].y,remguns[j].z,remguns[j].map);
send_reliable(0,"playerdeath "+killmsg(remguns[j].owner+"'s remote gun "+remguns[j].id,remguns[j].hitby,remguns[j].map),0);
int index=get_player_index_from(remguns[j].owner);
if(index>-1) send_reliable(players[index].peer_id,"play_s remgun_disconnect.ogg",0);
remguns.remove_at(j);
continue;
}
if(remguns[j].usetimer.elapsed>=remguns[j].usetime and remguns[j].can_fire==true)
{
play("remgun_fire",remguns[j].x,remguns[j].y,remguns[j].z,remguns[j].map);
if(remguns[j].lifetimer.elapsed>30000) remguns[j].lifetimer.force((remguns[j].lifetimer.elapsed-30000));
send_reliable(0,"distsound remgun_firedist "+remguns[j].x+" "+remguns[j].y+" "+remguns[j].z+" "+remguns[j].map,0);
remguns[j].can_fire=false;
remguns[j].shotsfired++;
remguns[j].usetimer.restart();
bool hit=false;
for(uint x=0; x<players.length(); x++)
{
if(get_3d_distance(remguns[j].x, remguns[j].y, remguns[j].z, players[x].x, players[x].y, players[x].z)<=15 and remguns[j].owner!=players[x].name and players[x].map==remguns[j].map and players[x].invinsible==false and players[x].is_dead==false and in_vehicle(players[x].name)<0 and !are_teamed(remguns[j].owner,players[x].name))
{
int index=get_player_index_from(remguns[j].owner);
if(index>-1)
{
hit=true;
play("hit"+random(1,3),players[x].x,players[x].y,players[x].z,players[x].map);
players[x].health-=random(remguns[j].mindammage, remguns[j].maxdammage);
players[x].should_subtract=false;
players[x].hitby=remguns[j].owner+"'s remote gun"+remguns[j].id;
send_reliable(players[index].peer_id,"play_s weaponping.ogg",0);
}
}
for(uint x=0; x<vs.length; x++)
{
if(are_teamed(remguns[j].owner,vs[x].owner)) continue;
if(get_2d_distance(vs[x].x,vs[x].y,remguns[j].x,remguns[j].y)<=15&&get_1d_distance(remguns[j].z,vs[x].z)<=15&&vs[x].map==remguns[j].map&&vs[x].owner!=remguns[j].owner)
{
vs[x].hit(random(remguns[j].mindammage, remguns[j].maxdammage),remguns[j].owner+"'s remote gun"+remguns[j].id);
playint("weaponping",remguns[j].owner);
}
}
for(uint x=0; x<impact_bombs.length(); x++)
{
if(get_3d_distance(remguns[j].x,remguns[j].y,remguns[j].z,impact_bombs[x].x,impact_bombs[x].y,impact_bombs[x].z)<=20 and remguns[j].map==impact_bombs[x].map)
{
play("ibombhit"+random(1,3),impact_bombs[x].x,impact_bombs[x].y,impact_bombs[x].z,impact_bombs[x].map);
impact_bombs[x].health-=random(remguns[j].mindammage,remguns[j].maxdammage);
}
}
}
}
}
if(tremguns.length>0)
{
for(uint i=0; i<tremguns.length; i++)
{
if(tremguns[i].placetime.elapsed>=6343) tremguns.remove_at(i);
}
}
}
int remgun_index(int id)
{
for(uint i=0; i<remguns.length(); i++)
{
if(remguns[i].id==id) return i;
}
return -1;
}
void placeremgun(double x, double y, double z,  string map, string owner)
{
remgun r1(x, y, z,   map, owner);
remguns.insert_last(r1);
}
bool remgun_at(int x, int y, int z, string map)
{
for(uint i=0; i<remguns.length; i++)
{
if(remguns[i].x==x&&remguns[i].y==y&&remguns[i].z==z&&remguns[i].map==map)
return true;
}
return false;
}
class timeremgun
{
int x,y,z;
string map,owner;
timer placetime;
timeremgun(int x,int y,int z,string map,string owner)
{
this.x=x;this.y=y;this.z=z;this.map=map;this.owner=owner;
play("remgun_place",x,y,z,map);
}
~timeremgun()
{
placeremgun(x,y,z,map,owner);
}
}
timeremgun@[] tremguns;
void placetimeremgun(int x, int y, int z, string map, string owner)
{
timeremgun t1(x,y,z,map,owner);
tremguns.insert_last(t1);
}