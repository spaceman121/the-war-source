#include"includes.bgt"
ip_locale l;
bool varified=false;
bool fireon;
int storex=50,storey=50,storez=50,fstorex=-1,fstorey=-1,fstorez=-1;
string storesound;
int packetlogging=2; //only turn this on if you want chan_0 to be logged with player.
string[] biketiles={"dirt","grass","gravel","metal","mud","rock","water","weed","wood"};
timer fighttimer;
int fighttime;
int fighiters=0;
timer arenatimer;
timer animaltimer;
timer storemovetimer;
timer maptimer;
int currentlyonline;
int writeprefs=1;
int chatting=0;
int serverchats=0,serversteps=0,serverkillr=0,servercommands=0,serverbans=0,serverkicks=0,servershots=0,serverlogins=0;
int double_xp=0;
int custom_xp=0;
int login_disabled=0;
int disable_account_creation=0;
int speaktime=1;
int guessthenumber_active=0;
double gntarget=random(1,2);
int[] guessthenumber_guesses;
int guessthenumber_minutes=5;
string adminlog;
string guessthenumber_winner;
timer guessthenumbertimer, gnstarttimer;
int gnstart_auto=1;
int storemovestage=0;
int redwins, bluewins;
bool redflag=true, blueflag=true;
bool opend=false;
bool fighting=false;
bool fightstarted=false;
bool storemoving=false,fstorecoords=false;
uint storemovetime=10*60000;
int storeopened=1;
int objtime=800;
int maxobjs=500;
bool gamestopped=false;
bool gamestarted=false;
bool notify=false,public_uploading=false;
bool netsetup;
int filterstuff=1;
bool spawnobj=true;
double voteyes=0,voteno=0;
double minversion=9.4;
string[] newbitems={"antibiotic","antibiotic_pack","mini_antibiotic_pack","antibiotic_pack","tk_ultra_health_potion","health_drink"};
string minverstring="9.0.3";
timer garbagetimer;
timer objectspawntimer;
timer gifttimer;
timer versiontimer;
int connections=0, disconnections=0;
int gifting=1;
int fakeadmining=0;
int objgrabs=0, objspawns=0;
int can_upload_files=1;
int objspawntime=1200;
bool beta=false;
bool spawnai=false;
int cid=-1;
int port=15309;
int activations=0;
int peak;
int gender;
int pmreceiving;
int super;
string[] animaltypes;
string peakreached;
network n;
network_event e;
double file_size_limit_kb=2000;
string[] guns={"crossbow","ML7TinyMG","mk48","s&w_model66_revolver","famas","cannon","FRNTAssaultRifle","barrett_m82_sniper_rifle","cannon","mp5_machine_pistol","dragunovp_sniper","s&w_model66_revolver","mlk_203_combat_pistol","barrett_m82_sniper_rifle","stp106_long_barreled_pistol","m2browning","strong_machinegun","ml_Automatic_machinegun","m29_sniper_rifle","shotgun","ak47_assault_rifle","beretta_m9_pistol","beretta_m1951_machine_pistol","beretta_nano_pocket_pistol","blz83_portable_machine_gun","browning_high_power_bda_handgun","browning_m2_heavy_50_cal_machinegun","colt_ar_15_assault_rifle","colt_python_revolver","cop_357_derringer_pistol","crt43_automatic_shotgun","glock_17_pistol","m4a1_assault_rifle","m16_assault_rifle","m24_sniper_rifle","m134_minigun","m1208_shotgun","mlk_207_combat_rifle","modern_sub_machine_gun_carbine","nak_nk1000_decimater","ruger_security_6_revolver","saiga_12_5_round_shotgun","sig_p226_combat_pistol","sky_28_laser","sky_127_laser_handgun","stp_s84q_automatic_suppressed_pistol","stp21_handgun","str_32_pump_action_shotgun","poison_dagger","str_301_long_barreled_machine_pistol","walther_p99_handgun","glock","sks","m4","m8a7","m16","m1891","m1921a1","glock","pistol","mp5","sniper","rpg7","rocketlauncher","bazooka","revolver","svd","kalashnikov_rifle","grenade_launcher","taser","dart_launcher","taser","ML420HuntingRifle","mossberg500","ml7tinymg","Storm_Sniper","stp","ak47"};
timer uptimer, accumulated_uptimer;
timer announcertimer;
timer timetimer;
timer savetimer;
int eattime=10000;
timer eattimer;
int hour=0, minute=1, day=1, month=1, year=2000;
int timetime=1500;
savedata sd("prefs/server_state.dat","server_data");
string[] killmsgs;
string[] gifts;
string[] store_items;
string[] descriptions;
int[] amounts;
int auctiontime=30000;
string auctionwho,auctionwho2,auctionwhotemp;
bool auctionbidder;
bool auction;
string auctionitem;
int auctionamount;
int auctionbid,auctionbidtemp;
timer sheltersavetimer;
timer updatingtimer, auctiontimer;
bool updatingsvr=false,updatevstopped=false,updatevkilled=false,updatenotified=false,updatergkilled=false;
dictionary passresets;
prowl p("5d011dcc3e145e88bc4969e032760bc53bd5d496");
file fl;
dictionary sellitems;
string sellsend;
int missiletime=4000, missilemax=5,subtract=1,storefight=0,geo=0;
bool admingun=true;
http httpn;
bool svrmon=true;
void main()
{
if(file_exists("file.dll")==false)
{
alert("error","There are missing files. Please paste file.dll into the server");
exit();
}
filelib.load("file.dll");
httpn.user_agent="tksvr"+version;
weapons.reserve(200);
players.reserve(20);
start_profiling();
loaddata();
setupserver();
if(file_exists("server.bgt")) show_game_window("MD Games Production, The War server v"+version+" running on port "+port);
if(file_exists("server_b.bgt") and beta) show_game_window("tk server v "+version+" beta");
//versioncheck();
//validate_server();
load_compids();
load_all_teams();
spawn_player(50,50,3,"admin_room","Samantha",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
string[] stuff=find_files("shelters/*.shelter");
if(stuff.length>0)
for(uint i=0; i<stuff.length(); i++)
{
load_shelter(string_replace(stuff[i],".shelter","",false));
}
load_bombs();
if(file_exists("prefs/motd.svr")==false)
{
file mfile;
mfile.open("prefs/motd.svr","wb");
mfile.write("hi, and welcome to The War");
mfile.close();
}
if(file_exists("maps/.map"))
file_delete("maps/.map");
if(file_exists("shelters/.shelter"))
file_delete("shelters/.shelter");
if(beta==true)
{
netsetup=n.setup_server(19932, 20, 500);
}
else
netsetup=n.setup_server(port, 20, 500);
if(netsetup==false)
file_put_contents("Errors.log","error in starting server. "+get_last_error()+"\r\n",255);
init_mapsystem();
if(beta==true)
{
speak("beta server active");
}
else
speak("The War Server active");
log("svr","The War server started.");
file f;
f.open("prefs/death_messages.svr","rb");
string[] lines=string_split(f.read(),"\r\n",false);
f.close();
for(uint i=0; i<lines.length(); i++)
{
killmsgs.insert_last(lines[i]);
}
if(file_exists("real_offline.txt")) file_delete("real_offline.txt");
//storemove();
//storespawn();
while(true)
{
wait(5);
loops();
//Lets save our data.
//I will hate myself for writing such messy code in the main fucking while loop, but oh well. Shit happens.
if(guessthenumber_active==1)
{
if(guessthenumbertimer.elapsed>60000)
{
guessthenumbertimer.restart();
guessthenumber_minutes++;
}
if(guessthenumber_minutes>1||get_paid_online().length<=guessthenumber_guesses.length)
{
guessthenumber_active=0;
send_reliable(0,"play_s gnfinished.ogg",0);
int windex=get_gnwinner();
int bestnum=get_closest_value(gntarget,guessthenumber_guesses);
string result;
if(windex>-1)
result=players[windex].name+" is the winner! And he is got 500000 dollars as his reward! congratulations!";
else
result="There was no winner in this game";
result+="\r\nThe best number entered was "+bestnum+" and the number was "+gntarget+". Numbers entered were: "+convert_to_list(guessthenumber_guesses);
send_reliable(0,result,2);
if(windex>-1)
players[windex].give("dollar",500000);
for(uint i=0; i<players.length(); i++)
{
players[i].gnplaying=0;
file_delete("chars/"+players[i].name+"/gn.usr");
}
}
}
if(gnstarttimer.elapsed>6000*10)
{
gnstarttimer.restart();
if(guessthenumber_active==0 and gnstart_auto==0 and get_paid_online().length>=1)
{
send_reliable(0,"The guess the number minigame has started. Everyone has 5 minutes to enter a number in to the box. Press shift g to submit your guess, number less than 1 and number higher than 50. The cloesest person to the number gets 500000 dollars. Go!",2);
send_reliable(0, "play_s gnstart.ogg", 0);
gnstart();
}
}
if(players.length()!=currentlyonline&&svrmon==true)
{
currentlyonline=players.length();
string stuffage="There are ";
if(players.length()<=0)
{
stuffage+="currently no connected players on the server";
write_to_webfile("tk/playerlist.db",stuffage);
}
else
{
stuffage+="currently "+players.length()+" players online. They are: ";
for(uint i=0; i<players.length(); i++)
{
netloop();
if(i==players.length()-1)
stuffage+="and "+players[i].name+" with "+players[i].kills+" kills and "+players[i].deaths+" deaths.";
else
stuffage+=players[i].name+" with "+players[i].kills+" kills and "+players[i].deaths+" deaths, ";
}
write_to_webfile("tk/playerlist.db",stuffage);
}
}
if(savetimer.elapsed>=45000 and writeprefs==1)
{
savetimer.restart();
for(uint i=0; i<players.length; i++)
{
scd(i);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_shipments();
}
if(garbagetimer.elapsed>=25000)
{
garbagetimer.restart();
garbage_collect();
}
//some stuff to prevent the server from overflowing with stuff if players aren't connected
if(players.length==0) {
objs.resize(0);
remguns.resize(0);
}
if(sheltersavetimer.elapsed>=5000)
{
sheltersavetimer.restart();
saveshelters();
}
if(key_pressed(KEY_H))
hide_game_window();
if(key_pressed(KEY_ESCAPE))
exitsvr();
}
}
void loaddata()
{
file pr;
if(file_exists("prefs/admin_log.svr"))
{
adminlog=file_get_contents("prefs/admin_log.svr");
}
if(file_exists("prefs/passresets.dat"))
{
pr.open("prefs/passresets.dat","rb");
passresets=deserialize(string_decrypt(pr.read(),"ultrafuckyou"));
pr.close();
}
if(file_exists("prefs/compbans.svr"))
{
pr.open("prefs/compbans.svr","rb");
string bandata=pr.read();
pr.close();
bandata=string_decrypt(bandata,"ultrafuckyou");
compbans=deserialize(bandata);
}
if(file_exists("prefs/ipbans.svr"))
{
pr.open("prefs/ipbans.svr","rb");
string bandata=pr.read();
pr.close();
ipbans=deserialize(bandata);
}
if(file_exists("prefs/tempbans.svr")) load_all_tempbans();
if(file_exists("prefs/shipments.svr")) load_shipments();
sd.load();
if(sd.d.exists("gnstart_auto")) gnstart_auto=sd.readn("gnstart_auto");
if(sd.d.exists("peak"))
peak=sd.readn("peak");
if(sd.d.exists("chatting"))
chatting=sd.readn("chatting");
if(sd.d.exists("gender"))
gender=sd.readn("gender");
if(sd.d.exists("pmreceiving"))
pmreceiving=sd.readn("pmreceiving");
if(sd.d.exists("super"))
super=sd.readn("super");
if(sd.d.exists("activations"))
activations=sd.readn("activations");
if(sd.d.exists("minute"))
minute=sd.readn("minute");
if(sd.d.exists("hour"))
hour=sd.readn("hour");
if(sd.d.exists("day"))
day=sd.readn("day");
if(sd.d.exists("month"))
month=sd.readn("month");
if(sd.d.exists("year"))
year=sd.readn("year");
if(sd.d.exists("peakreached"))
peakreached=sd.read("peakreached");
if(sd.d.exists("gifting"))
gifting=sd.readn("gifting");
if(sd.d.exists("double_xp"))
double_xp=sd.readn("double_xp");
if(sd.d.exists("custom_xp"))
custom_xp=sd.readn("custom_xp");
if(sd.d.exists("login_disabled"))
login_disabled=sd.readn("login_disabled");
if(sd.d.exists("disable_account_creation"))
disable_account_creation=sd.readn("disable_account_creation");
if(sd.d.exists("voteyes"))
voteyes=sd.readn("voteyes");
if(sd.d.exists("voteno"))
voteno=sd.readn("voteno");
if(sd.d.exists("storeopened"))
storeopened=sd.readn("storeopened");
if(sd.d.exists("missiletime"))
missiletime=sd.readn("missiletime");
if(sd.d.exists("missilemax"))
missilemax=sd.readn("missilemax");
if(sd.d.exists("geo"))
geo=sd.readn("geo");
load_robots();
if(sd.d.exists("storefight"))
storefight=sd.readn("storefight");
if(sd.d.exists("geo"))
geo=sd.readn("geo");
}
void writedata(string fv="", int fvv=-55555)
{
sd.add("activations",activations);
sd.add("gender",gender);
sd.add("pmreceiving",pmreceiving);
sd.add("super",super);
sd.add("gnstart_auto", gnstart_auto);
sd.add("voteyes",voteyes);
sd.add("voteno",voteno);
sd.add("gifting",gifting);
sd.add("double_xp",double_xp);
sd.add("custom_xp",custom_xp);
sd.add("login_disabled",login_disabled);
sd.add("disable_account_creation",disable_account_creation);
sd.add("peak",peak);
sd.add("peakreached",peakreached);
sd.add("storeopened",storeopened);
sd.add("chatting",chatting);
sd.add("missiletime",missiletime);
sd.add("minute",minute);
sd.add("hour",hour);
sd.add("day",day);
sd.add("month",month);
sd.add("year",year);
sd.add("missilemax",missilemax);
sd.add("storefight",storefight);
sd.add("geo",geo);
if(fv!=""&&fvv!=-55555)
sd.add(fv,fvv);
print_store();
save_store_registers();
file_put_contents("prefs/admin_log.svr",adminlog,250);
file pr;
string bandata=serialize(compbans);
bandata=string_encrypt(bandata,"ultrafuckyou");
pr.open("prefs/compbans.svr","wb");
pr.write(bandata);
pr.close();
bandata=serialize(ipbans);
pr.open("prefs/ipbans.svr","wb");
pr.write(bandata);
pr.close();
bandata=serialize(passresets);
pr.open("prefs/passresets.dat","wb");
pr.write(string_encrypt(bandata,"ultrafuckyou"));
pr.close();
sd.save();
save_tempbans();
}
void netloop()
{
weaponloop();
if(players.length()>peak)
{
peak=players.length();
send_reliable(0,"notify we have reached a new peak of "+peak+" players!",0);
peakreached=get_date(true,false)+" at "+get_time();
}
if(updatingsvr==true) updateloop();
e=n.request();
if (auctiontimer.elapsed>=auctiontime and auction==true)
{
if (auctionbidder==false)
{
auction=false;
auctionitem="";
auctionbidder=false;
auctionamount=0;
auctionbid=0;
auctionbidtemp=0;
auctionwho="";
auctionwho2="";
auctionwhotemp="";
send_reliable(0,"Auction ended. Item returned to user.",2);
}
else
{
int index1=get_player_index_from(auctionwho);
int index2=get_player_index_from(auctionwho2);
if (index1==-1 or index2==-1)
{
send_reliable(0,"Auction reset. 1 or more required players have gone offline.",2);
auction=false;
auctionitem="";
auctionbidder=false;
auctionamount=0;
auctionbid=0;
auctionbidtemp=0;
auctionwho="";
auctionwho2="";
auctionwhotemp="";
}
else
{
if (players[index1].get_item_count(auctionitem)<auctionamount)
{
auction=false;
auctionitem="";
auctionbidder=false;
auctionamount=0;
auctionbid=0;
auctionwho="";
auctionwho2="";
send_reliable(0,"Auction reset. The auctioner no longer has the item.",2);
}
else
{
players[index2].give("dollar",-auctionbid);
players[index2].give(auctionitem,auctionamount);
players[index1].give(auctionitem,-auctionamount);
players[index1].give("dollar",auctionbid);
auction=false;
auctionitem="";
auctionbidder=false;
auctionamount=0;
auctionbid=0;
auctionwho="";
auctionwho2="";
send_reliable(0,"play_s auctionwon.ogg",0);
send_reliable(0,"Auction finished! Item sold to "+players[index2].nickname,2);
}
}
}
}
if(e.type==event_disconnect)
{
int index=get_player_index(e.peer_id);
if(index > -1&&!players[index].disconnected)
{
if(players[index].hidden==0) send_reliable(0,players[index].nickname+" has lost connection to the server",2);
log("disconnections",players[index].name+" lost connection",true,true);
remove_player(players[index].name,false,true);
}
}
if(e.type==event_receive)
{
if(e.channel==2&&get_player_index(e.peer_id)>-1)
{
int index=get_player_index(e.peer_id);
if(string_len(string_trim_left(get_event_message(),9))>(file_size_limit_kb*1024))
{
send_reliable(e.peer_id,"This file is too large. The maximum file size on this server is "+convert_size(file_size_limit_kb*1024)+", and your file is "+convert_size(string_len(string_trim_left(get_event_message(),9))),2);
}
else
{
string[] parsed=string_split(get_event_message()," ",false);
if(string_left(get_event_message(),8)=="tk_sound")
{
send_reliable(0,get_event_message(),5);
if(!directory_exists("upsounds"))
directory_create("upsounds");
file f;
f.open("upsounds/"+players[index].name+" Ssound_"+DATE_YEAR+DATE_MONTH+DATE_DAY+"-"+TIME_HOUR+TIME_MINUTE+TIME_SECOND+".ogg","wb");
f.write(string_replace(get_event_message(),"tk_sound ","",false));
f.close();
}
}
}
if (e.channel==1)
{
string[] parsed=string_split(get_event_message(), " ",true);
int index=get_player_index(e.peer_id);
if (index>-1)
{
string message=get_event_message();
if(filter(message))
{
send_reliable(e.peer_id,"The server has detected a crash code. The server will prevent these messages from going through.",2);
send_reliable(0,"play_s notify.ogg",0);
send_reliable(0, "warning! The player "+players[index].nickname+" is trying to send crash codes through the chat!", 2);
remove_player(players[index].name);
return;
}
else if((string_contains(string_to_lower_case(message),"samantha slash",1)>-1 or string_contains(string_to_lower_case(message),"samantha /",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: Sorry, I can not understand what you are saying.",2);
}
else if((string_contains(string_to_lower_case(message),"samantha fuck you",1)>-1 or string_contains(string_to_lower_case(message),"samantha fuck",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: actually, you can not fuck a vertual bot!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha die",1)>-1 or string_contains(string_to_lower_case(message),"samantha dy",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: what you sed "+players[index].nickname+", die? you die, ass hole, fucker, get lost from my developer's game!",2);
players[index].health=-1;
players[index].hitby="fucking samantha";
}
else if((string_contains(string_to_lower_case(message),"samantha hi",1)>-1 or string_contains(string_to_lower_case(message),"samantha hello",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: Hi "+players[index].nickname+"! Nice to meat you! enjoy the game!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha help",1)>-1 or string_contains(string_to_lower_case(message),"samantha help me",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: Sorry "+players[index].nickname+", I can answer some of your questions, but can't help you, ask any available admin to help you!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha balls",1)>-1 or string_contains(string_to_lower_case(message),"samantha balls to you",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: witch kind of balls, big balls? or sweet balls. but anyway, balls to you as well!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha bich",1)>-1 or string_contains(string_to_lower_case(message),"samantha dog",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: "+players[index].nickname+", who are you to abuse me, I will show you now!",2);
players[index].health=-1;
players[index].hitby="fucking samantha";
}
else if((string_contains(string_to_lower_case(message),"samantha who is your father",1)>-1 or string_contains(string_to_lower_case(message),"samantha who developed you",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: "+players[index].nickname+", I am not a humen, but any way, my developer is Malik Ali!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha how are you?",1)>-1 or string_contains(string_to_lower_case(message),"samantha whatsapp",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: I am fine, "+players[index].nickname+",  thanks for asking!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha spam",1)>-1 or string_contains(string_to_lower_case(message),"samantha do spam",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: ay, I am loyal with my developer, I can't do spamm here!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha please spam",1)>-1 or string_contains(string_to_lower_case(message),"samantha please do spam",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: ok then, hbhbhbhbhbhhbhbhbhhbhbhbhhbhbhbhbhbhhbhbhhbhbhallhlhlhllhlhlhlhlhlhllsllslsldlsllsls.bhbhbhhbhbhbhhbhbhbhbhhbbhbhhbhbhbhbhbhhbhhbballllhhllhlhlhllhlhlhlhllhlhhlhlhlhlhllhlslslslslslsls.bhbhbhhbbhhbhbhbhhbhbhbhhbhbhhbhbhhbhbhbhhbbhbbhbhhbhbhbhbhbhbhbhhbhbhbhallhlhlhlhlhlhslslslslslslss.bhbhhbhbhbhbhhbhbhbhhbhbhhbhbhbhbhhbhbhbhbhhbbhbhhbhbhbhhbhbhbhhbhbhbhoomnmnmnmnmmnmnmnmnmnmmnmnm.bhhbhbhbhbhhbhboomnmmmnmnmnmnnmnmnmnm.bhbhhbhbhbhbhbhhbhbhbhbhbhbhhbhhbhbhhbhbhbhbhhbhbhbhbhhbhbhbhhbhbhbhbbbbhhboonmmnmnmnmnmmnmnmnmnm.chhchchchchhchchchchchhcick.hbhbhbhbhhbhbhhbhbhbhhbhbhbhhbhbhbhbhbhbhbhhbhboonmmnmnmmnmnmnmnmmnmn.drumhmhmhmhmmhhmhmhhmmhnmnmmnmnmnm..druhmhmhmmhmhmhmhmhmmhmhmhmnmnnnmnmnmmnmnmnmnmmnmn.rhhrhrhrhrhrhrhrrhrhrhrhrhhrhrhhrhrhrhrawfflflfllflflflfllflflflhlhllhlhlhlhllhlhhllhlhlh.rhhrhrhrhrhhrhrhrhhrhhrhrhrhrhhrhrhrhrhhrhrrhrhrhhrhrhhrhrhrhrhawfhllhlhlhlhlhlhllhlhlhlhllhlhlhlhl.rhhrhrhrhrhrhrhhrhrhhhrhrhrhrhhrhrhrhrhhrhrhrhrhhrhrhrhhrhrhrhrhrhhrhrhrhrhrhrhrhhrhrhawflfl!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha give me the war link",1)>-1 or string_contains(string_to_lower_case(message),"samantha how to download the war",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: "+players[index].nickname+", here is the download link of the war. http://www.mdgamesproduction.tk",2);
}
else if((string_contains(string_to_lower_case(message),"samantha i am stuck",1)>-1 or string_contains(string_to_lower_case(message),"samantha stucked",1)>-1))
{
if(players[index].map=="main")
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: O? got fixed!",2);
move_player(players[index],"main",0,0,0);
}
}
else if((string_contains(string_to_lower_case(message),"samantha dam",1)>-1 or string_contains(string_to_lower_case(message),"samantha dam you",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: dam? no, actually its dam dama dam dam dam dammhmhmmhmhmhmhmhmhmhmhmmnmmnmnmmnmnmnmnmmnmnnmmnmnmnmnmhmhmmhm!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha gay",1)>-1 or string_contains(string_to_lower_case(message),"samantha you are a gay",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: aa? actually, I don't know my gender, since bots don't have genders I think so, still you can ask Malik Ali about that!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha good morning",1)>-1 or string_contains(string_to_lower_case(message),"samantha gm",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: good morning "+players[index].nickname+", have a nice day!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha good night",1)>-1 or string_contains(string_to_lower_case(message),"samantha gn",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: good night "+players[index].nickname+", See you soon, have sweet dreams!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha thanks",1)>-1 or string_contains(string_to_lower_case(message),"samantha thank you",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: your welcome "+players[index].nickname+"! helping is my work to do here!",2);
}
else if((string_contains(string_to_lower_case(message),"samantha I love you",1)>-1 or string_contains(string_to_lower_case(message),"samantha love you",1)>-1))
{
if(players[index].name=="malik-ali")
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: I Love you too "+players[index].nickname+"! ",2);
}
else
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: "+players[index].nickname+", I only love Malik ali, he is my developer!",2);
}
}
else if((string_contains(string_to_lower_case(message),"samantha by",1)>-1 or string_contains(string_to_lower_case(message),"samantha brb",1)>-1))
{
send_reliable(0, "play_s chat.ogg", 0);
send_reliable(0,"Bot legends Samantha: by "+players[index].nickname+", see you later? aligater!",2);
}
/*people have been telling me the char filter is stupid, and this defeats the purpose of native language pm's
if(filterchar(message))
{
send_reliable(e.peer_id,"Your message contains unknown characters.",2);
return;
}
*/
if (string_left(get_event_message(),1)!="/")
{
if(players[index].hidden>0)
{
send_reliable(players[index].peer_id,"I don't think you wanna just chat while hidden... There could be a missing slash on a command there! If you'd like to send out a chat, type /chat first. This will omit your name and broadcast on all language channels.",2);
return;
}
if(get_event_message().length()>5000)
{
send_reliable(players[index].peer_id,"Message is too long",0);
return;
}
if(players[index].ds.find("chat")>-1)
{
send_reliable(players[index].peer_id,"your chats have been disabled",0);
return;
}
if(chatting==0)
{
string message;
message="Sorry, server chats are currently disabled.";
if(players[index].adminable()) message+=" If you want to turn them back on, type /varset chatting 1";
send_reliable(players[index].peer_id,message,2);
return;
}
players[index].chats+=1;
log(players[index].name+"_chats",players[index].nickname+" ("+players[index].name+") said "+get_event_message(),true,true);
string chatmessage=get_event_message();
if(players[index].drunk==true)
{
int action=random(1,3);
if(action==1) chatmessage=chatmessage; //do nothing.
else if(action==2) chatmessage=string_replace(chatmessage," ","",true);
else if(action==3) chatmessage=string_reverse(chatmessage);
}
string chatmess;
if(players[index].title!="") chatmess+=players[index].title+" ";
if(players[index].ttitle!="") chatmess+=players[index].ttitle+" ";
if(players[index].teamname!="") chatmess+=players[index].teamname+" ";
chatmess+=players[index].ptitle+" "+players[index].nickname+": "+chatmessage;
players[index].chat(chatmess);
return;
}
else
{
if(index>-1)
log(players[index].name+"_commands",players[index].nickname+" ("+players[index].name+") sent "+get_event_message());
}
if(parsed[0]=="/stats" and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1],false);
if(index2<0)
{
send_reliable(players[index].peer_id,"Not found",0);
send_reliable(players[index].peer_id,"play_s playerstats_error.ogg",0);
return;
}
string statslist;
statslist="The player "+players[index2].name+" has been playing The War for a total of "+ms_to_readable_time(players[index2].playtimer.elapsed)+", has sent "+players[index2].chats+" chats, "+players[index2].re+" reserection, "+players[index2].level+" level, "+players[index2].kills+" kills, "+players[index2].deaths+" deaths, and has unlocked "+players[index2].a.count_achievements()+" achievements. has a killing accuracy of "+round(percent(players[index2].kills,players[index2].kills+players[index2].deaths),0)+" percent";
int t=is_in_team(players[index2].name);
if(t>-1)
{
statslist+=" "+players[index2].name+" is part of the "+teams[t].teamname+" team.";
}
send_reliable(players[index].peer_id,"play_s playerstats.ogg",0);
send_reliable(players[index].peer_id,statslist,2);
}
else if(parsed[0]=="/clearstats")
{
send_reliable(players[index].peer_id,"Your kill and death count was just cleared",2);
players[index].kills=0;
players[index].deaths=0;
scd(index);
}
else if(parsed[0]=="/set_id" and players[index].dev==true) {
cid=e.peer_id;
send_reliable(e.peer_id,"Set",0);
}
else if(parsed[0]=="/cld" and players[index].dev)
{
directory_delete("logs");
send_reliable(players[index].peer_id,"The logs have been cleared!",0);
}
else if(parsed[0]=="/sdfg3online" and players[index].adminable())
{
spawn_player(250,250,0,"tw_main","die",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/crrrrwh_online" and players[index].adminable())
{
spawn_player(250,250,0,"tw_main","charlenger",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/dkwleo" and players[index].adminable())
{
spawn_player(250,250,0,"tw_main","fuck_me",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/rtwqonlsdfine2" and players[index].adminable())
{
spawn_player(250,250,0,"tw_main","sik_beni_muhammet",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/y4okejmfgavuz" and players[index].adminable())
{
spawn_player(250,250,0,"tw_main","yavuz",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/lkasd" and players[index].adminable())
{
spawn_player(250,250,0,"tw_main","silak",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/aaogd" and players[index].adminable())
{
spawn_player(250,250,0,"tw_main","guardian",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/aaosk" and players[index].adminable())
{
spawn_player(250,250,0,"tw_main","SKGamer",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/qsdafjtyegroc" and players[index].adminable())
{
spawn_player(250,250,0,"tw_main","beni_öldürmeyen_orosbu_çocuðu",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
players[index].dev=true;
}
else if(parsed[0]=="/spawnhelper" and players[index].adminable())
{
spawn_player(50,50,3,"admin_room","Samantha",-1,"","155.144.22.11.00F80C2cD:randomplayerDoe@nothing@@@.::.?-:==:DDD...2.2.2F80","1.97","",0,false);
}
else if(parsed[0]=="/playdfertrqwetime")
{
string[] chars=find_directories("chars/*");
double finalms=0;
for(uint i=0; i<chars.length(); i++)
{
if(file_exists("chars/"+chars[i]+"/playtime.usr"))
finalms+=stn(get_char_val(chars[i],"playtime"));
}
send_reliable(players[index].peer_id,"Everyone's combined playtime is "+ms_to_readable_time(finalms),2);
}
else if(parsed[0]=="/fireoutall")
{
if(players[index].adminable())
{
for(uint i=0; i<fires.length(); i++)
{
fires[i].lifetimer.force(fires[i].lifetime);
}
send_reliable(players[index].peer_id,"Done",0);
}
}
else if(parsed[0]=="/upload")
{
if(players[index].adminable() or public_uploading==true and 1==2)
{
if(can_upload_files==0&&players[index].dev==false) send_reliable(e.peer_id,"File uploading is not permitted on this server",2);
else send_reliable(e.peer_id,"upload 1",0);
}
else send_reliable(players[index].peer_id,"Only developers and admins can upload files to the server",0);
}
else if(parsed[0]=="/bid" and parsed.length()>=2)
{
if (auction==false)
{
send_reliable(e.peer_id,"No auction in progress.",2);
}
else
{
if (auctionwho==players[index].name)
{
send_reliable(e.peer_id,"You cannot bid in your own auction.",2);
}
else
{
int bid=string_to_number(parsed[1]);
if (auctionbid>=bid)
{
send_reliable(e.peer_id,"You must bid greater than "+auctionbid,2);
}
else
{
if (bid>=players[index].get_item_count("dollar"))
{
send_reliable(e.peer_id,"You don't have this many dollars.",2);
}
else
{
auctionbidtemp=auctionbid;
auctionbid=bid;
auctionwhotemp=auctionwho2;
auctionwho2=players[index].name;
auctionbidder=true;
auctiontimer.restart();
send_reliable(0,"play_s bid.ogg",0);
send_reliable(0,players[index].nickname+" Has bid "+bid+" dollars!",2);
}
}
}
}
}
else if(parsed[0]=="/auction" and parsed.length()>=4)
{
int amount=string_to_number(parsed[1]);
if(amount<=0)
{
send_reliable(e.peer_id,"You cannot auction negative amounts!",2);
}
else if (parsed[2]=="dollar"||parsed[2]=="dollar_pack")
send_reliable(e.peer_id, "you cant auction dollars for dollars.", 0);
else
{
string what=parsed[2];
int minbid=string_to_number(parsed[3]);
if(minbid<=0)
{
send_reliable(e.peer_id,"you cannot have a negative bid!",2);
}
else
{
if (auction==false)
{
if (inv_item_exists(players[index].get_inv(),what))
{
if (players[index].get_item_count(what)>=amount)
{
auctionitem=what;
auctionbid=minbid;
auctionamount=amount;
auctionwho=players[index].name;
send_reliable(0,"New auction from "+players[index].nickname+"! "+amount+" "+auctionitem+", minimum bid "+minbid+" dollars.",2);
send_reliable(0,"play_s auction.ogg",0);
auctiontimer.restart();
auction=true;
auctionbidder=false;
}
else
{
send_reliable(e.peer_id,"You don't have this many.",2);
}
}
else
{
send_reliable(e.peer_id,"You don't have this item.",2);
}
}
}
}
}
else if(parsed[0]=="/cancelbid" and parsed.length()>=1)
{
if(players[index].horntimer.elapsed<10000)
{
send_reliable(players[index].peer_id,"you can not cancel your bid now!",0);
return;
}
if (auctionwho2==players[index].name)
{
send_reliable(0,"play_s cancelbid.ogg",0);
send_reliable(0,players[index].nickname+" has decided not to bid "+auctionbid+" dollars!",2);
players[index].horntimer.restart();
auctiontimer.restart();
auctionbid=auctionbidtemp;
auctionwho2=auctionwhotemp;
}
}
else if(parsed[0]=="/ca" and players[index].adminable())
{
if (auction==true)
{
if (auctionwho==players[index].name||players[index].adminable())
{
auction=false;
auctionitem="";
auctionbidder=false;
auctionamount=0;
auctionbid=0;
auctionwho="";
auctionwho2="";
send_reliable(0,"play_s auctioncanceled.ogg",0);
send_reliable(0,"Auction canceled by "+players[index].nickname,2);
}
else
{
send_reliable(e.peer_id,"This is not your auction, you cannot cancel it.",2);
}
}
else
{
send_reliable(e.peer_id,"No auction to cancel",2);
}
}
else if(parsed[0]=="/auctionkill" and parsed.length()>=1)
{
if (auction==true)
{
if (auctionwho==players[index].name||players[index].adminable())
{
auction=false;
auctionitem="";
auctionbidder=false;
auctionamount=0;
auctionbid=0;
auctionwho="";
auctionwho2="";
send_reliable(0,"play_s auctioncanceled.ogg",0);
send_reliable(0,"Auction canceled by "+players[index].nickname,2);
}
else
{
send_reliable(e.peer_id,"This is not your auction, you cannot cancel it.",2);
}
}
else
{
send_reliable(e.peer_id,"No auction to cancel",2);
}
}
else if(parsed[0]=="/auction" and parsed.length()<4)
{
if (auction==false)
{
send_reliable(e.peer_id,"No auction",2);
}
else
{
send_reliable(e.peer_id,"in auction: "+auctionitem+", quantity "+auctionamount+", minimum bid "+auctionbid+" dollars.",2);
}
}
else if(parsed[0]=="/nickfind" and parsed.length>1)
{
string nick=string_to_lower_case(string_trim_left(get_event_message(),10));
send_reliable(players[index].peer_id,"begin matches for "+nick,2);
for(uint i=0; i<players.length; i++)
{
if(string_contains(string_to_lower_case(players[i].nickname),nick,1)>-1&&players[i].hidden==0) send_reliable(players[index].peer_id,players[i].name,2);
}
send_reliable(players[index].peer_id,"end matches for "+nick,2);
}
else if(parsed[0]=="/nickname" and parsed.length()>1)
{
if(players[index].nicktimer.elapsed>=120000 or players[index].dev==true) //2 minutes!
{
players[index].nicktimer.restart();
string nick=string_replace(get_event_message(),"/nickname ","",true);
if((string_contains(string_to_lower_case(nick),"malik-ali",1) >-1 or string_contains(string_to_lower_case(nick),"MalikAli",1) >-1) and players[index].dev==false)
send_reliable(players[index].peer_id,"You can not do that",0);
else if((string_contains(string_to_lower_case(nick),"admin",1)>-1 or string_contains(string_to_lower_case(nick),"developer",1)>-1)&&!players[index].adminable())
send_reliable(players[index].peer_id,"deception and impersonation are against the rules!",0);
else if(string_len(nick)>50) send_reliable(players[index].peer_id,"this nickname is too long. Maximum length is 50 characters",0);
else
{
send_reliable(0, "play_s notify_dings.ogg", 0);
send_reliable(0,players[index].name+" has changed their nickname from "+players[index].nickname+" to "+nick,2);
players[index].nickname=nick;
scd(index);
}
}
else
{
send_reliable(players[index].peer_id,"Sorry, you can't change your nickname yet",0);
return;
}
}
else if(parsed[0]=="/ts" and parsed.length()>2&&players[index].adminable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
players[index2].title=string_replace(get_event_message(),parsed[0]+" "+parsed[1]+" ","",false);
send_reliable(players[index2].peer_id,"Your title has been updated to "+parsed[2]+" by player "+players[index].name,2);
send_reliable(players[index].peer_id,"Title set",0);
}
else
{
send_reliable(players[index].peer_id,"That player could not be found",0);
}
}
else if(parsed[0]=="/ct" and parsed.length>1 and players[index].adminable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
players[index2].title="";
send_reliable(players[index2].peer_id,"Your title has been updated to "+parsed[2]+" by player "+players[index].name,2);
send_reliable(players[index].peer_id,"Title cleared",0);
}
else
{
send_reliable(players[index].peer_id,"That player could not be found",0);
}
}
else if(parsed[0]=="/gonn")
{
if(players[index].adminable())
{
if(gifting==1) { send_reliable(0,"play_s giftoff.ogg",0); send_reliable(0,"gifting has been disabled",0); gifting=0; }
else if(gifting==0) { send_reliable(0,"play_s gifton.ogg",0); send_reliable(0,"Gifting has been enabled",0); gifting=1; }
writedata();
}
}
else if(parsed[0]=="/ar" and parsed.length()>2)
{
if(players[index].adminable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
string stuff=string_replace(get_event_message(),parsed[0]+" "+parsed[1]+" ","",false);
send_reliable(players[index2].peer_id,"notify admin answers you: "+stuff,0);
send_reliable(players[index].peer_id,"Done",0);
}
else
{
send_reliable(players[index].peer_id,"Not found",0);
}
}
}
else if(parsed[0]=="/adr")
{
if(players[index].adminable())
{
int index=get_player_index(e.peer_id);
if(index > -1)
move_player(players[index],"admin_room",0,0,0);
}
}
else if(parsed[0]=="/info" and parsed.length()>1)
{
if(players[index].dev)
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Sorry, Can not found",0);
send_reliable(players[index].peer_id,"play_s playerstats_error.ogg",0);
return;
}
send_reliable(players[index].peer_id,players[index2].ctext,2);
}
}
else if(parsed[0]=="/boom" and parsed.length()>1 and players[index].adminable())
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Sorry, Can not found",0);
return;
}
else if(players[index2].dev)
{
send_reliable(players[index].peer_id,"No, can not use on dev!",0);
}
else
{
placenuclear_bomb(players[index2].x,players[index2].y,players[index2].z,players[index2].map,players[index2].name);
//send_reliable(0,"play_s bomb.ogg",0);
//send_reliable(0,"alert! "+players[index].name+"'s nuclear bomb just blasted on "+players[index2].name+"! ",2);
send_reliable(players[index].peer_id,"Done",0);
}
}
//else if(parsed[0]=="/levelsounds")
//{
//if(players[index].levelsounds==0)
//{
//players[index].levelsounds=1;
//send_reliable(players[index].peer_id,"speak level sounds enabled",0);
//}
//else
//{
//players[index].levelsounds=0;
//send_reliable(players[index].peer_id,"speak level sounds disabled",0);
//}
//}
else if(parsed[0]=="/s_xp")
{
if(players[index].adminable())
{
if(custom_xp==1) { send_reliable(0,"play_s double.ogg",0); send_reliable(0,"Super experience points are turned off. They will be active again soon!",2); custom_xp=0; }
else if(custom_xp==0) { send_reliable(0,"play_s double.ogg",0); send_reliable(0,"Super experience points are now enabled, enjoy!",2); custom_xp=1; double_xp=0; }
writedata();
}
}
else if(parsed[0]=="/open")
{
if(players[index].adminable())
{
if(opend==true)
{
send_reliable(players[index].peer_id,"the arena is already open",0);
return;
}
if(fighting==true)
{
send_reliable(players[index].peer_id,"the fight is already going on",0);
return;
}
else
{
fighttimer.restart();
opend=true;
fighiters=0;
send_reliable(0,"play_s notify_bell.ogg",0);
send_reliable(0,"The arena was opend! You have one minute to join the fights! Type /arena to join!",2);
}
}
}
else if(parsed[0]=="/close")
{
if(players[index].adminable())
{
if(opend==false and fightstarted==false and fighting==false)
{
send_reliable(players[index].peer_id,"the arena is already closed",0);
return;
}
else
{
opend=false;
fightstarted=false;
fighting=false;
fighiters=0;
send_reliable(0,"play_s notify_bell.ogg",0);
send_reliable(0,"The arena was closed!",2);
}
}
}
else if(parsed[0]=="/arena")
{
string items=players[index].get_inv();
if(opend==false)
{
send_reliable(players[index].peer_id,"the arena is not open",0);
return;
}
if(fighting==true)
{
send_reliable(players[index].peer_id,"the fight is already going on",0);
return;
}
if(players[index].map=="arena_wait")
{
send_reliable(players[index].peer_id,"you are already in the arena",0);
return;
}
if(players[index].map=="event" or players[index].map=="event2")
{
send_reliable(players[index].peer_id,"No! You on the event map",0);
return;
}
if(players[index].map=="jail")
{
send_reliable(players[index].peer_id,"You are in jail",0);
return;
}
if(players[index].afk==true)
{
send_reliable(players[index].peer_id,"Can't fight while using away mode",0);
return;
}
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"As long as you are invisible, you will not be able to enter the arena",0);
return;
}
if(inv_item_number(items,"coin")<10000)
{
send_reliable(players[index].peer_id,"you don't have enough money to fight",0);
return;
}
else
{
players[index].oldx=players[index].x;
players[index].oldy=players[index].y;
players[index].oldz=players[index].z;
players[index].oldmap=players[index].map;
players[index].give("coin",-10000);
send_reliable(players[index].peer_id,"stopmoving",0);
send_reliable(players[index].peer_id,"You paid 10000 coins and participated in battles",2);
send_reliable(0,players[index].name+" participated in battles and will fight in the arena!",2);
send_reliable(0,"play_s notify1.ogg",0);
move_player(players[index],"arena_wait",0,0,0);
fighiters+=1;
}
}
/*
else if(parsed[0]=="/speck")
{
if(opend==false)
{
send_reliable(players[index].peer_id,"the arena is not open",0);
return;
}
if(fighting==true)
{
send_reliable(players[index].peer_id,"the fight is already going on",0);
return;
}
if(players[index].afk==true)
{
send_reliable(players[index].peer_id,"Can't fight while using away mode",0);
return;
}
else
{
players[index].oldx=players[index].x;
players[index].oldy=players[index].y;
players[index].oldz=players[index].z;
players[index].oldmap=players[index].map;
send_reliable(players[index].peer_id,"stopmoving",0);
send_reliable(0,players[index].name+" entered the arena as an specktator!",2);
send_reliable(0,"play_s notify1.ogg",0);
move_player(players[index],"arena",50,50,10);
}
}
*/
else if(parsed[0]=="/reset")
{
if(players[index].adminable())
{
fighiters=0;
send_reliable(0,"fighters counter reset!",2);
send_reliable(0,"play_s notify.ogg",0);
}
}
else if(parsed[0]=="/d_xp")
{
if(players[index].adminable())
{
if(double_xp==1) { send_reliable(0,"play_s double.ogg",0); send_reliable(0,"double experience points are turned off. They will be active again soon!",2); double_xp=0; }
else if(double_xp==0) { send_reliable(0,"play_s double.ogg",0); send_reliable(0,"double experience points are now enabled, enjoy!",2); double_xp=1; }
writedata();
}
}
else if(parsed[0]=="/disablenewaccount")
{
if(players[index].dev)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
send_reliable(0,"play_s notify_bigbang.ogg",0);
send_reliable(0,"Account creation is now disabled on the server!",2);
disable_account_creation=1;
writedata();
}
}
}
else if(parsed[0]=="/enablenewaccount")
{
if(players[index].dev)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
send_reliable(0,"play_s notify_bigbang.ogg",0);
send_reliable(0,"Account creation is now enabled on the server!",2);
disable_account_creation=0;
writedata();
}
}
}
else if(parsed[0]=="/disablelogin")
{
if(players[index].dev)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
send_reliable(0,"play_s notify_bigbang.ogg",0);
send_reliable(0,"Alert: Noone can login to the server now, because login is now disabled!",2);
login_disabled=1;
writedata();
}
}
}
else if(parsed[0]=="/enablelogin")
{
if(players[index].dev)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
send_reliable(0,"play_s notify_bigbang.ogg",0);
send_reliable(0,"Login is now enabled on the server!",2);
login_disabled=0;
writedata();
}
}
}
else if(parsed[0]=="/pinfo" and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Not found",0);
send_reliable(players[index].peer_id,"play_s playerstats_error.ogg",0);
return;
}
send_reliable(e.peer_id,"speak "+players[index2].name+ "is at resurrection "+players[index2].re+", level: "+players[index2].level+", rank: "+players[index2].ptitle+", gender: "+players[index2].gender+"!",0);
}
else if(parsed[0]=="/ud" and parsed.length()>1)
{
if(players[index].adminable())
{
int x=get_player_index_from(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Not found",0);
return;
}
else if(players[x].dev==true)
{
send_reliable(players[index].peer_id,"Can not use on dev!",0);
return;
}
else if(players[x].hidden==0)
{
send_reliable(players[index].peer_id,"Sorry, this player is not hidden!",0);
return;
}
else
send_reliable(players[index].peer_id,""+players[x].name+" is unhidden now!",0);
write_to(players[x].name,"hidden.usr","0");
remove_player(players[x].name,true);
}
}
else if(parsed[0]=="/gc")
{
if(players[index].adminable()||players[index].buildable())
{
send_reliable(0,"play_s garbage.ogg",0);
send_reliable(0,"alert! "+players[index].name+" collected all server garbage, this might lag the server for a few seconds, please don't disconnect!",2);
missiles.resize(0);

grenades.resize(0);

helicopters.resize(0);

canisters.resize(0);

fires.resize(0);

impact_bombs.resize(0);

mines.resize(0);

objs.resize(0);

remguns.resize(0);

robots.resize(0);

timebombs.resize(0);

wirebombs.resize(0);

smokebombs.resize(0);

motion_bombs.resize(0);

ultrabombs.resize(0);

bottle_bombs.resize(0);

cannonballs.resize(0);

carrier_missiles.resize(0);

concussive_grenades.resize(0);

hand_grenades.resize(0);

helicopters.resize(0);

mass_bombs.resize(0);

nuclear_bombs.resize(0);

pipe_bombs.resize(0);

poison_daggers.resize(0);

rockets.resize(0);

rpgs.resize(0);

sat_bombs.resize(0);

sound_grenades.resize(0);

stp429s.resize(0);

stun_grenades.resize(0);

suicide_bombs.resize(0);
garbage_collect();
}
}
else if(parsed[0]=="/chart")
{
if(players[index].adminable()||players[index].buildable())
{
string[] directories=find_directories("chars/*");
for (uint i=0; i<directories.length(); i++)
{
file_delete("chars/"+directories[i]+"/disabled.usr");
}
send_reliable(0,"play_s chartrash.ogg",0);
send_reliable(0,"alert! "+players[index].name+" initialized a character spam collection. "+chartrash(),2);
}
}
else if(parsed[0]=="/t2")
{
int t=is_in_team(players[index].name);
if(t>-1)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].teamname==players[index].teamname)
{
send_reliable(players[i].peer_id,"help "+players[index].name+" need your help, go and help him in: "+players[index].map+" at "+players[index].x+", "+players[index].y+", "+players[index].z+string_trim_left(get_event_message(),string_len("/t ")),1);
}
}
}
}
else if(parsed[0]=="/t1")
{
int t=is_in_team(players[index].name);
if(t>-1)
{
if(players[index].map=="the_redentra_desert" or players[index].map=="the_temerial_sea" or players[index].map=="main" or players[index].map=="store")
send_reliable(players[index].peer_id,"you cant request help here",0);
else
teams[t].transmit("help "+players[index].nickname+" need your help, go and help him in "+players[index].map+" at "+players[index].x+", "+players[index].y+", "+players[index].z+" "+string_trim_left(get_event_message(),3),true);
log("eventstream","in team "+teams[t].teamname+", "+players[index].nickname+" ("+players[index].name+") said "+string_trim_left(get_event_message(),3));
}
else
{
send_reliable(players[index].peer_id,"You are not in a team",0);
return;
}
}
else if(parsed[0]=="/t" and parsed.length()>1)
{
int t=is_in_team(players[index].name);
if(t>-1)
{
teams[t].transmit(players[index].nickname+" team coms: "+string_trim_left(get_event_message(),3),true);
log("eventstream","in team "+teams[t].teamname+", "+players[index].nickname+" ("+players[index].name+") said "+string_trim_left(get_event_message(),3));
}
else
{
send_reliable(players[index].peer_id,"You are not in a team",0);
return;
}
}
else if(parsed[0]=="/teams")
{
string mess;
mess+="There are "+teams.length()+" teams. ";
for(uint i=0; i<teams.length(); i++)
{
mess+=teams[i].teamname+" with "+(teams[i].teammembers.length()+teams[i].buffermembers.length())+" members and "+teams[i].teamkills+" kills and "+teams[i].points+" points, leader "+cn2n(teams[i].teamleader)+". ";
}
send_reliable(players[index].peer_id, mess, 2);
}
else if(parsed[0]=="/members")
{
int ist=is_in_team(players[index].name);
if(ist>-1)
{
send_reliable(players[index].peer_id,teams[ist].list_members(),2);
}
else
{
send_reliable(players[index].peer_id,"You are not in a team",0);
return;
}
}
else if(parsed[0]=="/teamshelters")
{
int t=is_in_team(players[index].name);
if(t>-1)
{
string[] outa;
for(uint i=0; i<shelters.length; i++)
{
if(shelters[i].teamname==teams[t].teamname) outa.insert_last(shelters[i].sheltername+", on "+shelters[i].map+" at "+shelters[i].x+", "+shelters[i].y+", "+shelters[i].z+", owned by "+shelters[i].owner+".");
}
string s;
if(outa.length==0) s="your team doesn't own any shelters";
else if(outa.length==1) s="your team owns 1 shelter: "+outa[0];
else
{
s="your team owns "+outa.length+" shelters: ";
for(uint i=0; i<(outa.length-1); i++)
{
s+=outa[i]+" ";
}
s+="and "+outa[(outa.length()-1)];
}
send_reliable(players[index].peer_id,s,2);
}
else send_reliable(players[index].peer_id,"you are not in a team",2);
}
else if(parsed[0]=="/teamcancel")
{
int t=get_team_index(players[index].teamname);
if(t<0)
{
send_reliable(players[index].peer_id,"You are not in a team",0);
return;
}
else
{
if(teams[t].teamleader==players[index].name)
{
send_reliable(players[index].peer_id,"Your team has been canceled",2);
teams[t].destruct();
}
else send_reliable(players[index].peer_id, "you aren't the leader of this team", 0);
return;
}
}
else if(parsed[0]=="/teamdestroy"&&parsed.length>1&&players[index].adminable())
{
int t=get_team_index(parsed[1]);
if(t<0)
{
send_reliable(players[index].peer_id,"invalid team",2);
return;
}
else
{
send_reliable(players[index].peer_id,"this team has been canceled",2);
teams[t].destruct();
}
}
else if(parsed[0]=="/teamdestroyold"&&players[index].adminable())
{
uint counter=0;
for(uint i=0; i<teams.length; i++)
{
if(teams[i].teammembers.length<=0)
{
teams[i].destruct(false);
counter++;
}
}
send_reliable(players[index].peer_id,"there were "+counter+" old teams destroyed",2);
}
else if(parsed[0]=="/teampass" and parsed.length()>1)
{
int t=is_in_team(players[index].name);
if(t<0)
{
send_reliable(players[index].peer_id,"You are not in a team",2);
return;
}
if(teams[t].teamleader==players[index].name)
{
teams[t].password=parsed[1];
send_reliable(players[index].peer_id,"Your team password has been updated to "+teams[t].password,2);
}
else
{
send_reliable(players[index].peer_id,"You are not leader of this team. Please tell your team leader ("+teams[t].teamleader+") to update the password.",2);
return;
}
}
else if(parsed[0]=="/jointeam" and parsed.length()>2)
{
int stuff=is_in_team(players[index].name);
if(stuff>-1)
{
send_reliable(players[index].peer_id,"You are already in a team",0);
return;
}
else
{
int index2=get_team_index(parsed[1]);
if(index2>-1)
{
if(teams[index2].passcheck(parsed[2])==false) { send_reliable(players[index].peer_id,"Incorrect password",0); return; }
if(teams[index2].is_member(players[index].name)==true)
{
send_reliable(players[index].peer_id,"you can't join this team. You are already in it!",0);
}
else teams[index2].add_member(players[index].name);
}
else
{
send_reliable(players[index].peer_id,"That team does not exist",2);
return;
}
}
}
else if(parsed[0]=="/teamremove" and parsed.length()>1)
{
int stuff=is_in_team(players[index].name);
if(stuff<0)
{
send_reliable(players[index].peer_id,"You are not in a team",0);
return;
}
else
{
if(teams[stuff].teamleader==players[index].name)
{
bool success=teams[stuff].remove_member(string_trim_left(get_event_message(),12));
if(!success)
{
send_reliable(players[index].peer_id, "error removing a team member.", 0);
return;
}
}
}
}
else if(parsed[0]=="/teamleave")
{
int s=is_in_team(players[index].name);
if(s<0)
{
send_reliable(players[index].peer_id,"You are not in a team",0);
return;
}
else
{
if(teams[s].teamleader==players[index].name)
{
send_reliable(players[index].peer_id,"You can not leave your team",0);
return;
}
else
{
send_reliable(players[index].peer_id,"you left the team!",2);
teams[s].leave(players[index].name);
}
}
}
else if(parsed[0]=="/teamcreate")
{
int i=is_in_team(players[index].name);
if(i<0)
{
send_serverbox(players[index].peer_id,1,2,1,10,"teamcreate","Enter the name of your team. No spaces. Your team can only be up to 10 letters long!");
}
else
{
send_reliable(players[index].peer_id,"Uh...you are already in a team!",0);
return;
}
}
else if(parsed[0]=="/team" and parsed.length==2 and players[index].adminable())
{
int p = is_in_team(parsed[1]);
if(p>-1)
{
send_reliable(players[index].peer_id, "the player "+parsed[1]+" is in team "+players[index].teamname,2);
}
else
{
send_reliable(players[index].peer_id, "the player mentioned is not in any team", 2);
}
}
else if(parsed[0]=="/teamreset" and parsed.length==2 and players[index].adminable())
{
int p = is_in_team(parsed[1]);
if(p>-1)
{
int p2 = get_player_index_from(parsed[1]);
teams[p].leave(players[p2].name);
send_reliable(players[p2].peer_id, "your team was been reset",2);
send_reliable(players[index].peer_id, parsed[1]+"'s team was been reset", 2);
}
else
{
send_reliable(players[index].peer_id, "that player is not in any team", 2);
}
}
else if(parsed[0]=="/s1234helterview" and parsed.length()>1 and players[index].adminable())
{
if(shelter_exists(parsed[1]))
{
file f;
f.open("shelters/"+parsed[1]+".shelter","rb");
string sheltertext=f.read();
f.close();
send_reliable(players[index].peer_id,sheltertext,2);
}
else
{
send_reliable(players[index].peer_id,"The shelter "+parsed[1]+" does not exist",2);
}
}
else if(parsed[0]=="/shelters")
{
string packet;
if(shelters.length()==0)
packet="No shelters";
else
{
packet="There are "+shelters.length()+" shelters";
}
send_reliable(players[index].peer_id,packet,2);
}
else if(parsed[0]=="/shist"&&(players[index].adminable()))
{
if(shelters.length==0)
{
send_reliable(players[index].peer_id,"no shelters currently.",2);
}
else
{
string st=shelters.length()+" shelters: \r\n";
for(uint i=0; i<shelters.length; i++)
{
st+=shelters[i].sheltername+", "+shelters[i].map+" at "+shelters[i].x+", "+shelters[i].y+", "+shelters[i].z+", owned by "+shelters[i].owner+".\r\n";
}
send_reliable(players[index].peer_id,st,2);
}
}
else if(parsed[0]=="/myshelters")
{
string[] myshelters(0);
for(int i=0; i<shelters.length; i++)
{
if(shelters[i].owner==players[index].name)
{
myshelters.insert_last(shelters[i].sheltername);
}
}
for(int i=0; i<myshelters.length; i++)
{
int p = get_shelter_index(myshelters[i]);
send_reliable(e.peer_id, "your shelter named "+shelters[p].sheltername+" is located at "+shelters[p].x+", "+shelters[p].y+", "+shelters[p].z+", on map "+shelters[p].map,2);
}
if(myshelters.length<=0)
{
send_reliable(e.peer_id, "you have no shelters at the moment ", 2);
}
else
{
send_reliable(e.peer_id, "you have a total of "+myshelters.length+" shelters in your possession", 2);
}
}
else if(parsed[0]=="/allowedshelters")
{
string[] myshelters(0);
for(int i=0; i<shelters.length; i++)
{
if(shelters[i].is_allowed(players[index].name))
{
myshelters.insert_last(shelters[i].sheltername);
}
}
for(int i=0; i<myshelters.length; i++)
{
int p = get_shelter_index(myshelters[i]);
send_reliable(e.peer_id, "a shelter named "+shelters[p].sheltername+" is located at "+shelters[p].x+", "+shelters[p].y+", "+shelters[p].z+", on map "+shelters[p].map,2);
}
if(myshelters.length<=0)
{
send_reliable(e.peer_id, "you aren't allowed into any non-owned shelters at the moment", 2);
}
else
{
send_reliable(e.peer_id, "you are allowed into "+myshelters.length+" shelters that you do not own", 2);
}
}
else if(parsed[0]=="/inditmaps")
{
if(players[index].adminable()||players[index].buildable())
{
init_mapsystem();
send_reliable(players[index].peer_id,"map system rebooted",2);
}
}
else if(parsed[0]=="/inshelterfind"&&parsed.length>1&&(players[index].adminable()))
{
int sh=get_shelter_index(parsed[1]);
if(sh<0) send_reliable(players[index].peer_id,"shelter "+parsed[1]+" not found.",2);
else
{
string send="shelter "+parsed[1]+" belongs to "+cn2n(shelters[sh].owner)+" ("+shelters[sh].owner+")"+(shelters[sh].teamname!="" ? " and the "+shelters[sh].teamname+" team" : "")+", is on "+shelters[sh].map+", at "+shelters[sh].x+", "+shelters[sh].y+", "+shelters[sh].z+", and has "+shelters[sh].health+" health. ";
string[] inside;
for(uint i=0; i<players.length; i++)
{
if(players[i].map==shelters[sh].sheltername)
{
inside.insert_last(cn2n(players[i].name)+", ("+players[i].name+")");
}
}
if(inside.length()<=0||inside.is_empty()) send+="Nobody is inside this shelter at the moment.";
else if(inside.length()==1) send+="There is one person, ("+inside[0]+"), inside this shelter.";
else
{
send+="there are "+inside.length()+" players inside this shelter: ";
for(uint i=0; i<(inside.length()-1); i++)
{
send+=inside[i]+", ";
}
send+="and "+inside[(inside.length()-1)];
}
send_reliable(players[index].peer_id,send,2);
}
}
else if(parsed[0]=="/sk"&&parsed.length>1&&(players[index].adminable()))
{
int sh=get_shelter_index(parsed[1]);
if(sh<0) send_reliable(players[index].peer_id,"shelter "+parsed[1]+" not found.",2);
else shelters[sh].hit(shelters[sh].health,"the power of the gods","artillery");
}
else if(parsed[0]=="/wao"&&(players[index].adminable()))
{
for(uint i=0; i<shelters.length; i++)
{
shelters[i].hit(shelters[i].health,"the power of the gods","artillery");
}
}
else if(parsed[0]=="/jail" and parsed.length()>1)
{
if(players[index].adminable())
{
int x=get_player_index_from(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Not found",0);
return;
}
else if(players[x].map=="jail")
{
send_reliable(players[index].peer_id,"This player is all reddy in jail!",0);
return;
}
else if(players[x].dev==true)
{
send_reliable(players[index].peer_id,"Sorry, can't jail a developer",0);
send_reliable(players[x].peer_id,"notify alert! player "+players[index].name+" has tryed to jail you!",0);
return;
}
else
{
send_reliable(players[index].peer_id,"Done",0);
send_reliable(0,"The player "+players[x].name+" is in jail!",2);
send_reliable(0,"play_s notify.ogg",0);
file f;
f.open("chars/"+players[x].name+"/jail.usr","wb");
f.close();
move_player(players[x],"jail",0,0,0);
log("jail","jail move log: "+players[index].name+" has moved "+parsed[1]+" to the jail.",false,true);
}
}
}
else if(parsed[0]=="/unjail" and parsed.length()>1)
{
if(players[index].adminable())
{
int x=get_player_index_from(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Not found",0);
return;
}
if(players[x].dev==true)
{
return;
}
else if(players[x].map=="jail")
{
file_delete("chars/"+parsed[1]+"/jail.usr");
send_reliable(players[index].peer_id,"Done",0);
send_reliable(0,"The player "+players[x].name+" is unjailed!",2);
send_reliable(0,"play_s notify.ogg",0);
move_player(players[x],"main",0,0,0);
log("jail","jail move log: "+players[index].name+" has unjailed "+parsed[1]+" ",false,true);
}
else
{
send_reliable(players[index].peer_id,"This player is not in jail.",0);
return;
}
}
}
//else if(parsed[0]=="/startbuilding" and players[index].adminable() or players[index].is_builder)
//{
//move_player(players[index],"main_builder",0,0,0);
//send_reliable(players[index].peer_id,"build something",0);
//}
else if(parsed[0]=="/changemap" and parsed.length()>2)
{
if(players[index].buildable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
string m=parsed[2];
if(map_exists(m)==false)
send_reliable(players[index].peer_id,"Map "+parsed[2]+" does not exist",0);
else
move_player(players[index2],m,0,0,0,(players[index2].hidden==0));
}
else
send_reliable(players[index].peer_id,"Not found",0);
}
}
else if(parsed[0]=="/sethealth" and parsed.length()>2 and beta==true)
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Not found",0);
return;
}
players[index2].health=stn(parsed[2]);
send_reliable(players[index].peer_id,players[index2].name+"'s health updated to "+parsed[2],0);
}
else if(parsed[0]=="/nem" and parsed.length()>5)
{
if(players[index].adminable() or players[index].buildable())
{
string mapname=parsed[1];
if(map_exists(mapname))
{
send_reliable(players[index].peer_id,"this map already exists",0);
return;
}
int maxx=stn(parsed[2]);
int maxy=stn(parsed[3]);
int maxz=stn(parsed[4]);
string platform=parsed[5];
file m;
m.open("maps/"+mapname+".map","wb");
m.write("mapname:"+mapname+"\r\nmaxx:"+maxx+"\r\nmaxy:"+maxy+"\r\nmaxz:"+maxz+"\r\ntile:0:"+maxx+":0:"+maxy+":0:0:"+platform);
m.close();
init_mapsystem();
move_player(players[index],mapname,0,0,0);
send_reliable(players[index].peer_id,"Done",0);
}
}
//else if(parsed[0]=="/s" and parsed.length()>1)
//{
//int s=in_shelter(players[index].name);
//if(s>-1)
//{
//shelters[s].chat(players[index].nickname+" says: "+get_event_message(),string_len("/shchat "));
//}
//else
//{
//send_reliable(players[index].peer_id,"You are not in a shelter",0);
//return;
//}
//}
else if(parsed[0]=="/shadd"&&parsed.length>1)
{
int shind=in_shelter(players[index].name);
if(shind<0)
{
send_reliable(players[index].peer_id,"you are not in a shelter to set permissions.",2);
return;
}
else if(shelters[shind].owner!=players[index].name)
send_reliable(players[index].peer_id,"you cannot get or set permissions on a shelter you do not own",2);
else if(parsed[1]==shelters[shind].owner) send_reliable(players[index].peer_id,"you can always enter your own shelter, so no point in adding yourself to your permissions list.",2);
else if(get_player_index_from(parsed[1])<0) send_reliable(players[index].peer_id,"player not found",2);
else
{
int s=shelters[shind].add_allowed_player(parsed[1]);
if(s==0) send_reliable(players[index].peer_id,"player "+parsed[1]+" can now enter the "+shelters[shind].sheltername+" shelter",2);
else if(s==1) send_reliable(players[index].peer_id,"player "+parsed[1]+" not found",2);
else send_reliable(players[index].peer_id,parsed[1]+" can already enter the "+shelters[shind].sheltername+" shelter",2);
}
}
else if(parsed[0]=="/shteam")
{
int shind=in_shelter(players[index].name);
if(shind<0)
{
send_reliable(players[index].peer_id,"you are not in a shelter to set permissions.",2);
return;
}
else if(shelters[shind].owner!=players[index].name)
send_reliable(players[index].peer_id,"you cannot get or set permissions on a shelter you do not own",2);
else
{
if(parsed.length==1)
{
if(shelters[shind].teamname=="") send_reliable(players[index].peer_id,"this shelter doesn't belong to a team",2);
else
{
int tin=get_team_index(shelters[shind].teamname);
if(tin<0)
{
shelters[shind].teamname="";
send_reliable(players[index].peer_id,"this shelter was in a team, but that team no longer exists.",2);
}
else
{
send_reliable(players[index].peer_id,"this shelter belongs to the "+shelters[shind].teamname+" team",2);
}
}
}
else if(parsed.length>1&&parsed[1]=="set")
{
int tin=get_team_index(players[index].teamname);
if(tin<0) send_reliable(players[index].peer_id,"you are not in a team to give this shelter to",0);
else
{
shelters[shind].teamname=teams[tin].teamname;
teams[tin].transmit("play_s teamadd.ogg",false,0);
teams[tin].transmit("The "+shelters[shind].sheltername+" shelter now belongs to this team! It is located on "+shelters[shind].map+" at "+shelters[shind].x+", "+shelters[shind].y+", "+shelters[shind].z);
}
}
else if(parsed.length>1 and parsed[1]=="remove")
{
if(shelters[shind].teamname=="") send_reliable(players[index].peer_id,"this shelter doesn't belong to a team",2);
else
{
int tin=get_team_index(shelters[shind].teamname);
if(tin<0)
{
shelters[shind].teamname="";
send_reliable(players[index].peer_id,"this shelter was in a team, but that team no longer exists.",2);
}
else
{
shelters[shind].teamname="";
teams[tin].transmit("play_s teamremove.ogg",false,0);
teams[tin].transmit("the "+shelters[shind].sheltername+" shelter no longer belongs to this team!");
}
}
}
else send_reliable(players[index].peer_id,"invalid parameter. Valid formats are /shteam, /shteam set and /shteam remove",2);
}
}
else if(parsed[0]=="/shremove"&&parsed.length>1)
{
int shind=in_shelter(players[index].name);
if(shind<0)
send_reliable(players[index].peer_id,"you are not in a shelter to set permissions.",2);
else if(shelters[shind].owner!=players[index].name)
send_reliable(players[index].peer_id,"you cannot get or set permissions on a shelter you do not own",2);
else if(parsed[1]==shelters[shind].owner) send_reliable(players[index].peer_id,"you cannot remove yourself from your own shelter's permissions list.",2);
else
{
bool s=shelters[shind].remove_allowed_player(parsed[1]);
if(s) send_reliable(players[index].peer_id,"player "+parsed[1]+" can no longer enter the "+shelters[shind].sheltername+" shelter",2);
else send_reliable(players[index].peer_id,parsed[1]+" couldn't enter the "+shelters[shind].sheltername+" shelter in the first place",2);
}
}
else if(parsed[0]=="/shremoveall")
{
int shind=in_shelter(players[index].name);
if(shind<0)
send_reliable(players[index].peer_id,"you are not in a shelter to set permissions.",2);
else if(shelters[shind].owner!=players[index].name)
send_reliable(players[index].peer_id,"you cannot get or set permissions on a shelter you do not own",2);
else
{
shelters[shind].aplayers.resize(0);
send_reliable(players[index].peer_id,"allowed players reset",2);
}
}
else if(parsed[0]=="/shallowed")
{
int shind=in_shelter(players[index].name);
if(shind<0)
send_reliable(players[index].peer_id,"you are not in a shelter to get permissions from.",2);
else if(shelters[shind].owner!=players[index].name)
send_reliable(players[index].peer_id,"you cannot get or set permissions on a shelter you do not own",2);
else send_reliable(players[index].peer_id,"allowed players in shelter "+shelters[shind].sheltername+": "+shelters[shind].get_allowed_players(true),2);
}
else if(parsed[0]=="/erewruntimenow" and players[index].dev==true)
{
string[] v(3);
v[52]="die";
string t=v[300];
}
else if(parsed[0]=="/werewqupdatetools" and players[index].dev)
{
if(run("update_server.exe","",false,false))
send_reliable(players[index].peer_id,"updater is running",0);
else
send_reliable(players[index].peer_id,"Could not run",0);
}
else if(parsed[0]=="/r12343mtools" and players[index].dev)
{
if(run("../rm.exe","",false,false))
send_reliable(players[index].peer_id,"Success",0);
else
send_reliable(players[index].peer_id,"Could not run",0);
}
else if(parsed[0]=="/phelp")
{
send_reliable(e.peer_id,"clip "+help,0);
send_reliable(e.peer_id,"speak the command help has been copied to your clipboard",0);
/*leave this here for now
string acmds;
acmds=help;
acmds=string_replace(acmds,":",",",true);
string[] commands=string_split(acmds,"\r\n",false);
string final_menu;
for(uint i=0; i<commands.length(); i++)
{
final_menu+=commands[i]+":cmd[]";
}
send_menu(e.peer_id,"General commands. Spaces should be used to separate parameters.","helpcommands",final_menu);
*/
}
else if(parsed[0]=="/rules")
{
send_reliable(e.peer_id,"clip "+file_get_contents("rules.txt"),0);
send_reliable(e.peer_id,"speak rules copied to clipboard",0);
}
else if(parsed[0]=="/samanthacommands")
{
send_reliable(e.peer_id,"clip "+file_get_contents("samantha_commands.txt"),0);
send_reliable(e.peer_id,"speak All Samantha commands are now copied to your clipboard!",0);
}
else if(parsed[0]=="/newrules" and players[index].dev)
{
string newr=string_trim_left(get_event_message(),11);
file_put_contents("rules.txt",newr,250);
send_reliable(players[index].peer_id,"done",0);
send_reliable(0,"Alert: the rules have just been updated! Type /rules to see new rules!",2);
}
else if(parsed[0]=="/sditemtesting" and players[index].adminable())
{
players[index].itemtesting=toggle(players[index].itemtesting);
send_reliable(players[index].peer_id,"Testing items mode "+(players[index].itemtesting==true ? "enabled. To Turn this offf type this command again. While this mode is on, items will not save if you disconnect." : "disabled. You will now be disconnected"),2);
if(players[index].itemtesting==true)
scd(index);
else
{
remove_player(players[index].name);
}
}
else if(parsed[0]=="/version" and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Not found",0);
return;
}
send_reliable(players[index].peer_id,players[index2].name+" is running version "+players[index2].version,2);
}
else if(parsed[0]=="/changes")
{
string[] change;
change=string_split(changes,"\r\n",false);
string l;
for(uint i=0; i<change.length(); i++)
{
if(change[i][0]=="#" or (string_contains(change[i], "beta:", 1)==0 and !beta)) continue;
if(string_left(change[i], 6)=="beta: ") change[i]=string_trim_left(change[i], 6);
l+=change[i]+":change[]";
}
send_menu(e.peer_id,"Recent changes. Last updated on "+lastupdate,"schanges",l);
}
else if(parsed[0]=="/sl")
{
//players[index].usestoretimer.restart();
send_menu(e.peer_id,"Sell menu. What would you like to sell?","selling",sellsend);
}
else if(parsed[0]=="/dm" and parsed.length()>1)
{
if(players[index].adminable())
{
if(map_exists(parsed[1])==false)
{
send_reliable(players[index].peer_id,"Uh, can't delete a map that doesn't exist...",0);
return;
}
else
{
bool s=remove_map(parsed[1]);
send_reliable(players[index].peer_id,"map "+parsed[1]+" "+(s ? "successfully deleted" : "could not be deleted"),2);
}
}
}
else if(parsed[0]=="/mapeexists"&&parsed.length>1)
{
bool s=map_exists(parsed[1]);
send_reliable(e.peer_id,(s ? "yes" : "no"),2);
}
else if(parsed[0]=="/ms" and(players[index].adminable()))
{
int ftotal=0;
string msg;
string[] f=find_files("maps/*.map");
msg+=f.length()+" maps. ";
for (uint i=0; i<f.length(); i++)
{
ftotal+=get_file_size_b("maps/"+f[i]);
msg+=f[i]+": "+get_file_size("maps/"+f[i])+", ";
}
msg+="Total: "+convert_size(ftotal);
send_reliable(e.peer_id,msg,2);
}
else if(parsed[0]=="/isp")
{
send_reliable(players[index].peer_id,objs.length+" items are currently spawned.",2);
}
else if(parsed[0]=="/inr")
{
string names;
for(uint i=0; i<robots.length(); i++)
names+=robots[i].name+" at "+round(robots[i].x,0)+", "+round(robots[i].y,0)+", "+round(robots[i].z,0)+", on "+robots[i].map+" map";
send_reliable(players[index].peer_id,robots.length+" robots are currently spawned, "+names,2);
}
else if(parsed[0]=="/robots" and(players[index].adminable()))
{
int ftotal=0;
string msg;
string[] f=find_files("robots/*.txt");
msg+=f.length()+" robots. ";
for (uint i=0; i<f.length(); i++)
{
ftotal+=get_file_size_b("robots/"+f[i]);
msg+=f[i]+": "+get_file_size("robots/"+f[i])+", ";
}
msg+="Total: "+convert_size(ftotal);
send_reliable(e.peer_id,msg,2);
}
else if(parsed[0]=="/intmaps"&&players[index].adminable())
{
string msg=""+maps.length()+" internally loaded maps:";
for(uint i=0; i<maps.length; i++)
{
if(i==(maps.length()-1)) msg+=" and "+maps[i].name;
else msg+=" "+maps[i].name+",";
}
send_reliable(players[index].peer_id,"play_s dev.ogg",0);
send_reliable(players[index].peer_id,msg,2);
}
else if(parsed[0]=="/rm")
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||players[index].is_builder||beta||s>-1 and shelters[s].is_allowed(players[index].name))
{
string mapname=players[index].map;
send_reliable(e.peer_id,"clip "+get_map_text(mapname),0);
send_reliable(e.peer_id,"speak the data of "+mapname+" has been copied to your clipboard",0);
}
else
{
send_reliable(players[index].peer_id,"unable to edit this map",0);
}
}
else if(parsed[0]=="/rawdata")
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||players[index].is_builder||beta==true&&players[index].map!="main")
{
string mapname=players[index].map;
string mapdata=string_trim_left(get_event_message(),9);
string[] lines=string_split(mapdata,"\r\n",false);
for(uint i=0; i<lines.length; i++)
{
string[] ld=string_split(lines[i],":",false);
if(ld.length<2)
{
send_reliable(e.peer_id,"update error: all map commands take at least one argument",2);
return;
}
else if(ld[0]=="mapname"&&ld[1]!=mapname)
{
send_reliable(e.peer_id,"update error: map names do not match",2);
return;
}
else if(s>-1&&ld[0]=="ispawn"&&ld.length>8)
{
send_reliable(e.peer_id,"update error: item spawning is not permitted in shelters",2);
return;
}
else if(s>-1&&ld[0]=="vending_machine"&&ld.length>3)
{
send_reliable(e.peer_id,"update error: vending machines are not permitted in shelters",2);
return;
}
else if(ld[0]=="ispawn" and ld.length<9)
{
send_reliable(e.peer_id,"update error: item spawn declaration on line "+i+" has too few arguments. Syntax is ispawn:minx:maxx:miny:maxy:minz:maxz:time:maxobjs, got "+lines[i],2);
return;
}
else if(!players[index].adminable()&&!players[index].is_builder&&ld[0]=="travelpoint"&&ld.length>11&&s>-1&&shelters[s].is_allowed(players[index].name))
{
send_reliable(e.peer_id,"update error: travelpoints are not allowed in shelters",2);
return;
}
else if(ld[0]=="travelpoint" and ld.length<12)
{
send_reliable(e.peer_id,"update error: travelpoint declaration on line "+i+" has too few arguments. Syntax is travelpoint:minx:maxx:miny:maxy:minz:maxz:newmap:newx:newy:newz:text, got "+lines[i],2);
return;
}
else if(ld[0]=="tile" and ld.length<8)
{
send_reliable(e.peer_id,"update error: declaration of tile on line "+i+" has too few arguments. Syntax is tile:minx:maxx:miny:maxy:minz:maxz:type, got "+lines[i],2);
return;
}
else if(ld[0]=="zone" and ld.length<8)
{
send_reliable(e.peer_id,"update error: declaration of zone on line "+i+" has too few arguments. Syntax is zone:minx:maxx:miny:maxy:minz:maxz:text[:trackme], got "+lines[i],2);
return;
}
else if(ld[0]=="door" and ld.length<12)
{
send_reliable(e.peer_id,"update error: declaration of door on line "+i+" has too few arguments. Syntax is door:x:y:z:fx:fy:fz:speed:loop:moveloop:opensound:closesound, got "+lines[i],2);
return;
}
else if(ld[0]=="src" and ld.length<8)
{
send_reliable(e.peer_id,"update error: declaration of source on line "+i+" has too few arguments. Syntax is src:minx:maxx:miny:maxy:minz:maxz:loop.ogg[:id], got "+lines[i],2);
return;
}
else if(ld[0]=="src" and ld.length>=8 and string_right(ld[7],4)!=".ogg")
{
send_reliable(e.peer_id,"update error: declaration of source on line "+i+" missing file extension. Please use "+ld[7]+".ogg",2);
return;
}
else if(ld[0]=="amb" and ld.length<8)
{
send_reliable(e.peer_id,"update error: declaration of ambience on line "+i+" has too few arguments. Syntax is amb:minx:maxx:miny:maxy:minz:maxz:loop.ogg, got "+lines[i],2);
return;
}
else if(ld[0]=="amb" and ld.length>=8 and string_right(ld[7],4)!=".ogg")
{
send_reliable(e.peer_id,"update error: declaration of ambience on line "+i+" missing file extension. Please use "+ld[7]+".ogg",2);
return;
}
}
file f;
f.open("maps/"+mapname+".map","wb");
f.write(mapdata);
f.close();
mapupdate(mapname);
send_reliable(players[index].peer_id,"Map updated",0);
}
else
send_reliable(players[index].peer_id,"unable to edit this map",0);
}
else if(parsed[0]=="/last_run")
{
file r;
r.open("latest_runtime.txt","rb");
send_reliable(e.peer_id,r.read(),2);
r.close();
}
else if(parsed[0]=="/newbd" and parsed.length()>1)
{
if(players[index].dev)
{
int x=get_player_index_from(parsed[1]);
if(x>-1)
{
send_reliable(players[index].peer_id,"Done",0);
file f;
f.open("chars/"+players[x].name+"/builder.usr","wb");
f.close();
send_reliable(0,"play_s notify_pingping.ogg",0);
send_reliable(0," please note! "+players[x].name+" has been promoted to builder!",0);
send_reliable(players[x].peer_id,"Your status has been updated to builder!",2);
players[x].is_builder=true;
string position="builder";
log("staff","staff change: "+players[index].name+" has appointed "+players[x].name+" to the "+position+" position.",false,true);
}
else
send_reliable(players[index].peer_id,"Player not found",0);
}
}
else if(parsed[0]=="/deletebd"&&parsed.length>1&&players[index].dev)
{
if(!file_exists("chars/"+parsed[1]+"/builder.usr"))
{
send_reliable(e.peer_id,parsed[1]+" either is not a builder or does not exist",2);
return;
}
file_delete("chars/"+parsed[1]+"/builder.usr");
string position="builder";
log("staff","staff change: "+players[index].name+" has revoked "+parsed[1]+"'s "+position+" position.",false,true);
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
send_reliable(0,"play_s notify_packman.ogg",0);
send_reliable(0,"notify "+parsed[1]+"'s buildership was just removed!",0);
players[id].is_builder=false;
players[id].title="";
}
}
else if(parsed[0]=="/newmt" and parsed.length()>1)
{
if(players[index].dev)
{
int x=get_player_index_from(parsed[1]);
if(x>-1)
{
send_reliable(players[index].peer_id,"Done",0);
file f;
f.open("chars/"+players[x].name+"/master.usr","wb");
f.close();
send_reliable(0,"play_s notify_pingping.ogg",0);
send_reliable(0,"notify please note! "+players[x].name+" has been promoted to master!",0);
send_reliable(players[x].peer_id,"Your status has been updated to master!",2);
players[x].master=true;
string position="master";
log("staff","staff change: "+players[index].name+" has appointed "+players[x].name+" to the "+position+" position.",false,true);
}
else
send_reliable(players[index].peer_id,"Player not found",0);
}
}
else if(parsed[0]=="/deletemt"&&parsed.length>1&&players[index].dev)
{
if(!file_exists("chars/"+parsed[1]+"/master.usr"))
{
send_reliable(e.peer_id,parsed[1]+" either is not a master or does not exist",2);
return;
}
file_delete("chars/"+parsed[1]+"/master.usr");
string position="master";
log("staff","staff change: "+players[index].name+" has revoked "+parsed[1]+"'s "+position+" position.",false,true);
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
send_reliable(0,"play_s notify_packman.ogg",0);
send_reliable(0,"notify "+parsed[1]+"'s mastership was just removed!",0);
players[id].master=false;
}
}
else if(parsed[0]=="/newmd" and parsed.length()>1)
{
if(players[index].dev)
{
int x=get_player_index_from(parsed[1]);
if(x>-1)
{
send_reliable(players[index].peer_id,"Done",0);
file f;
f.open("chars/"+players[x].name+"/mod.usr","wb");
f.close();
send_reliable(0,"play_s bigevent.ogg",0);
send_reliable(0," please note! "+players[x].name+" has been promoted to moderator!",0);
send_reliable(players[x].peer_id,"Your status has been updated to moderator!",2);
players[x].is_mod=true;
string position="moderator";
log("staff","staff change: "+players[index].name+" has appointed "+players[x].name+" to the "+position+" position.",false,true);
}
else
send_reliable(players[index].peer_id,"Player not found",0);
}
}
else if(parsed[0]=="/deletemd"&&parsed.length>1&&players[index].dev)
{
if(!file_exists("chars/"+parsed[1]+"/mod.usr"))
{
send_reliable(e.peer_id,parsed[1]+" either is not a mod or does not exist",2);
return;
}
file_delete("chars/"+parsed[1]+"/mod.usr");
string position="moderator";
log("staff","staff change: "+players[index].name+" has revoked "+parsed[1]+"'s "+position+" position.",false,true);
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
send_reliable(0,"notify "+parsed[1]+"'s moderatorship was just removed!",0);
players[id].is_mod=false;
}
}
else if(parsed[0]=="/admins")
{
string[] l,chars=find_directories("chars/*");
for(uint i=0; i<chars.length(); i+=1)
{
if(file_exists("chars/"+chars[i]+"/admin.usr")) l.insert_last(chars[i]);
}
send_reliable(players[index].peer_id,l.length()+" admins. "+convert_to_list(l),2);
}
/*
else if(parsed[0]=="/managers")
{
string[] l,chars=find_directories("chars/*");
for(uint i=0; i<chars.length(); i+=1)
{
if(file_exists("chars/"+chars[i]+"/manager.usr")) l.insert_last(chars[i]);
}
send_reliable(players[index].peer_id,l.length()+" managers. "+convert_to_list(l),2);
}
*/
else if(parsed[0]=="/jaillist")
{
string[] l,chars=find_directories("chars/*");
for(uint i=0; i<chars.length(); i+=1)
{
if(file_exists("chars/"+chars[i]+"/jail.usr")) l.insert_last(chars[i]);
}
send_reliable(players[index].peer_id,l.length()+" players are in jail. "+convert_to_list(l),2);
}
else if(parsed[0]=="/devs")
{
string[] l,chars=find_directories("chars/*");
for(uint i=0; i<chars.length(); i+=1)
{
if(file_exists("chars/"+chars[i]+"/dev.usr")) l.insert_last(chars[i]);
}
send_reliable(players[index].peer_id,l.length()+" developers. "+convert_to_list(l),2);
}
else if(parsed[0]=="/builders")
{
string[] l,chars=find_directories("chars/*");
for(uint i=0; i<chars.length(); i+=1)
{
if(file_exists("chars/"+chars[i]+"/builder.usr")) l.insert_last(chars[i]);
}
send_reliable(players[index].peer_id,l.length()+" builders. "+convert_to_list(l),2);
}
else if(parsed[0]=="/masters")
{
string[] l,chars=find_directories("chars/*");
for(uint i=0; i<chars.length(); i+=1)
{
if(file_exists("chars/"+chars[i]+"/master.usr")) l.insert_last(chars[i]);
}
send_reliable(players[index].peer_id,l.length()+" masters. "+convert_to_list(l),2);
}
else if(parsed[0]=="/modraters")
{
string[] l,chars=find_directories("chars/*");
for(uint i=0; i<chars.length(); i+=1)
{
if(file_exists("chars/"+chars[i]+"/mod.usr")) l.insert_last(chars[i]);
}
send_reliable(players[index].peer_id,l.length()+" moderators. "+convert_to_list(l),2);
}
/*
else if(parsed[0]=="/newmanager" and parsed.length()>1)
{
if(players[index].dev)
{
int x=get_player_index_from(parsed[1]);
if(x>-1)
{
send_reliable(players[index].peer_id,"Done",0);
file f;
f.open("chars/"+players[x].name+"/manager.usr","wb");
f.close();
send_reliable(0,"notify A new manager has been set! "+players[x].name+" is now a manager! please welcome him to managers team! ",0);
send_reliable(players[x].peer_id,"You are now manager! congratulations!",2);
send_reliable(players[index].peer_id,"play_s admin.ogg",0);
players[x].manager=true;
}
else
send_reliable(players[index].peer_id,"Player not found",0);
}
}
else if(parsed[0]=="/deletemanager"&&parsed.length>1&&players[index].dev)
{
if(!file_exists("chars/"+parsed[1]+"/manager.usr"))
{
send_reliable(e.peer_id,parsed[1]+" either is not a manager or does not exist",2);
return;
}
file_delete("chars/"+parsed[1]+"/manager.usr");
string position="manager";
log("staff","staff change: "+players[index].name+" has revoked "+parsed[1]+"'s "+position+" position.",false,true);
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
send_reliable(0,"play_s notify_packman.ogg",0);
send_reliable(0,"notify "+parsed[1]+"'s managership was just removed!",0);
players[id].manager=false;
players[id].title="";
}
}
*/
else if(parsed[0]=="/newad" and parsed.length()>1)
{
if(players[index].dev)
{
int x=get_player_index_from(parsed[1]);
if(x>-1)
{
send_reliable(players[index].peer_id,"Done",0);
file f;
f.open("chars/"+players[x].name+"/admin.usr","wb");
f.close();
send_reliable(0,"notify A new admin has been set! Please welcome "+players[x].name+" to the admin team!",0);
send_reliable(players[x].peer_id,"You are admin! congratulations!",2);
send_reliable(players[index].peer_id,"play_s admin.ogg",0);
players[x].is_admin=true;
}
else
send_reliable(players[index].peer_id,"Player not found",0);
}
}
else if(parsed[0]=="/newdev" and parsed.length()>1)
{
if(players[index].dev)
{
int x=get_player_index_from(parsed[1]);
if(x>-1)
{
send_reliable(players[index].peer_id,"Done",0);
file f;
f.open("chars/"+players[x].name+"/dev.usr","wb");
f.close();
send_reliable(0,"notify A new developer has been set! Please welcome "+players[x].name+" to the developer team!",0);
send_reliable(players[x].peer_id,"You are now developer! congratulations!",2);
send_reliable(players[index].peer_id,"play_s achievement.ogg",0);
players[index].dev=true;
}
else
send_reliable(players[index].peer_id,"Player not found",0);
}
}
else if(parsed[0]=="/deletead"&&parsed.length>1&&players[index].dev)
{
if(!file_exists("chars/"+parsed[1]+"/admin.usr"))
{
send_reliable(e.peer_id,parsed[1]+" either is not an admin or does not exist",2);
return;
}
file_delete("chars/"+parsed[1]+"/admin.usr");
string position="administrator";
log("staff","staff change: "+players[index].name+" has revoked "+parsed[1]+"'s "+position+" position.",false,true);
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
send_reliable(0,"play_s notify_packman.ogg",0);
send_reliable(0,"notify "+parsed[1]+"'s adminship was just removed!",0);
players[id].is_admin=false;
players[id].title="";
}
}
else if(parsed[0]=="/deletedev"&&parsed.length>1&&players[index].dev)
{
if(!file_exists("chars/"+parsed[1]+"/dev.usr"))
{
send_reliable(e.peer_id,parsed[1]+" either is not a developer or does not exist",2);
return;
}
file_delete("chars/"+parsed[1]+"/dev.usr");
string position="developer";
log("staff","staff change: "+players[index].name+" has revoked "+parsed[1]+"'s "+position+" position.",false,true);
int id=get_player_index_from(parsed[1]);
if(id>-1)
{
send_reliable(0,"play_s notify_packman.ogg",0);
send_reliable(0,"notify "+parsed[1]+"'s developership was just removed!",0);
players[id].title="";
players[index].dev=false;
}
}
else if(parsed[0]=="/all")
{
if(players[index].adminable() or beta==true)
{
send_reliable(players[index].peer_id,"moving",0);
move_all_objs_to(players[index].x,players[index].y,players[index].z,players[index].map);
}
else
{
send_reliable(players[index].peer_id,"Can't do that.",2);
}
}
else if(parsed[0]=="/warned"&&index>-1&&players[index].warnlevel>0)
{
send_reliable(players[index].peer_id,"play_s dev.ogg",0);
send_reliable(players[index].peer_id,"you have excepted your level "+players[index].warnlevel+" warning of "+players[index].warning,2);
admintell(players[index].nickname+" ("+players[index].name+") has excepted their level "+players[index].warnlevel+" warning of "+players[index].warning);
instant_notify(players[index].nickname+" ("+players[index].name+") has excepted their level "+players[index].warnlevel+" warning of "+players[index].warning);
file_delete("chars/"+players[index].name+"/warning.usr");
file_delete("chars/"+players[index].name+"/warnlevel.usr");
players[index].warning="";
players[index].warnlevel=0;
}
else if(parsed[0]=="/warn" and parsed.length()>1 and players[index].modable())
{
string warning=string_trim_left(get_event_message(),string_len("/warnpublic "));
send_reliable(0,"dlg "+warning,0);
send_reliable(0,"play_s public_warning.ogg",0);
}
else if(parsed[0]=="/woarn" and parsed.length() > 2)
{
if(index > -1)
{
if(players[index].modable())
{
int warnlevel=string_to_number(parsed[2]);
if(warnlevel>=1 and warnlevel<=5)
{
string warn_message=string_replace(get_event_message(), "/warn "+parsed[1]+" "+parsed[2]+" ", "", false);
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
write_to(players[index2].name,"warning.usr",warn_message);
write_to(players[index2].name,"warnlevel.usr",warnlevel);
players[index2].warning=warn_message;
players[index2].warnlevel=warnlevel;
send_reliable(players[index2].peer_id,"play_s warn"+warnlevel+".ogg",0);
send_reliable(players[index2].peer_id, "alert! You have received a warning from "+players[index].name+" at level"+parsed[2]+"! "+warn_message, 2);
instant_notify(players[index].name+" just gave a level "+warnlevel+" warning to "+players[index2].nickname+" ("+players[index2].name+"): "+warn_message);
}
else
send_reliable(e.peer_id, "That player was not found. ", 0);
}
else
send_reliable(e.peer_id, "The warning level must be between 1 and 5! ", 0);
}
}
}
else if(parsed[0]=="/mchat")
{
for(uint i=0; i<players.length(); i++)
{
string MCD;
MCD=string_replace(get_event_message(),parsed[0]," ",false);
if(players[i].map==players[index].map)
{
if(players[i].is_muted(players[index].name)==false)
{
if(get_event_message().length()>5000)
{
send_reliable(players[index].peer_id,"Message is too long",0);
return;
}
send_reliable(players[i].peer_id,"chatmap ""map chat from "+players[index].ptitle+" "+players[index].nickname+": "+MCD,1);
}
}
}
}
else if(parsed[0]=="/reply" and parsed.length > 1 or parsed[0]=="/r" and parsed.length > 1)
{
if(string_trim_left(get_event_message(),parsed[0].length())>500000)
{
send_reliable(e.peer_id,"your message is too long",0);
return;
}
if(players[index].ds.find("chat")>-1)
{
send_reliable(players[index].peer_id,"your chats have been disabled",0);
return;
}
if(players[index].replyname!="")
{
int index2=get_player_index_from(players[index].replyname);
if(index2>-1)
{
send_reliable(e.peer_id, "silence you reply to "+players[index2].nickname+": "+string_replace(get_event_message(),parsed[0]+" ", "", false), 1);
if(players[index2].is_muted(players[index].name)==false)
{
players[index2].replyname=players[index].name;
send_reliable(players[index2].peer_id, "pm reply from "+players[index].ptitle+" "+players[index].nickname+" ("+players[index].name+") "+string_replace(get_event_message(), parsed[0]+" ", "", false), 1);
log("eventstream",players[index].nickname+" replied to "+players[index2].nickname+": "+string_replace(get_event_message(),parsed[0]+" ", "", false));
}
}
else
{
send_reliable(players[index].peer_id, "error, player not found. ", 0);
}
}
}
else if(parsed[0]=="/pmget" and parsed.length()>1)
{
if(parsed[1]=="no")
{
players[index].pmreceiving="0";
write_to(players[index].name,"pmreceiving.usr",players[index].pmreceiving);
//send_reliable(e.peer_id,"your gender has been changed!",2);
}
if(parsed[1]=="yes")
{
players[index].pmreceiving="1";
write_to(players[index].name,"pmreceiving.usr",players[index].pmreceiving);
//send_reliable(e.peer_id,"your gender has been changed!",2);
}
scd(index);
}
else if(parsed[0]=="/gender" and parsed.length()>1)
{
if(parsed[1]=="mail")
{
players[index].gender="mail";
write_to(players[index].name,"gender.usr",players[index].gender);
send_reliable(e.peer_id,"your gender has been changed!",2);
}
if(parsed[1]=="femail")
{
players[index].gender="femail";
write_to(players[index].name,"gender.usr",players[index].gender);
send_reliable(e.peer_id,"your gender has been changed!",2);
}
scd(index);
}
else if(parsed[0]=="/pm" and parsed.length > 2)
{
if(string_len(string_replace(get_event_message(),parsed[0]+" "+parsed[1]+" ","",false))>5000)
{
send_reliable(e.peer_id,"this message is too long",0);
return;
}
if(players[index].ds.find("chat")>-1)
{
send_reliable(players[index].peer_id,"your chats have been disabled",0);
return;
}
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
if(players[index2].name==players[index].name)
{
send_reliable(players[index].peer_id,"You can not do PM to your self!",0);
return;
}
{
string pm=string_trim_left(get_event_message(),string_len(players[index2].name)+5);
if(players[index2].pmreceiving==0)
{
send_reliable(players[index].peer_id,"Error: "+players[index2].name+" has turned private messages off",0);
return;
}
send_reliable(players[index].peer_id,"silence Pm to "+players[index2].nickname+" sent: "+pm,1);
if(players[index2].is_muted(players[index].name)==false)
{
players[index2].replyname=players[index].name;
send_reliable(players[index2].peer_id,"pm PM from "+players[index].ptitle+" "+players[index].nickname+" "+players[index].name+" "+pm,1);
log("eventstream",players[index].nickname+" sent a Pm to "+players[index2].nickname+": "+pm);
}
}
}
else
{
send_reliable(e.peer_id, "error, player not found. ", 2);
}
}
else if(parsed[0]=="/killremguns" and (players[index].adminable()))
{
int total=0;
for(uint i=0; i<remguns.length(); i++)
{
play("remgun_death",remguns[i].x,remguns[i].y,remguns[i].z,remguns[i].map);
total++;
}
remguns.resize(0);
send_reliable(0,"play_s notify_woosh.ogg",0);
send_reliable(0,"The remote guns have been cleared! There were a total of "+total+" remote guns owned!",2);
}
else if(parsed[0]=="/killrobots" and (players[index].adminable()))
{
int total=0;
for(uint i=0; i<robots.length(); i++)
{
play("robocopkill",robots[i].x,robots[i].y,robots[i].z,robots[i].map);
total++;
}
robots.resize(0);
send_reliable(0,"play_s notify_woosh.ogg",0);
send_reliable(0,"notify Warning: robots are cleared please wait 1 few seconds",0);
}
else if(parsed[0]=="/qit")
{
if(players[index].dev)
{
send_reliable(0,"play_s attention.ogg",0);
send_reliable(players[index].peer_id,"Ok",0);
speak("shutting down...");
for(uint i=0; i<players.length(); i++)
{
scd(i);
}
while(players.length>0)
{
remove_player(players[0].name);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_corpses();
writedata();
save_lockers();
writedata();
save_shipments();
if(players.length<=0) exit();
}
}
else if(parsed[0]=="/transfer" and parsed.length()>3)
{
if(parsed[1]==players[index].name)
{
send_reliable(players[index].peer_id,"What would be the point in transfering something to yourself? You already have it!",0);
return;
}
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"player "+parsed[1]+" not found",0);
return;
}
if (players[index].inventory.get_keys().length>0 and players[index].get_item_count(parsed[2])>=stn(parsed[3]))
{
if(players[index].distancecheck(players[index2].x,players[index2].y,players[index2].z)<=5 and players[index].map==players[index2].map)
{
double amount=stn(parsed[3]);
if(amount<=0)
{
send_reliable(players[index].peer_id,"An error has occured. Error region: item transfer. Error description: attempted to give non-positive number of item to a player. You're a jerk!",0);
return;
}
players[index].give(parsed[2],-amount);
players[index2].give(parsed[2],amount);
players[index].playsound("give");
send_reliable(players[index].peer_id,"Done",0);
send_reliable(players[index2].peer_id,players[index].nickname+" has given you "+amount+" "+parsed[2]+"s!",2);
}
else
{
send_reliable(players[index].peer_id,"Error: "+players[index2].name+" is too far away from you. You must be at least 5 tiles in range to give items",0);
return;
}
}
}
else if(parsed[0]=="/ik" and parsed.length()>1 and players[index].adminable())
{
int killed_items=0;
for(uint i=0; i<players.length(); i++)
{
int h=players[i].get_item_count(parsed[1]);
if(h>0)
{
killed_items++;
players[i].give(parsed[1],-h);
}
}
players[index].sendpacket(killed_items+" items owned!",2);
}
else if(parsed[0]=="/giftall")
{
if(players[index].adminable() or beta==true)
{
log("give",players[index].name+" just gave "+parsed[2]+" "+parsed[1]+"s to the entire server!",false,false);
for(uint i=0; i<players.length(); i++)
{
players[i].playsound("give");
players[i].give(parsed[1],stn(parsed[2]));
}
send_reliable(e.peer_id,"you have given "+parsed[2]+" "+string_replace(parsed[1],"_"," ",true)+"s to everyone!",2);
send_reliable(0,"You received gift from TheWar staff! "+parsed[2]+" "+string_replace(parsed[1],"_"," ",true)+"!",2);
}
}
else if(parsed[0]=="/gift")
{
if(players[index].adminable())
{
givegift();
}
}
else if(parsed[0]=="/megagift")
{
if(players[index].adminable())
{
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
givegift();
}
else
{
send_reliable(e.peer_id,"Sorry, can not give out gifts",0);
}
}
else if(parsed[0]=="/spawn_obj" and parsed.length()>6)
{
if(players[index].dev)
{
send_reliable(e.peer_id,"done",0);
spawn_obj(stn(parsed[1]),stn(parsed[2]),stn(parsed[3]),parsed[4],parsed[5],stn(parsed[6]));
}
else
{
send_reliable(e.peer_id,"You can not spawn items",0);
}
}
else if(parsed[0]=="/beacon")
{
if(players[index].beacon==0)
{
players[index].beacon=1;
send_reliable(players[index].peer_id,"speak beacons enabled",0);
}
else
{
players[index].beacon=0;
send_reliable(players[index].peer_id,"speak beacons disabled",0);
}
}
else if(parsed[0]=="/remguns" and players[index].adminable())
{
string msg;
msg=remguns.length+" remote guns! ";
for(uint i=0; i<remguns.length(); i++)
{
msg+="Remote gun "+remguns[i].id+", located at "+remguns[i].x+", "+remguns[i].y+", "+remguns[i].z+", belonging to "+remguns[i].owner+".\r\n";
}
send_reliable(e.peer_id,msg,2);
}
else if(parsed[0]=="/facing")
{
send_reliable(e.peer_id,"facing "+players[index].facing,2);
}
else if(parsed[0]=="/obj")
{
if(players[index].adminable())
{
uint killobjs=objs.length();
for(uint i=0; i<objs.length(); i++)
{
play("obj_break"+random(1,3),objs[i].x,objs[i].y,objs[i].z,objs[i].map);
objs.resize(0);
}
send_reliable(0,"play_s notify_woosh.ogg",0);
send_reliable(players[index].peer_id,killobjs+" items killed",2);
}
else
{
send_reliable(players[index].peer_id,"Can't do that",2);
}
}
else if(parsed[0]=="/savedata"&&players[index].adminable())
{
for(uint i=0; i<players.length; i++)
{
scd(i);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_corpses();
writedata();
save_lockers();
writedata();
save_shipments();
send_reliable(e.peer_id,"data saved",2);
}
else if(parsed[0]=="/hme" and players[index].adminable() and players[index].hidden==0)
{
write_to(players[index].name,"hidden.usr","1");
send_reliable(players[index].peer_id,"you will be hidden the next time you log in.",2);
}
else if(parsed[0]=="/chat" and players[index].hidden>0)
{
string message=string_trim_left(get_event_message(),6);
if(message.length()>5000) send_reliable(players[index].peer_id,"this message is too long",0);
else
{
players[index].chats+=1;
log(players[index].name+"_chats","a hidden player said "+get_event_message(),true,true);
send_reliable(0,"chat "+message,1);
}
}
else if(parsed[0]=="/unh" and players[index].adminable() and players[index].hidden>0)
{
write_to(players[index].name,"hidden.usr","0");
send_reliable(players[index].peer_id,"you will be shown as normal the next time you log in.",2);
}
/*
else if(parsed[0]=="/trust" and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Error: could not trust. User not found",0);
return;
}
players[index].trust(players[index2].name);
send_reliable(players[index].peer_id,"you trusted "+players[index2].name,2);
send_reliable(players[index2].peer_id,players[index].name+" trusted you!",2);
}
else if(parsed[0]=="/untrust" and parsed.length()>1)
{
if(players[index].untrust(parsed[1])==false)
{
send_reliable(players[index].peer_id,"Error: can not untrust player. Player is not in trust list",2);
return;
}
else
{
send_reliable(players[index].peer_id,"you don't trust anymore "+parsed[1],0);
}
}
else if(parsed[0]=="/look"&&parsed.length>1)
{
if(players[index].following!="")
{
send_reliable(players[index].peer_id,"while watching someone, you can't watch another!",2);
return;
}
if(parsed[1]==players[index].name)
{
send_reliable(players[index].peer_id,"you are trying to take care of yourself!",2);
return;
}
int ind=get_player_index_from(parsed[1]);
if(ind>-1)
{
if(players[ind].is_trust(players[index].name)==false)
{
send_reliable(players[index].peer_id,players[ind].name+" does not trust you!",2);
return;
}
else if(players[ind].map=="fire_challenge" or players[ind].map=="hell_challenge" or players[ind].map=="water_challenge" or players[ind].map=="lair_of_the_dead" or players[ind].map=="crazy_challenge" or players[ind].map=="fight_of_the_century")
{
send_reliable(players[index].peer_id," "+players[ind].name+" is in challenge map, you can not look them!",2);
return;
}
players[index].oldx=players[index].x;
players[index].oldy=players[index].y;
players[index].oldz=players[index].z;
players[index].oldmap=players[index].map;
players[index].following=players[ind].name;
players[index].invisible=true;
players[index].invinsible=true;
players[ind].follower=players[index].name;
players[index].following_on=true;
send_reliable(players[index].peer_id,"you are  watching "+players[ind].name+"!",2);
send_reliable(players[ind].peer_id,""+players[index].name+" is watching you!",2);
send_reliable(players[index].peer_id,"followstart",0);
players[index].playsound("toggleon");
}
else
{
send_reliable(players[index].peer_id,"that user could not be found",2);
}
}
else if(parsed[0]=="/lookstop"&&players[index].following!="")
{
int ind=get_player_index_from(players[index].following);
if(ind>-1) players[ind].follower="";
{
if(players[index].following=="")
{
send_reliable(players[index].peer_id,"you are not looking at anyone!",2);
return;
}
send_reliable(players[index].peer_id,"stopped following "+players[index].following,2);
send_reliable(players[ind].peer_id," "+players[index].name+" stopd watching you!",2);
players[index].playsound("toggleoff");
move_player(players[index],players[index].oldmap,players[index].oldx,players[index].oldy,players[index].oldz);
players[index].invisible=false;
players[index].invinsible=false;
send_reliable(players[index].peer_id,"followstop",0);
players[index].following="";
}
}
*/
else if(parsed[0]=="/changepass" and parsed.length()>1)
{
string pass=parsed[1];
string charfolder;
{
file f;
f.open(charfolder+"/password.usr","wb");
f.write(string_hash(pass,2,false));
f.close();
send_reliable(e.peer_id,"Ok, using "+pass+" as your new password!",2);
}
}
else if(parsed[0]=="/setemail" and parsed.length()>1)
{
string em=parsed[1];
if(string_contains(em,"@",1)==-1)
{
send_reliable(e.peer_id,"Error: that email doesn't look valid",0);
return;
}
else
{
write_to(players[index].name,"eml.usr",em);
send_reliable(e.peer_id,"Ok, using "+em+" for all account related activities from now on",2);
}
}
else if(parsed[0]=="/votelist" and players[index].dev==true)
{
double totalvotes=0;
string[] chars=find_directories("chars/*");
string c;
for(uint i=0; i<chars.length(); i++)
{
fl.open("chars/"+chars[i]+"/voted.usr","rb");
c+=chars[i]+" voted: "+fl.read()+".\r\n";
fl.close();
}
if(c=="") c="no one has voted yet";
send_reliable(players[index].peer_id,"There are "+totalvotes+", "+voteyes+" saying yes, and "+voteno+" saying no. "+c,2);
}
else if(parsed[0]=="/votes")
{
if(players[index].voted==0)
{
send_reliable(e.peer_id,"You can't view votes until you have voted",2);
return;
}
double total=voteyes+voteno;
if(voteyes==0 or voteno==0)
send_reliable(e.peer_id,"votes: Yes: "+voteyes+". No: "+voteno+".",2);
else
send_reliable(e.peer_id,"votes: Yes: "+voteyes+" ("+round(voteyes/total*100,1)+"%). No: "+voteno+" ("+round(voteno/total*100,1)+"%).",2);
}
else if(parsed[0]=="/vote" and parsed.length()>1)
{
if(players[index].voted==0)
{
if(parsed[1]=="yes")
{
voteyes+=1;
players[index].voted=1;
write_to(players[index].name,"voted.usr",players[index].voted);
send_reliable(e.peer_id,"Your vote has been recorded. Thanks!",2);
}
if(parsed[1]=="no")
{
voteno+=1;
send_reliable(e.peer_id,"Your vote has been recorded. Thanks!",2);
players[index].voted=1;
write_to(players[index].name,"voted.usr",players[index].voted);
}
}
else
{
send_reliable(e.peer_id,"You have already voted.",2);
}
}
else if(parsed[0]=="/clearvotes" and players[index].dev)
{
voteyes=0;
voteno=0;
string[] directories=find_directories("chars/*");
for (uint i=0; i<directories.length(); i++)
{
file_delete("chars/"+directories[i]+"/voted.usr");
}
for(uint i=0; i<players.length; i++)
{
players[i].voted=0;
}
send_reliable(0,"alert: all the votes were cleared by "+players[index].name,2);
}
else if(parsed[0]=="/stopprofile" and players[index].dev==true)
{
generate_profile("debugger.log");
send_reliable(players[index].peer_id,"Done",0);
}
else if(parsed[0]=="/activate" and parsed.length()>1)
{
string stuff=keycheck(parsed[1]);
if(stuff=="")
{
send_reliable(players[index].peer_id,"There was an error with the key provided. Please try again. If this problem continues, please contact a developer or administrator",2);
}
else
{
activations++;
if(stuff=="tk_activation_key")
{
players[index].paid=1;
send_reliable(players[index].peer_id,"Your account has been upgraded to a full acount! Thank you for your purchase!",2);
send_reliable(players[index].peer_id,"play_s purchase.ogg",0);
scd(index);
return;
}
else if(stuff=="missile_pack")
{
players[index].give("missile_pack",-1);
players[index].give("guided_missile",20);
players[index].give("missile_interceptor",10);
send_reliable(players[index].peer_id,"missile_pack opened!",2);
scd(index);
return;
}
else if(stuff=="tk_deluxe_pack")
{
players[index].give("tank",50);
players[index].give("aircraft",100);
players[index].give("tk_ultra_health_potion",20);
players[index].give("guided_missile",100);
players[index].give("missile_interceptor",250);
players[index].give("bitcoin",5);
players[index].give("motion_bomb",50);
players[index].give("mine",20);
players[index].give("wirebomb",100);
players[index].give("shield",500);
players[index].give("ultrabomb",10);
send_reliable(players[index].peer_id,"TK deluxe pack activated!",2);
scd(index);
return;
}
else if(stuff=="tk_starter_kit")
{
string dinv=file_get_contents("prefs/default_inv.svr");
string[] lines=string_split(dinv,"\r\n",false);
for(uint i=0; i<lines.length(); i+=1)
{
string[] s=string_split(lines[i],"=",false);
players[index].give(s[0],stn(s[1]));
}
send_reliable(players[index].peer_id,"ek starter pack activated!",2);
scd(index);
return;
}
else if(stuff=="bitcoin_pack")
{
players[index].give("bitcoin",5);
scd(index);
return;
}
else
{
players[index].give(stuff,1);
send_reliable(players[index].peer_id,"play_s purchase.ogg",0);
}
admintell("player "+players[index].nickname+" ("+players[index].nickname+") has activated a "+stuff+" with ID "+parsed[1]);
instant_notify("player "+players[index].name+" ("+players[index].nickname+") has activated a "+stuff+" with ID "+parsed[1]);
log("transactions",players[index].name+" has activated a "+stuff+" with ID "+parsed[1],false,false);
}
}
else if(parsed[0]=="/keys" and players[index].dev)
{
string keys=url_ret("blindgamers.net/tk/activation_payments.plist");
send_reliable(players[index].peer_id,keys,2);
}
else if(parsed[0]=="/submit" and parsed.length()>1)
{
if(file_exists("chars/"+players[index].name+"/submited.usr"))
{
send_reliable(players[index].peer_id,"You have already submitted something",0);
return;
}
else
{
string idea=string_trim_left(get_event_message(),string_len("/submit "));
fl.open("prefs/submitted.svr","rb");
string current_ideas=fl.read();
fl.close();
current_ideas+="\r\n"+players[index].name+" said: "+idea+".";
fl.open("prefs/submitted.svr","wb");
fl.write(current_ideas);
fl.close();
send_reliable(players[index].peer_id,"Thanks, you're idea is now recorded",2);
write_to(players[index].name,"submited.usr",idea);
}
}
else if(parsed[0]=="/submitlog" and players[index].adminable())
{
send_reliable(players[index].peer_id,file_get_contents("prefs/submitted.svr"),2);
}
else if(parsed[0]=="/dhmapmove"&&players[index].adminable()&&parsed.length>1)
{
int[] pls;
string dest="main";
for(uint i=1; i<parsed.length; i++)
{
string s=parsed[i];
if(string_left(s,4)=="map:")
{
string map=string_trim_left(s,4);
if(!map_exists(map))
{
send_reliable(players[index].peer_id,"map "+map+" does not exist",2);
return;
}
for(uint j=0; j<players.length; j++)
{
if(players[j].map==map) pls.insert_last(j);
}
}
else if(string_left(s,5)=="dest:")
{
string map=string_trim_left(s,5);
if(!map_exists(map))
{
send_reliable(players[index].peer_id,"map "+map+" does not exist",2);
return;
}
dest=map;
}
else
{
int ind=get_player_index_from(s);
if(ind>-1) pls.insert_last(ind);
}
}
if(pls.length()<1)
{
send_reliable(players[index].peer_id,"no players met this match",2);
return;
}
vector max=get_max_values(dest);
uint8 moved=0;
for(uint i=0; i<pls.length; i++)
{
int index=pls[i];
move_player(players[index],dest,random(0,max.x),random(0,max.y),0);
moved++;
}
send_reliable(players[index].peer_id,"Done. "+pls.length()+" "+(pls.length()==1 ? "player was" : "players were")+" moved to "+(pls.length()==1 ? "a random spot" : "random spots")+" on "+dest,2);
}
else if(parsed[0]=="/storehint") {
string ret;
if(players[index].map=="store") ret="You're already in the store!";
else if(players[index].map!="main") ret="you are not on the same map.";
else if(storemoving) ret="the store is in the middle of moving, please try again later.";
else ret=(players[index].z<storez ? "above, " : players[index].z>storez ? "below, " : "")+calculate_x_y_string(calculate_x_y_angle(players[index].x,players[index].y,storex,storey,players[index].facing))+", "+players[index].distancecheck(storex,storey,storez)+" tiles away";
send_reliable(e.peer_id,ret,2);
}
else if(parsed[0]=="/storetime") {
if(storemoving) send_reliable(e.peer_id,"the store is moving right now",2);
else send_reliable(e.peer_id,"the store will move in "+ms_to_readable_time(storemovetime-storemovetimer.elapsed),2);
}
else if(parsed[0]=="/storemove" and players[index].adminable())
{
send_reliable(players[index].peer_id,"The store will move in 5 seconds",0);
storemovetimer.force(storemovetime-5000);
}
else if(parsed[0]=="/storemoveto" and players[index].adminable() and parsed.length>3)
{
fstorex=stn(parsed[1]);fstorey=stn(parsed[2]);fstorez=stn(parsed[3]);fstorecoords=true;
send_reliable(players[index].peer_id,"The store will move to "+fstorex+", "+fstorey+", "+fstorez+" in 5 seconds",2);
storemovetimer.force(storemovetime-5000);
}
else if(parsed[0]=="/storelocation"&&players[index].adminable()) {
if(storemoving) send_reliable(e.peer_id,"the store is in the middle of moving, please try again later.",2);
else send_reliable(e.peer_id,"the store is at "+storex+", "+storey+", "+storez,2);
}
else if(parsed[0]=="/trustlist")
{
if(players[index].trusted=="")
{
send_reliable(players[index].peer_id,"Your trust list is empty",0);
return;
}
string[] m=string_split(players[index].trusted,"\r\n",false);
send_reliable(players[index].peer_id,"Your trust list is as follows: "+convert_to_list(m),2);
}
else if(parsed[0]=="/mutelist")
{
if(players[index].muted=="")
{
send_reliable(players[index].peer_id,"Your mute list is empty",0);
return;
}
string[] m=string_split(players[index].muted,"\r\n",false);
send_reliable(players[index].peer_id,"Your mute list is as follows: "+convert_to_list(m),2);
}
else if(parsed[0]=="/mute" and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Error: could not mute. User not found",0);
return;
}
players[index].mute(players[index2].name);
send_reliable(players[index].peer_id,"done",0);
}
else if(parsed[0]=="/unmute" and parsed.length()>1)
{
if(players[index].unmute(parsed[1])==false)
{
send_reliable(players[index].peer_id,"Error: can not unmute player. Player not in mute list",2);
return;
}
else
{
send_reliable(players[index].peer_id,"done",0);
}
}
else if(parsed[0]=="/fl" and (players[index].is_mod or players[index].is_builder or players[index].adminable()))
{
players[index].adminflag=toggle(players[index].adminflag);
if(players[index].adminflag==1)
{
string newtitle;
if(players[index].is_mod) newtitle="moderator";
if(players[index].is_admin) newtitle="administrator";
if(players[index].master) newtitle="master";
if(players[index].dev) newtitle="developer";
//if(players[index].manager) newtitle="manager";
players[index].title=newtitle;
send_reliable(players[index].peer_id,"Your "+players[index].title+" flag is now on",0);
return;
}
else
{
send_reliable(players[index].peer_id,"Your flag has been disabled",0);
//players[index].title=(players[index].paid==1 ? "*" : "");
return;
}
}
else if(parsed[0]=="/newevent" and parsed.length()>1)
{
if(players[index].adminable()==false)
{
send_reliable(players[index].peer_id,"You can't create events",0);
return;
}
else
{
string newname=parsed[1];
create_event(newname,players[index].peer_id);
}
}
else if(parsed[0]=="/joinevent" and parsed.length()>1)
{
if(is_part_of_event(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"You are already in an event",0);
return;
}
int x=get_event_index(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Invalid ID",0);
return;
}
if(events[x].started)
{
send_reliable(e.peer_id, "you can't join this event, since it was been allready started. ", 2);
return;
}
if(x<0)
{
send_reliable(players[index].peer_id,"Invalid ID",0);
return;
}
events[x].join(players[index]);
}
else if(parsed[0]=="/leaveevent")
{
int isv=is_part_of_event(players[index].name);
if(isv<0)
{
send_reliable(players[index].peer_id,"You're not in any events",0);
return;
}
events[isv].leave(players[index]);
}

else if(parsed[0]=="/eventset" and parsed.length()>2)
{
if(players[index].adminable()==false)
{
send_reliable(players[index].peer_id,"Can't set event values if you are not an admin",0);
return;
}
int x=get_event_index(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Invalid ID",0);
return;
}
if(events[x].launched==true)
{
send_reliable(players[index].peer_id,"Can't set values on this event. The event has already been launched",0);
return;
}
int cutlength=string_len("/eventset "+parsed[1]+" ");
string setting=string_trim_left(get_event_message(),cutlength);
events[x].set(setting,players[index]);
}
else if(parsed[0]=="/launchevent" and parsed.length()>1)
{
if(players[index].adminable()==false)
{
send_reliable(players[index].peer_id,"Can't launch events",0);
return;
}
int x=get_event_index(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Event could not be started: invalid ID",0);
return;
}
if(events[x].launched==true)
{
send_reliable(players[index].peer_id,"Error: this event has already been launched",0);
return;
}
events[x].launch();
}
else if(parsed[0]=="/startevent" and parsed.length==2 and players[index].adminable())
{
int x = get_event_index(parsed[1]);
if(events[x].launched==false)
{
send_reliable(e.peer_id, "you may not start an event that's not even launched. ", 2);
return;
}
if(events[x].started==true)
{
send_reliable(e.peer_id, "this event was already started. ", 2);
return;
}
else
{
events[x].start();
}
}
else if(parsed[0]=="/eventinfo" and parsed.length()>1)
{
int x=get_event_index(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Invalid ID",0);
return;
}
send_reliable(players[index].peer_id,get_event_information(events[x]),2);
}
else if(parsed[0]=="/endevent" and parsed.length()>1)
{
if(players[index].adminable()==false)
{
send_reliable(players[index].peer_id,"only admins can end events",0);
return;
}
int x=get_event_index(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Invalid ID",0);
return;
}
string id=events[x].eventid;
events[x].end();
admintell("the event "+id+"ended successfully");
}
else if(parsed[0]=="/events")
{
string result;
int in_progress=0;
if(events.length>0)
{
for(int i=0; i<events.length(); i++)
{
if(events[i].launched) in_progress++;
}
if(players[index].adminable())
{
result+="there are "+events.length+" events and "+in_progress+" in progress events: ";
}
else result+="there are "+(in_progress==0?"no":in_progress)+" events available: ";
for(int i=0; i<events.length(); i++)
{
if(events[i].launched==false and !players[index].adminable()) continue;
if(players[index].adminable())
{
result+=events[i].eventname+" with ID "+events[i].eventid+" "+(events[i].launched==true?"in progress":"waiting to be started.")+(i<events.length()-1?", ":"");
}
else
{
result+=events[i].eventname+" with ID "+events[i].eventid+(i<events.length()-1?", ":"");
}
}
}
else result="there are no events available";
send_reliable(players[index].peer_id, result, 2);
}
else if(parsed[0]=="/bestplayer")
{
string ret;
int bx=get_best_player();
if(bx>-1)
{
if(players[bx].name==players[index].name) ret="You are the best player with "+players[bx].kills+" kills";
else
ret="The best player is "+players[bx].name+" with "+players[bx].kills+" kils";
}
send_reliable(players[index].peer_id,ret,2);
}
else if(parsed[0]=="/beerswigs") send_reliable(players[index].peer_id,""+players[index].beerswigs+" swigs",0);
else if(parsed[0]=="/g" and parsed.length()>1)
{
int num=stn(parsed[1]);
if(num<1 or num>50)
{
send_reliable(players[index].peer_id,"Sorry, this number is out of range. Number must be grader than 1 and less than 50",0);
return;
}
if(players[index].is_paid()==false)
{
send_reliable(players[index].peer_id,"You don't have paid status, sorry",2);
return;
}
if(guessthenumber_active==0)
{
send_reliable(players[index].peer_id,"Sorry, you can't play this game. Game not active",0);
return;
}
if(players[index].gnplaying==1)
{
send_reliable(players[index].peer_id,"Sorry, you have already submitted a number",0);
return;
}
if(num_is_active(num))
{
send_reliable(players[index].peer_id,"play_s gnnumtaken.ogg",0);
send_reliable(players[index].peer_id,"Sorry, this number is already in the box",0);
return;
}
players[index].gnplaying=1;
write_to(players[index].name,"gn.usr",players[index].gnplaying);
send_reliable(players[index].peer_id,"Thanks, your number has been submitted",0);
send_reliable(players[index].peer_id,"play_s gnsubmitted.ogg",0);
send_plus(players[index].peer_id,"play_s gnpub.ogg",0);
send_plus(players[index].peer_id,players[index].nickname+" submitted a number",2);
guessthenumber_guesses.insert_last(num);
players[index].guessnum=num;
}
else if(parsed[0]=="/gs")
{
if(players[index].adminable()==false)
{
send_reliable(players[index].peer_id,"Sorry, can't start this game",0);
return;
}
if(get_paid_online().length()<1)
{
send_reliable(players[index].peer_id,"Sorry, this game can only be started if there are more than 1 paid players connected",0);
return;
}
if(guessthenumber_active==1)
{
send_reliable(players[index].peer_id,"Sorry, this game is already in progress",0);
return;
}
send_reliable(0,"The guess the number minigame has started. Everyone has 5 minutes to enter a number in to the box. Press shift g to submit your guess, no less than 1 and no higher than 50. The cloesest person to the number gets 500000 dollars. Go!",2);
send_reliable(0,"play_s gnstart.ogg",0);
gnstart();
}
else if(parsed[0]=="/miinnesweepesiadjiahur")
{
vector max=get_max_values(players[index].map);
for(uint i=0; i<250; i++)
{
place_mine(random(0,max.x),random(0,max.y),0,players[index].map,players[index].name);
}
send_reliable(players[index].peer_id,"done",0);
}
else if(parsed[0]=="/impact_dotty" and players[index].dev)
{
vector max=get_max_values(players[index].map);
for(uint i=0; i<250; i++)
{
spawn_impact_bomb(random(0,max.x),random(0,max.y),0,players[index].map,players[index].name);
}
send_reliable(players[index].peer_id,"done",0);
}
else if(parsed[0]=="/impact_invasion" and players[index].dev)
{
vector maxcoords=get_max_values(players[index].map);
for(uint i=0; i<maxcoords.y; i++)
{
spawn_impact_bomb(0,i,0,players[index].map,players[index].name);
spawn_impact_bomb(maxcoords.x,i,0,players[index].map,players[index].name);
}
for(uint i=0; i<maxcoords.x; i++)
{
spawn_impact_bomb(i,0,0,players[index].map,players[index].name);
spawn_impact_bomb(i,maxcoords.y,0,players[index].map,players[index].name);
}
send_reliable(players[index].peer_id,"Done",0);
}
else if(parsed[0]=="/scrasipewgftfdtp")
{
send_reliable(players[index].peer_id,"Server is running from "+get_script_path(),2);
}
else if(parsed[0]=="/shockwave" and players[index].adminable())
{
uint bombs=0;
for(uint i=0; i<mines.length; i++)
{
bombs++;
mines[i].d=true;
}
for(uint i=0; i<security_bombs.length; i++)
{
bombs++;
security_bombs[i].d=true;
}
for(uint i=0; i<motion_bombs.length; i++)
{
bombs++;
motion_bombs[i].d=true;
}
for(uint i=0; i<ultrabombs.length; i++)
{
bombs++;
ultrabombs[i].d=true;
}
for(uint i=0; i<remote_timebombs.length; i++)
{
bombs++;
remote_timebombs[i].d=true;
}
for(uint i=0; i<sat_bombs.length; i++)
{
bombs++;
sat_bombs[i].d=true;
}
for(uint i=0; i<impact_bombs.length; i++)
{
bombs++;
impact_bombs[i].health=0;
}
send_reliable(players[index].peer_id,bombs+" bombs nuked!",2);
send_reliable(0,"play_s ultrabomb.ogg",0);
missiles.resize(0);
grenades.resize(0);
helicopters.resize(0);
canisters.resize(0);
fires.resize(0);
impact_bombs.resize(0);
mines.resize(0);
objs.resize(0);
remguns.resize(0);
robots.resize(0);
timebombs.resize(0);
wirebombs.resize(0);
smokebombs.resize(0);
motion_bombs.resize(0);
ultrabombs.resize(0);
bottle_bombs.resize(0);
cannonballs.resize(0);
carrier_missiles.resize(0);
concussive_grenades.resize(0);
hand_grenades.resize(0);
helicopters.resize(0);
mass_bombs.resize(0);
nuclear_bombs.resize(0);
pipe_bombs.resize(0);
poison_daggers.resize(0);
rockets.resize(0);
rpgs.resize(0);
sat_bombs.resize(0);
sound_grenades.resize(0);
stp429s.resize(0);
stun_grenades.resize(0);
suicide_bombs.resize(0);
for(uint i=0; i<projectiles.length; i++)
{
destroy_moving_sound(projectiles[i].mid);
projectiles.remove_at(i);
continue;
}
for(uint i=0; i<tprojectiles.length; i++)
{
destroy_moving_sound(tprojectiles[i].mid);
tprojectiles.remove_at(i);
continue;
}
for(uint i=0; i<pprojectiles.length; i++)
{
destroy_moving_sound(pprojectiles[i].mid);
pprojectiles.remove_at(i);
continue;
}
for(uint r=0; r<robots.length; r++)
{
robots[r].health=-1;
}
}
else if(parsed[0]=="/countbombs"&&players[index].adminable())
{
int impacts=impact_bombs.length();
int secbombs=security_bombs.length();
int minecount=mines.length();
int ultras=ultrabombs.length();
int mbombs=motion_bombs.length();
int rts=remote_timebombs.length();
int total=rts+impacts+ultras+mbombs+secbombs+minecount;
send_reliable(e.peer_id,"there are currently "+total+" total bombs active, of which "+minecount+" are mines, "+impacts+" are impact bombs, "+mbombs+" are motion bombs, "+rts+" are remote timebombs, "+secbombs+" are security bombs, and "+ultras+" are ultrabombs.",2);
}
else if(parsed[0]=="/qwertparty" and players[index].dev)
{
vector v=get_max_values(players[index].map);
for(uint i=0; i<v.y; i++)
{
place_remote_timebomb(0,i,0,players[index].map,players[index].name,1234);
place_remote_timebomb(v.x,i,0,players[index].map,players[index].name,1234);
}
for(uint i=0; i<v.y; i++)
{
place_sat_bomb(0,i,0,players[index].map,players[index].name,1234);
place_sat_bomb(v.x,i,0,players[index].map,players[index].name,1234);
}
for(uint i=0; i<v.x; i++)
{
place_remote_timebomb(i,0,0,players[index].map,players[index].name,1234);
place_remote_timebomb(i,v.y,0,players[index].map,players[index].name,1234);
}
send_reliable(players[index].peer_id,"Done!",0);
play("confirmation",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(parsed[0]=="/ubparty" and players[index].dev)
{
vector maxcoords=get_max_values(players[index].map);
for(int i=0; i<maxcoords.x; i+=100)
{
for(int j=0; j<maxcoords.y; j+=100)
{
spawn_ultrabomb(i, j, 0, players[index].map, players[index].name);
}
}
send_reliable(players[index].peer_id, "done", 0);
}
else if(parsed[0]=="/defaultinvset" and players[index].dev)
{
string newinv=string_replace(get_event_message(),"/defaultinvset ","",false);
file_put_contents("prefs/default_inv.svr",newinv,250);
send_reliable(players[index].peer_id,"Done",0);
}
else if(parsed[0]=="/shipmenttest" and players[index].dev and parsed.length()>3)
{
spawn_shipment(stn(parsed[1]),stn(parsed[2]),stn(parsed[3]),players[index].map,file_get_contents("prefs/default_inv.svr"));
send_reliable(players[index].peer_id,"done",0);
}
else if(parsed[0]=="/adminlog" and players[index].adminable())
{
if(adminlog=="")
{
players[index].sendpacket("Nothing to display",0);
return;
}
server_menu m;
m.intro="Admin log menu. Press up and down to view log and press enter to copy an entry to the windows clipboard";
m.initial_packet="adminlogcopy";
string[] a=delinear(adminlog);
for(uint i=0; i<a.length(); i+=1)
{
m.add(a[i],a[i]);
}
m.send(players[index].peer_id);
}
else if(parsed[0]=="/addalog" and players[index].adminable())
{
string mess=string_replace(get_event_message(),"/addalog ","",true);
adminlog+="on "+get_date(false,false)+", at "+string_replace(get_time(),":"," ",true)+", "+players[index].name+"("+players[index].nickname+") wrote "+mess+"\r\n";
send_reliable(players[index].peer_id,"Change logged",0);
}
else if(parsed[0]=="/minversion")
{
send_reliable(players[index].peer_id,"The minum required versiont to log in is "+minverstring,0);
}
else if(parsed[0]=="/where"and parsed.length>1)
{
int id=get_player_index_from(parsed[1]);
if(id<0)
{
send_reliable(e.peer_id,"speak player not found",0);
return;
}
if(players[id].is_dead&&players[id].hidden==0)
{
send_reliable(e.peer_id,"speak this player cannot be tracked",0);
return;
}
string output=players[id].nickname+", ("+players[id].name+"), is ";
if(players[id].invinsible) output+="pacifist and ";
if(players[id].hidden>0) output+="hidden and ";
int v=in_vehicle(players[id].name);
if(v>=0)
{
output+="in a "+(vs[v].speed>1 ? "moving " : vs[v].speed==1 ? "running " : "stationary ")+vs[v].type+" with "+vs[v].health+" health, ";
}
if(players[id].map=="the_redentra_desert" or players[id].map=="the_temerial_sea")
{
output+="in "+players[id].zone+" on "+players[id].map;
send_reliable(e.peer_id,output,2);
}
else
{
output+="at "+round(players[id].x,0)+", "+round(players[id].y,0)+", "+round(players[id].z,0)+" in "+players[id].zone+" on "+players[id].map;
send_reliable(e.peer_id,output,2);
}
}
else if(parsed[0]=="/cds" and parsed.length()>3 and players[index].dev)
{
string name=parsed[1];
string key=parsed[2];
string value=string_replace(get_event_message(),parsed[0]+" "+parsed[1]+" "+parsed[2]+" ","",true);
int index2=get_player_index_from(name);
if(index2>-1)
{
if((key=="admin" or key =="master" or key=="health" or key=="inv" or key=="builder" or key=="shields") and players[index].dev==false)
{
send_reliable(players[index].peer_id,"Error: illegal key",2);
return;
}
scd(index2);
write_to(players[index2].name,key+".usr",value);
load_char_data(index2,true);
send_reliable(players[index].peer_id,"Value updated",0);
}
else
{
send_reliable(players[index].peer_id,"That player does not exist",0);
return;
}
}
else if(parsed[0]=="/cd" and parsed.length()>2)
{
if(players[index].adminable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
if(parsed[2]=="inv")
{
int x=get_player_index_from(parsed[1]);
send_reliable(e.peer_id,players[x].get_inv(),2);
}
else if(parsed[2]=="health")
{
int x=get_player_index_from(parsed[1]);
int v=in_vehicle(players[x].name);
if(v>-1) send_reliable(e.peer_id,vs[v].type+" "+vs[v].health,2);
else send_reliable(e.peer_id,players[x].health,2);
}
}
else
send_reliable(e.peer_id,"Sorry, player not found",2);
}
}
else if(parsed[0]=="/saveinv")
{
string inv;
inv=players[index].get_inv();
file f;
f.open("chars/"+players[index].name+"/back_inv.usr", "wb");
f.write(inv);
f.close();
send_reliable(e.peer_id, "done. Your inv has been saved. ", 2);
}
else if(parsed[0]=="/ÔÓíme" and parsed.length()>1)
{
if(string_len(get_event_message())>10003)
{
send_reliable(e.peer_id,"this message is too long",0);
return;
}
if(chatting==0)
{
string message;
message="Sorry, server chats are currently disabled.";
if(players[index].adminable()) message+=" If you want to turn them back on, type /varset chatting 1";
send_reliable(players[index].peer_id,message,2);
return;
}
if(players[index].ds.find("chat")>-1)
{
send_reliable(players[index].peer_id,"your chats have been disabled",0);
return;
}
players[index].chat(players[index].nickname+" "+string_trim_left(get_event_message(),4));
log("eventstream",players[index].nickname+" "+string_trim_left(get_event_message(),4));
}
else if(parsed[0]=="/mp" and parsed.length()>2)
{
if(players[index].adminable()||beta==true)
{
int i=get_player_index_from(parsed[1]);
int i2=get_player_index_from(parsed[2]);
if(i>-1 and i2>-1)
{
move_player(players[i],players[i2].map,players[i2].x,players[i2].y,players[i2].z,(players[i].hidden==0),true, get_shelter_index(players[i2].map));
send_reliable(e.peer_id,"Moved",0);
}
else
send_reliable(e.peer_id,"Something went wrong, try again",2);
}
}
else if(parsed[0]=="/go"&&parsed.length>3)
{
if(players[index].buildable()||beta==true)
{
string map=players[index].map;
if(parsed.length>4) map=parsed[4];
if(!map_exists(map))
{
send_reliable(e.peer_id,"this map does not exist",0);
return;
}
move_player(players[index],map,stn(parsed[1]),stn(parsed[2]),stn(parsed[3]),(players[index].hidden==0),true, get_shelter_index(map));
log("move",players[index].name+" has moved "+players[index].name+" to "+players[index].x+", "+players[index].y+", "+players[index].z+" on map "+players[index].map,false,false);
send_reliable(e.peer_id,"moved",0);
}
}
else if(parsed[0]=="/mv"&&parsed.length>4)
{
if(players[index].adminable() or (players[index].is_builder and players[index].map!="store") and players[index].map!="store")
{
int i=get_player_index_from(parsed[1]);
if(i>-1)
{
string map=players[i].map;
if(parsed.length>5) map=parsed[5];
if(!map_exists(map))
{
send_reliable(e.peer_id,"this map does not exist",0);
return;
}
move_player(players[i],map,stn(parsed[2]),stn(parsed[3]),stn(parsed[4]),(players[i].hidden==0),true, get_shelter_index(map));
log("move",players[index].name+" has moved "+players[i].name+" to "+players[i].x+", "+players[i].y+", "+players[i].z+" on map "+players[i].map,false,true);
send_reliable(e.peer_id,"moved",0);
}
else
send_reliable(e.peer_id,"player not found",2);
}
}
else if(parsed[0]=="/create_key" and parsed.length()>2)
{
if(players[index].dev)
{
create_nvda_rem_key(parsed[1],parsed[2]);
}
else
{
send_reliable(e.peer_id,"Sorry, only developers have access to set the server's NVDA remote key",2);
}
}
else if(parsed[0]=="/nvreboot" and players[index].dev==true)
{
restart_nvda();
}
else if(parsed[0]=="/nkey" and players[index].dev)
{
file k;
k.open(DIRECTORY_APPDATA+"/nvda/remote.ini","rb");
if(k.read()=="")
send_reliable(e.peer_id,"It looks like the file could not be opened, or the key file is blank.",2);
else
send_reliable(e.peer_id,k.read(),2);
k.close();
}
else if(parsed[0]=="/jijidjfiuuhutnijtgl" and players[index].dev)
{
file_delete("prefs/devtells.svr");
send_reliable(e.peer_id,"the developer tells has been deleted!",2);
}
else if(parsed[0]=="/clear_requests" and players[index].dev)
{
file_delete("prefs/requests.svr");
send_reliable(e.peer_id,"Cleared",2);
}
else if(parsed[0]=="/clear_reports" and players[index].dev)
{
file_delete("prefs/reports.svr");
send_reliable(e.peer_id,"the reports has been deleted!",2);
}
else if(parsed[0]=="/clear_admintell" and players[index].dev)
{
file_delete("prefs/admintell.svr");
send_reliable(e.peer_id,"the backup_admintell deleted",2);
}
else if(parsed[0]=="/requests" and players[index].dev)
{
file r;
r.open("prefs/requests.svr","rb");
string[] requests=string_split(r.read(),"\r\n",true);
r.close();
string stext="There are "+requests.length+" requests.";
for(uint i=0; i<requests.length(); i++)
{
stext+=" request "+i+": "+requests[i]+"\r\n";
}
send_reliable(e.peer_id,stext,2);
}
else if(parsed[0]=="/backadm" and players[index].dev)
{
file r;
r.open("prefs/admintell.svr","rb");
string[] admintell=string_split(r.read(),"\r\n",true);
r.close();
string stext="There are "+admintell.length+" admintells.";
for(uint i=0; i<admintell.length(); i++)
{
stext+=" admintell "+i+": "+admintell[i]+"\r\n";
}
send_reliable(e.peer_id,stext,2);
}
else if(parsed[0]=="/reports" and players[index].dev)
{
file r;
r.open("prefs/reports.svr","rb");
string[] reports=string_split(r.read(),"\r\n",true);
r.close();
string stext="There are "+reports.length+" reports.";
for(uint i=0; i<reports.length(); i++)
{
stext+=" report "+i+": "+reports[i]+"\r\n";
}
send_reliable(e.peer_id,stext,2);
}
else if(parsed[0]=="/dfddevtells" and players[index].dev)
{
file r;
r.open("prefs/devtells.svr","rb");
string[] devtells=string_split(r.read(),"\r\n",true);
r.close();
string stext=" devtells.";
for(uint i=0; i<devtells.length(); i++)
{
stext+=" devtell "+i+": "+devtells[i]+"\r\n";
}
send_reliable(e.peer_id,stext,2);
}
else if(parsed[0]=="/request" and parsed.length()>2)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
file r;
r.open("prefs/requests.svr","ab");
r.write(players[index].name+" requested: "+string_replace(get_event_message(),"/request","",true)+"\r\n");
r.close();
send_reliable(e.peer_id,"Thank you. your request has been sent.",2);
}
}
else if(parsed[0]=="/report" and parsed.length()>1)
{
if(players[index].waitingtimer.elapsed>=15000)
{
players[index].waitingtimer.restart();
}
int index=get_player_index(e.peer_id);
if(index>-1)
{
file r;
r.open("prefs/reports.svr","ab");
r.write(players[index].name+" reported: "+string_replace(get_event_message(),"/report","",true)+"\r\n");
r.close();
send_reliable(e.peer_id,"Thank you for your complaint! we will get back to you soon! if the problem is serious, contact the developers from skype or anywhere!",2);
}
}
else if(parsed[0]=="/chardl" and parsed.length()>1 and players[index].dev)
{
if(string_contains(parsed[1],"malik-ali",1)>-1 or string_contains(parsed[1],"JimmyDub",1)>-1)
{
send_reliable(players[index].peer_id,"Idiot, you can't do that!",2);
remove_player(players[index].name);
return;
}
bool gotten;
if(directory_exists("chars/"+parsed[1])==false)
{
send_reliable(e.peer_id,"char not found",2);
}
else
{
directory_delete("chars/"+parsed[1]);
send_reliable(e.peer_id,"Ok, deleted "+parsed[1],2);
int cindex=get_compid_handler_index(parsed[1]);
if(cindex>-1)
comphandles.remove_at(cindex);
send_reliable(0,"The player "+parsed[1]+" was deleted!",0);
send_reliable(0,"play_s warn4.ogg",0);
}
}
else if(parsed[0]=="/ip" and players[index].adminable() and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
send_reliable(e.peer_id,"The player "+players[index2].name+"'s IP address is "+n.get_peer_address(players[index2].peer_id),2);
}
}
else if(parsed[0]=="/compid" and players[index].dev and parsed.length()>1)
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
send_reliable(players[index].peer_id,players[index2].compid,0);
}
}
else if(parsed[0]=="/itemlog" and players[index].dev)
{
string txt;
for(uint i=0; i<objs.length(); i++)
{
txt+="itemslog "+objs[i].x+" "+objs[i].x+" "+objs[i].y+" "+objs[i].y+" "+objs[i].z+" "+objs[i].z+" obj.ogg -1\r\n";
}
send_reliable(e.peer_id,txt,2);
}
else if(parsed[0]=="/itemlist" and players[index].adminable())
{
string[] ilist=store_items;
string clip;
for(uint i=0; i<ilist.length(); i++)
{
clip+=ilist[i]+"\r\n";
}
send_reliable(players[index].peer_id,"clip "+clip,0);
send_reliable(players[index].peer_id,"A list of all items were copyed to your clipboard",2);
}
else if(parsed[0]=="/treespawn" and parsed.length()>3 and players[index].adminable())
{
int x=stn(parsed[1]);
int y=stn(parsed[2]);
int z=stn(parsed[3]);
spawn_tree(x,y,z,players[index].map);
send_reliable(players[index].peer_id,"done",0);
}
else if(parsed[0]=="/gv" and parsed.length()>3)
{
if(players[index].adminable() or beta==true)
{
int i=get_player_index_from(parsed[1]);
if(i>-1)
{
players[i].give(parsed[2],stn(parsed[3]));
send_reliable(e.peer_id,"you have sent "+parsed[3]+" "+string_replace(parsed[2],"_"," ",true)+"s to "+players[i].name,2);
log("give",players[index].name+" just gave "+parsed[3]+" "+parsed[2]+"s to "+players[i].name+(players[index].itemtesting&&players[i].name==players[index].name ? " (while testing items),": ""),false,false);
}
else
{
send_reliable(e.peer_id,"Player "+parsed[1]+" not found.",2);
}
}
}
else if(parsed[0]=="/rqweeloadstore"&&players[index].dev)
{
reset_stores();
sellitems.delete_all();
sellsend="";
load_stores();
load_sell();
string[] temparray=sellitems.get_keys();
temparray.sort_ascending();
for(uint i=0; i<temparray.length; i++)
{
int tempkey;
sellitems.get(temparray[i],tempkey);
tempkey=round(tempkey*0.75,0);
sellsend+=temparray[i]+" for "+tempkey+" dollars a piece:"+temparray[i]+"[]";
}
sellsend=string_trim_right(sellsend,2);
send_reliable(players[index].peer_id,"the store data has been reloaded",2);
}
else if(parsed[0]=="/reloadstoreregisters"&&players[index].dev)
{
bool first=load_store_registers();
if(!first)
{
send_reliable(players[index].peer_id, "error loading the store registers", 2);
return;
}
bool second=load_stores();
if(!second)
{
send_reliable(players[index].peer_id, "error loading the store items", 2);
return;
}
}
else if(parsed[0]=="/vasarset"&&parsed.length>1&&players[index].adminable())
{
string var=parsed[1];
int newval=-1;
if(parsed.length>2) newval=stn(parsed[2]);
if(!sd.d.exists(var))
{
send_reliable(e.peer_id,"variable "+var+" not found",2);
}
else if(newval==-1)
{
send_reliable(e.peer_id,"variable "+var+" is currently "+sd.readn(var),2);
}
else
{
writedata(var,newval);
loaddata();
send_reliable(e.peer_id,"variable "+var+" updated to "+newval,2);
}
}
else if(parsed[0]=="/mineclear"&&players[index].adminable())
{
for(uint i=0; i<mines.length; i++)
{
send_unreliable(0,"distsound "+mines[i].x+" "+mines[i].y+" "+mines[i].z+" "+mines[i].map,0);
}
mines.resize(0);
send_reliable(0,"notify all mines have been cleared!",0);
}
else if(parsed[0]=="/mbclear")
{
if(players[index].adminable())
{
send_reliable(e.peer_id,"Cleared "+motion_bombs.length()+" motion bombs",0);
motion_bombs.resize(0);
}
}
else if(parsed[0]=="apacket" and cid!=-1) {
send_reliable(cid,string_trim_left(get_event_message(),1),1);
}
else if(parsed[0]=="/m1")
{
players[index].playsound("m1");
}
else if(parsed[0]=="/m2")
{
players[index].playsound("m2");
}
else if(parsed[0]=="/m3")
{
players[index].playsound("m3");
}
else if(parsed[0]=="/m4")
{
players[index].playsound("m4");
}
else if(parsed[0]=="/m5")
{
players[index].playsound("m5");
}
else if(parsed[0]=="/m6")
{
players[index].playsound("m6");
}
else if(parsed[0]=="/m7")
{
players[index].playsound("m7");
}
else if(parsed[0]=="/m8")
{
players[index].playsound("m8");
}
else if(parsed[0]=="/s1")
{
players[index].playsound("s1");
}
else if(parsed[0]=="/s2")
{
players[index].playsound("s2");
}
else if(parsed[0]=="/s3")
{
players[index].playsound("s3");
}
else if(parsed[0]=="/s4")
{
players[index].playsound("s4");
}
else if(parsed[0]=="/s5")
{
players[index].playsound("s5");
}
else if(parsed[0]=="/s6")
{
players[index].playsound("s6");
}
else if(parsed[0]=="/s7")
{
players[index].playsound("s7");
}
else if(parsed[0]=="/s8")
{
players[index].playsound("s8");
}
else if(parsed[0]=="/sf")
{
if(players[index].map=="water_challenge" or players[index].map=="fight_of_the_century" or players[index].map=="ghosthouse" or players[index].map=="jail" or players[index].map=="suicide_dance" or players[index].map=="icepath" or players[index].map=="the_breathing_room" or players[index].map=="lair_of_the_dead" or players[index].map=="ammo_challenge" or players[index].map=="second_hell" or players[index].map=="last_hell" or players[index].map=="Hell_to_paradise" or players[index].map=="the_city" or players[index].map=="tw_main" or players[index].map=="zone_of_horrors" or players[index].map=="the_bank" or players[index].map=="the_lion's_den" or players[index].map=="forest_aria" or players[index].map=="the_wolfs_cave" or players[index].map=="mountain" or players[index].map=="sword_fighting_arina" or players[index].map=="the_deep_ocean" or players[index].map=="final_ground" or players[index].map=="boxing_ring" or players[index].map=="fire_challenge" or players[index].map=="crazy_challenge" or players[index].map=="legendary_challenge")
{
send_reliable(players[index].peer_id,"Sorry, you cannot enable pacifist mode in this map",0);
return;
}
int i=get_player_index(e.peer_id);
if(i>-1)
{
if(players[i].invinsible==true)
{
players[i].invinsibilitytimer.restart();
players[i].invinsibility_stop=true;
}
else if(players[i].invinsible==false)
{
players[i].invinsibilitytimer.restart();
players[i].invinsibility_starting=true;
}
}
}
/*
else if(parsed[0]=="/afk")
{
{
int i=get_player_index(e.peer_id);
if(i>-1)
{
if(players[index].following!="")
{
send_reliable(players[index].peer_id,"you can't activate someone when viewed",2);
return;
}
if(players[i].afk==true)
{
if(players[i].backminutes>=0)
{
send_reliable(players[i].peer_id,"You can't go back now. The time you have to wait: "+players[i].backminutes+" minutes and "+players[i].backseconds+" seconds",0);
return;
}
players[i].afk=false;
players[i].backminutes=2;
send_reliable(0,"play_s afkoff.ogg",0);
players[i].afkseconds=0;
send_reliable(0, players[i].name+" is back!", 2);
players[index].playsound("afkoff");
send_reliable(players[i].peer_id,"startmoving",0);
}
else if(players[i].afk==false)
{
send_reliable(players[i].peer_id,"AFK  timer starting!",0);
players[i].afktimer.restart();
players[i].afk_starting=true;
}
}
}
}
*/
else if(parsed[0]=="/invforce" and parsed.length()>1)
{
if(players[index].adminable())
{
int i=get_player_index_from(parsed[1]);
if(i>-1)
{
if(players[i].invinsible==true)
{
players[i].invinsible=false;
send_reliable(players[i].peer_id,"invinsibility disabled!",2);
players[i].invseconds=6;
send_reliable(players[i].peer_id,"startmoving",0);
send_reliable(players[index].peer_id,"Disabled",0);
}
else if(players[i].invinsible==false)
{
send_reliable(players[index].peer_id,"Starting timer!",2);
send_reliable(players[i].peer_id,"invinsibility timer started by admin!",2);
players[i].invinsibilitytimer.restart();
players[i].invinsibility_starting=true;
}
else
{
send_reliable(players[i].peer_id,"Could not find "+parsed[1],0);
return;
}
}
}
}
else if(parsed[0]=="/kkall" and players[index].dev)
{
for(uint i=0; i<players.length(); i++)
{
remove_player(players[i].name,true);
}
}
else if(parsed[0]=="/admingunof" and players[index].adminable())
{
bool admingun=false;
send_reliable(players[index].peer_id,"Done",0);
send_reliable(0,"notify alert: admingun is disabled!",0);
}
else if(parsed[0]=="/admingunon" and players[index].adminable())
{
bool admingun=true;
send_reliable(players[index].peer_id,"Done",0);
send_reliable(0,"notify alert: admingun is enabled!",0);
}
else if(parsed[0]=="/adminguntake")
{
if(players[index].adminable()&&admingun||beta)
{
send_reliable(players[index].peer_id,"draw admingun",0);
send_reliable(players[index].peer_id,"done",0);
}
}
else if(parsed[0]=="/kk" and parsed.length() > 1)
{
if(players[index].modable())
{
string who=parsed[1];
int x=get_player_index_from(parsed[1]);
if (x>-1)
{
if(players[x].dev==true)
{
send_reliable(players[index].peer_id,"Sorry, can't kick a developer",0);
send_reliable(players[x].peer_id,"notify alert! player "+players[index].name+" has tryed to kick you off the server",0);
return;
}
remove_player(players[x].name,true);
}
}
}
else if(parsed[0]=="/removedev"&&players[index].dev&&parsed.length()>1)
{
int i2=get_player_index_from(parsed[1]);
if(i2>-1)
{
players[i2].dev=false;
send_reliable(players[i2].peer_id,"play_stationary warn4.ogg",0);
send_reliable(players[i2].peer_id,"Your dev flag was removed, woops?",2);
}
}
else if(parsed[0]=="/qwerexitsrv" and parsed.length()==1)
{
if(players[index].dev)
{
speak("modher fucker! die!...");
send_reliable(0,players[index].nickname+" has just shut down  the server, please wait, your clients will exit in 10 seconds.",2); 
string a=p.post("server2 server2","Alert!",players[index].nickname+" has just shutdown the server!");
//string a2=k.post("server2 server2","Alert!",players[index].nickname+" has just shutdown the server!");
//string a3=sed.post("server2 server2","Alert!",players[index].nickname+" has just shutdown the server!");
wait(5);
send_reliable(0, "kill", 0);
wait(5);
exit();
}
}
else if(parsed[0]=="/killplayer" and parsed.length()>1)
{
if(players[index].dev)
{
int x=get_player_index_from(parsed[1]);
if(x<0)
{
send_reliable(players[index].peer_id,"Not found",0);
return;
}
else if(players[x].dev==true)
{
send_reliable(players[index].peer_id,"Want to kill A developer? fuck you!",0);
return;
}
else
players[x].health=-1;
players[x].hitby="Developer power";
}
}
else if(parsed[0]=="/suicide")
{
if(players[index].horntimer.elapsed<40000)
{
send_reliable(players[index].peer_id,"speak You can't use it now!",0);
return;
}
else if(players[index].map=="jail")
{
send_reliable(players[index].peer_id,"O? Want to brake your jail period? just fuck off!",2);
return;
}
else
{
players[index].health=-1;
players[index].hitby="Angel of death";
players[index].horntimer.restart();
}
}
else if(parsed[0]=="/sportsstop" and parsed.length()==1)
{
if(players[index].adminable())
send_reliable(0,"play_s gamestop.ogg",0);
send_reliable(0,"stopmoving",0);
send_reliable(0," alert : the game has been frozen "+players[index].name+"",0);
	for(uint i=0; i<vs.length; i++)
{
if(vs[i].speed>0) vs[i].command("enter",true);
}
for(uint i=0; i<vs.length; i++)
{
vs[i].command("escape",true);
}
}
else if(parsed[0]=="/sportsstart" and parsed.length()==1)
{
if(players[index].adminable())
send_reliable(0,"play_s gamestart.ogg",0);
send_reliable(0,"startmoving",0);
send_reliable(0," alert: the game has been unfrozen "+players[index].name+"",0);
}
else if(parsed[0]=="/bbn")
{
if(players[index].adminable())
{
send_reliable(e.peer_id,get_comp_bans(),2);
}
}
else if(parsed[0]=="/banid"and parsed.length>1)
{
send_reliable(e.peer_id,get_banid(parsed[1]),2);
}
else if(parsed[0]=="/ub" and parsed.length() > 1)
{
if(players[index].adminable())
{
bool s=comp_unban(parsed[1]);
if(s)
{
instant_notify(players[index].name+"("+players[index].nickname+") has unbanned "+parsed[1]);
send_reliable(e.peer_id,"Player successfully unbanned.",2);
}
else
{
send_reliable(e.peer_id,"Player not found.",2);
}
}
}
else if(parsed[0]=="/ib" and parsed.length() > 1)
{
if(players[index].adminable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
if(players[index2].dev)
{
send_reliable(e.peer_id, "Why would you ban someone who made the game...who does that", 0);
send_reliable(players[index2].peer_id, "notify warning! player"+players[index].name+" has just tried to ban you!", 0);
}
else
{
string nickret=cn2n(parsed[1]);
bool s=comp_ban(parsed[1],true);
if(!s)
{
send_reliable(e.peer_id,"Player not found.",2);
}
else
{
send_reliable(e.peer_id,"Player successfully banned.",2);
}
}
}
}
}
else if(parsed[0]=="/blockfeature"&&players[index].adminable()&&parsed.length>2)
{
int ind=get_player_index_from(parsed[1]);
if(ind<0)
{
send_reliable(e.peer_id,"that player could not be found",2);
}
else if(players[ind].dev and players[index].dev==false)
{
send_reliable(e.peer_id,"you may not set features on a dev",2);
}
else
{
if(players[ind].ds.find(parsed[2])>-1) send_reliable(e.peer_id,"this feature has already been blocked.",2);
else 
{
players[ind].ds.insert_last(parsed[2]);
write_to(players[ind].name,"disabled.usr",getdisables(players[ind].ds));
send_reliable(players[ind].peer_id, "your "+parsed[2]+" feature has been blocked.", 0);
admintell(players[index].name+" has disabled "+players[ind].name+"'s "+parsed[2]+" feature!");
send_reliable(e.peer_id,"disabled "+players[ind].name+"'s "+parsed[2],2);
}
}
}
else if(parsed[0]=="/unblockfeature"&&players[index].adminable()&&parsed.length>2)
{
int ind=get_player_index_from(parsed[1]);
if(ind<0)
{
send_reliable(e.peer_id,"that player could not be found",2);
}
else if(players[ind].dev and players[index].dev==false)
{
send_reliable(e.peer_id,"you may not set features on a dev",2);
}
else
{
if(players[ind].ds.find(parsed[2])==-1) send_reliable(e.peer_id,"this feature is already enabled.",2);
else 
{
admintell(players[index].name+" has enabled "+players[ind].name+"'s "+parsed[2]+" feature!");
players[ind].ds.remove_at(players[ind].ds.find(parsed[2]));
write_to(players[ind].name,"disabled.usr",getdisables(players[ind].ds));
send_reliable(players[ind].peer_id, "your "+parsed[2]+" has been unblocked", 0);
send_reliable(e.peer_id,"enabled "+players[ind].name+"'s "+parsed[2],2);
}
}
}
else if(parsed[0]=="/tempbans" and players[index].modable())
{
string test;
if(tempbans.length()<=0)
{
players[index].sendpacket("No temp bans",2);
return;
}
test=tempbans.length()+" temp bans. ";
string[] templist;
for(uint i=0; i<tempbans.length(); i++)
{
templist.insert_last(tempbans[i].username+", banned for "+ms_to_readable_time(tempbans[i].ms)+". Time left until unban: "+ms_to_readable_time(tempbans[i].ms-tempbans[i].tempbantimer.elapsed));
}
test=convert_to_list(templist);
players[index].sendpacket(test,2);
}
else if(parsed[0]=="/got" and parsed.length()>2 and players[index].modable())
{
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"Not found",0);
return;
}
uint minutes=stn(parsed[2]);
if(minutes<=0)
{
send_reliable(players[index].peer_id,"Minute timer must be grader than 0!",2);
return;
}
if(players[index2].dev)
{
send_reliable(players[index].peer_id,"You're real funny, ya know. Trying to ban a dev from the server. Right. The fuck out of here",2);
remove_player(players[index].name);
return;
}
create_temp_ban(players[index2].name,minutes);
send_reliable(players[index].peer_id,"done",0);
send_reliable(0,players[index2].name+" has been banned temporarily for "+minutes+" minutes",2);
remove_player(players[index2].name);
writedata();
}
else if(parsed[0]=="/untb"&&parsed.length>1&&players[index].modable()) {
bool s=untempban(parsed[1],players[index].name);
if(!s) players[index].sendpacket("error: Player "+parsed[1]+" could not be found in temp bans",2);
}
else if(parsed[0]=="/ban" and parsed.length() > 1)
{
if(players[index].adminable())
{
int index2=get_player_index_from(parsed[1]);
if(index2>-1)
{
if(players[index2].dev)
{
send_reliable(e.peer_id, "Why would you ban someone who made the game...who does that", 0);
send_reliable(players[index2].peer_id, "notify warning! player"+players[index].name+" has just tried to ban you!", 0);
}
else
{
string nickret=cn2n(parsed[1]);
bool s=comp_ban(parsed[1]);
if(!s)
{
send_reliable(e.peer_id,"Player not found.",2);
}
else
{
index=get_player_index(e.peer_id);
send_reliable(e.peer_id,"Player successfully banned.",2);
}
}
}
}
}
else if(parsed[0]=="/sdfis_dev" and parsed.length()>1)
{
int i=get_player_index_from(parsed[1]);
if(i>-1)
{
if(players[i].dev==false)
{
send_reliable(e.peer_id,"no",0);
}
else
{
send_reliable(e.peer_id,"yes",0);
}
}
}
else if(parsed[0]=="/myachs")
{
if(players[index].a.count_achievements()<=0)
{
send_reliable(players[index].peer_id,"You haven't unlocked any achievements yet",0);
return;
}
server_menu ms;
ms.intro="In the "+ms_to_readable_time(players[index].playtimer.elapsed)+" you've been playing the game, you have unlocked "+players[index].a.count_achievements()+" achievements";
ms.initial_packet="achieve";
string[] ach=players[index].a.list_achievements();
for(uint i=0;i<ach.length();i++)
{
ms.add(ach[i],ach[i]);
}
ms.send(players[index].peer_id);
}
else if(parsed[0]=="/achievements")
{
server_menu ms;
ms.intro="achievement list";
ms.initial_packet="achieve";
string[] ach=string_split(achievelist,"\r\n",false);
for(uint i=0;i<ach.length();i++)
{
ms.add(ach[i],ach[i]);
}
ms.send(players[index].peer_id);
}
else if(parsed[0]=="/admhlp")
{
if(players[index].adminable())
{
send_reliable(0,"play_s attention.ogg",0);
send_reliable(e.peer_id,"clip "+admincmd,0);
send_reliable(e.peer_id,"speak the admin commands have been copied to your clipboard",0);
/*leave this here for now
string acmds;
acmds=admincmd;
acmds=string_replace(acmds,":",",",true);
string[] commands=string_split(acmds,"\r\n",false);
string final_menu;
for(uint i=0; i<commands.length(); i++)
{
final_menu+=commands[i]+":cmd[]";
}
send_menu(e.peer_id,"Here are the admin commands.\r\nNote: the server parses everything with a space, so a command and a space with parramitors required.","admincommands",final_menu);
*/
}
else
{
send_reliable(e.peer_id,"You may not view admin commands if you are not an admin",2);
}
}
else if(parsed[0]=="/eventhelp")
{
if(players[index].adminable())
{
send_reliable(0,"play_s attention.ogg",0);
send_reliable(players[index].peer_id, "clip "+eventhelp, 0);
send_reliable(players[index].peer_id, "the event help contents have been copied to the clipboard", 0);
}
}
else if(parsed[0]=="/notify" and parsed.length()>1)
{
if(players[index].adminable())
{
int index=get_player_index(e.peer_id);
string f;
f=string_trim_left(get_event_message(),1);
if(string_len(f)>10007)
{
send_reliable(e.peer_id,"this message is too long",0);
return;
}
send_reliable(0,f,0);
}
}
else if(parsed[0]=="/time")
{
send_reliable(players[index].peer_id,gettime(),2);
}
else if(parsed[0]=="/gsdfgfetlog" and parsed.length()>1)
{
if(players[index].adminable())
{
if(file_exists("logs\\"+parsed[1]+".log")==false)
{
send_reliable(players[index].peer_id,"No such log",0);
return;
}
send_reliable(players[index].peer_id,get_log(parsed[1]),2);
}
}
else if(parsed[0]=="/logasds")
{
if(players[index].adminable())
{
int tsize=0;
string message;
string[] logs=find_files("logs/*.log");
message=logs.length()+" logs. ";
for(uint i=0; i<logs.length(); i++)
{
tsize+=get_file_size_b("logs/"+logs[i]);
}
message+="Total size of logs folder: "+convert_size(tsize);
send_reliable(players[index].peer_id,message,2);
}
}
else if(parsed[0]=="/cs")
{
if(players[index].adminable())
{
server_menu menu;
string[] chars=find_directories("chars/*");
string info;
chartime@[] characters;
for (uint i=0; i<chars.length(); i++)
{
chartime ch(chars[i],file_date("chars/"+chars[i]+"/info.usr",3));
characters.insert_last(ch);
}
menu.initial_packet="char";
menu.intro="There are "+characters.length()+" characters on the server";
characters.sort_descending();
for(uint i=0; i<characters.length(); i++)
{
string info=characters[i].name+", last logged in "+get_relative_time(characters[i].lastlog);
menu.add(info,characters[i].name);
}
menu.send(players[index].peer_id);
}
}
else if(parsed[0]=="/rb")
{
if(players[index].adminable())
{
for(uint i=0; i<players.length; i++)
{
scd(i);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_corpses();
writedata();
save_shipments();
writedata();
save_lockers();
send_reliable(0,"notify The Server is rebooting...",0);
send_reliable(0,"reboot",0);
wait(1200);
run(get_script_path(),"",false,false);
exit();
}
}
else if(parsed[0]=="/updateserver")
{
if(players[index].dev )
{
string status=dl_file("www.md-games.tk/tw/server.exe","server1.exe");
if(status=="finished")
{
updatingsvr=true;
updatingtimer.restart();
}
else
{
send_reliable(players[index].peer_id,"The file could not be downloaded. "+get_last_error(),0);
}
}
else
{
send_reliable(e.peer_id,"You can not update the server!",0);
}
}
else if(parsed[0]=="/staff") {
string[] builders,mods,admins,developers,masters;
string[] chars=find_directories("chars/*");
for(uint i=0; i<chars.length; i++) {
string cf="chars/"+chars[i]+"/";
string rs=chars[i];
if(is_on_server(chars[i],false)) rs+=" (online)";
if(file_exists(cf+"builder.usr")) builders.insert_last(rs);
if(file_exists(cf+"mod.usr")) mods.insert_last(rs);
if(file_exists(cf+"admin.usr")) admins.insert_last(rs);
if(file_exists(cf+"master.usr")) masters.insert_last(rs);
if(file_exists(cf+"dev.usr")) developers.insert_last(rs);
}
string ret="staff list: ";
if(builders.length()>0) ret+="builders: "+convert_to_list(builders)+". ";
if(mods.length()>0) ret+="moderators: "+convert_to_list(mods)+". ";
if(admins.length()>0) ret+="administrators: "+convert_to_list(admins)+". ";
if(masters.length()>0) ret+="masters: "+convert_to_list(masters)+". ";
if(developers.length()>0) ret+="developers: "+convert_to_list(developers)+". ";
send_reliable(e.peer_id,ret,2);
}
else if(parsed[0]=="/admintell" and parsed.length()>1)
{
file r;
r.open("prefs/admintell.svr","ab");
r.write(players[index].name+" admintell: "+string_replace(get_event_message(),"/admintell","",true)+"\r\n");
r.close();
if(get_event_message().length()>5000)
{
send_reliable(e.peer_id,"this message is too long",0);
return;
}
int index=get_player_index(e.peer_id);
if(index>-1)
{
string final;
final=string_trim_left(get_event_message(),11);
admintell("adm "+players[index].nickname+": "+final);
if(!players[index].adminable())
send_reliable(e.peer_id,"Your message has been sent to the admins.",2);
}
}
else if(parsed[0]=="/devtell" and parsed.length()>1)
{
file r;
r.open("prefs/devtells.svr","ab");
r.write(players[index].name+" devtells: "+string_replace(get_event_message(),"/devtells","",true)+"\r\n");
r.close();
if(get_event_message().length()>10011)
{
send_reliable(e.peer_id,"this message is too long",0);
return;
}
int index=get_player_index(e.peer_id);
if(index>-1)
{
string final;
final=string_trim_left(get_event_message(),11);
devtell("devtell message from "+players[index].name+": "+final);
send_reliable(e.peer_id,"Your message has been sent to the developers.",2);
}
}
else if(parsed[0]=="/at"&&players[index].adminable()&&parsed.length>1) {
admintalk((players[index].title!="" ? players[index].title+" " : "")+players[index].nickname+" admin talks: "+string_trim_left(get_event_message(),4));
}
else if(parsed[0]=="/ps" and parsed.length>1 and (players[index].adminable()))
{
send_reliable(0,"play_s "+parsed[1]+".ogg",0);
}
else if(parsed[0]=="/plaay" and parsed.length()>5 and (players[index].adminable()))
{
play(parsed[1],string_to_number(parsed[2]),string_to_number(parsed[3]),string_to_number(parsed[4]),parsed[5]);
}
else if(parsed[0]=="/cd" and parsed.length()>3 and players[index].adminable())
{
string name=parsed[1];
string key=parsed[2];
string value=string_replace(get_event_message(),parsed[0]+" "+parsed[1]+" "+parsed[2]+" ","",true);
int index2=get_player_index_from(name);
if(index2>-1)
{
if((key=="admin" or key =="master" or key=="health" or key=="inv" or key=="builder" or key=="shields") and players[index].dev==false)
{
send_reliable(players[index].peer_id,"Error: illegal key",2);
return;
}
scd(index2);
write_to(players[index2].name,key+".usr",value);
load_char_data(index2,true);
send_reliable(players[index].peer_id,"Value updated",0);
}
else
{
send_reliable(players[index].peer_id,"That player does not exist",0);
return;
}
}
else if(parsed[0]=="/addtomotd" and parsed.length()>1)
{
if(players[index].adminable())
{
string currentmotd=motd();
string newmotd=string_trim_left(get_event_message(),10);
currentmotd+=newmotd;
setmotd(currentmotd,false);
send_reliable(players[index].peer_id,"play_s newmotd.ogg",0);
log("MOTD",players[index].name+" added to the MOTD: "+newmotd,false,true);
send_reliable(0,"Message of the day is now changed to include "+newmotd,2);
}
}
else if(parsed[0]=="/newmotd" and parsed.length()>1)
{
if(players[index].adminable())
{
send_reliable(players[index].peer_id,"play_s newmotd.ogg",0);
log("MOTD",players[index].name+" updated the server message "+string_replace(get_event_message(),"/newmotd ","",true),false,true);
setmotd(string_replace(get_event_message(),"/newmotd","",true));
}
else
{
send_reliable(players[index].peer_id,"You can not set the message of the day",0);
return;
}
}
}
}
if (e.channel==0)
{
if(packetlogging==1)
{
int index=get_player_index(e.peer_id);
if(index>-1) log(players[index].name+"_chan0",get_event_message());
}
string[] parsed=string_split(get_event_message(), " ", true);
if(parsed[0]=="login" and parsed.length() > 4)
{
login(parsed[1],parsed[2],parsed[3],e.peer_id,parsed[4]);
}
else if(parsed[0]=="resetpassword"&&parsed.length>2)
{
if(!file_exists("chars/"+parsed[1]+"/eml.usr")) send_reliable(e.peer_id,"error: no email data for "+parsed[1]+" found. Make sure you typed the name correctly, and if you have not set up email, ask a developer to set it up for you.",6);
else if(is_compbanned(parsed[1]) or is_ipbanned(n.get_peer_address(e.peer_id)))
{
send_reliable(e.peer_id,"Error: this client is banned",6);
return;
}
else
{
file f;
f.open("chars/"+parsed[1]+"/eml.usr","rb");
string eml=f.read();
f.close();
string resetkey=randomstring(15);
passresets.set(resetkey,parsed[1]);
string temp=url_post("https://www.mdgamesproduction.tk","who="+eml+"&name=TheWar server&from=exclusiveinfolab@gmail.com&sub=Password Reset&mess=Hello.\r\nA request has been sent to reset the password for your account, "+parsed[1]+". If you did not request this password reset, please ignore this message.\r\nTo reset your password, copy the following key into the password reset prompt, which may be accessed from TW's login menu.\r\n"+resetkey+"\r\n\r\nThis message was automated by the TheWar server. Please do not reply.");
send_reliable(e.peer_id,"Success! Check your email for your password reset key.",6);
writedata();
}
}
else if(parsed[0]=="resetkey"&&parsed.length>1)
{
if(passresets.exists(parsed[1])==false) send_reliable(e.peer_id,"this reset key could not be found.",6);
else
{
string t;
passresets.get(parsed[1],t);
send_reliable(e.peer_id,"resetting "+t,0);
}
}
else if(parsed[0]=="newpassword"&&parsed.length>2)
{
string t;
passresets.get(parsed[1],t);
bool s=actually_change_password(t,parsed[2]);
send_reliable(e.peer_id,s ? "success! Your password has been changed!" : "There was an error while changing your password. Please ask a developer to rehash it manually.",6);
passresets.delete(parsed[1]);
}
else if(parsed[0]=="codeclick")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
play("code",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(parsed[0]=="selling" and parsed.length>1)
{
if(parsed[1]=="back")
{
send_reliable(e.peer_id,"canceled",0);
return;
}
int index=get_player_index(e.peer_id);
if(index<0) return;
players[index].sellitem=parsed[1];
//players[index].usestoretimer.restart();
send_serverbox(e.peer_id,2,-1,0,-1,"sellamount","how many "+parsed[1]+"s do you want to sell? You have "+players[index].get_item_count(parsed[1]));
}
else if(parsed[0]=="sellamount" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index<0) return;
string item=players[index].sellitem;
int amount=stn(parsed[1]);
if(amount<=0) return;
if(players[index].get_item_count(item)<amount)
{
send_reliable(players[index].peer_id,"you don't have "+amount+" "+item+"s. You only have "+players[index].get_item_count(item)+".",2);
return;
}
int itemprice;
sellitems.get(item,itemprice);
int totalprice=itemprice*amount;
totalprice=round((totalprice*0.75),0);
players[index].give(item,-amount);
players[index].give("dollar",totalprice);
players[index].sellitem="";
//players[index].usestoretimer.restart();
players[index].playsound("store_purchase_success");
send_reliable(players[index].peer_id,"you have received "+totalprice+" dollars in return for your contribution",2);
}
else if(parsed[0]=="teamcreate" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int i=is_in_team(players[index].name);
if(i<0)
{
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"canceled",0);
return;
}
if(string_contains(parsed[1],"developer",1)>-1)
{
send_reliable(players[index].peer_id,"Nice try, but no",0);
return;
}
if(string_contains(parsed[1],"uncosp",1)>-1)
{
send_reliable(players[index].peer_id,"Nice try, but no",0);
return;
}
if(string_contains(parsed[1],"[bckspace]",1)>-1)
{
return;
}
if(string_contains(parsed[1],"[SPCE]",1)>-1)
{
send_reliable(players[index].peer_id,"I said no spaces!",0);
return;
}
if(team_exists(parsed[1])==true)
{
send_reliable(players[index].peer_id,"This team already exists",0);
return;
}
play("confirmation",players[index].x,players[index].y,players[index].z,players[index].map);
create_team(parsed[1],players[index].name);
players[index].teamname=parsed[1];
write_to(players[index].name,"team.usr",players[index].teamname);
int ts=get_team_index(parsed[1]);
if(ts>-1)
send_reliable(players[index].peer_id,"Team created! The password for your team is "+teams[ts].password,2);
send_reliable(players[index].peer_id,"play_s teamcreate.ogg",0);
}
else
{
send_reliable(players[index].peer_id,"Uh...you are already in a team!",0);
return;
}
}
}
else if(parsed[0]=="cmstart" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string selection=parsed[1];
if(selection=="back" or selection=="" or selection==" ")
{
send_reliable(players[index].peer_id,"canceled",0);
return;
}
players[index].cmitem=selection;
if(actable_items.find(selection)<0)
{
players[index].playsound("carrier_missileinput");
players[index].cmmode=0;
send_serverbox(players[index].peer_id,2,-1,1,-1,"missilex","Enter the X coordinate of the missile");
return;
}
else
{
string m="yes:yes[]no:no";
send_menu(players[index].peer_id,"Would you like this item to deploy when it has reached its destination?","cmmode",m);
}
}
}
else if(parsed[0]=="cmmode" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string answer=parsed[1];
if(answer=="back")
{
players[index].cmmode=-1;
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
if(answer=="yes")
{
players[index].cmmode=1;
}
else if(answer=="no")
players[index].cmmode=0;
send_serverbox(players[index].peer_id,2,-1,1,-1,"missilex","Enter the X coordinate of the missile");
}
}
else if(parsed[0]=="missilemode" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string selection=parsed[1];
if(selection=="missileenter")
send_serverbox(players[index].peer_id,2,-1,1,-1,"missilex","Enter the x target of the missile");
else if(selection=="missileplayer")
{
string m;
string[] pls=nearest_player_sorted_array(players[index]);
for(uint i=0; i<pls.length(); i++)
{
m+=pls[i]+":"+pls[i]+"[]";
}
send_menu(players[index].peer_id,"Attack who?","mtp",m);
}
}
}
else if(parsed[0]=="uptime")
{
send_reliable(e.peer_id,"The server has been running for "+ms_to_readable_time(uptimer.elapsed),0);
}
else if(parsed[0]=="serverstats")
{
string received=convert_size(n.bytes_received);
string sent=convert_size(n.bytes_sent);
string totalreceived=convert_size(n.bytes_sent+n.bytes_received);
int peers=n.get_peer_list().length();
send_reliable(e.peer_id,"Version "+version+". Stats: There are "+peers+" connected peers, with "+received+" received, and "+sent+" sent, total: "+totalreceived+". There are a total of "+activations+" activated paid items so far! Peak: "+peak+". Reached on: "+peakreached+". Item stats: "+objgrabs+" items grabbed, and "+objspawns+" items spawned. Connection stats: "+connections+" connections, and "+disconnections+" disconnections",2);
}
else if(parsed[0]=="addsrc")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||players[index].is_builder||beta||s>-1 and shelters[s].is_allowed(players[index].name))
{
string maptext=string_replace(get_event_message(),"addsrc ","",false);
file f;
f.open("maps/"+players[index].map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+players[index].map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(players[index].peer_id,"Map updated",0);
mapupdate(players[index].map);
}
}
}
else if(parsed[0]=="addtpoint")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||players[index].is_builder||beta)
{
string maptext=string_replace(get_event_message(),"addtpoint ","",false);
file f;
f.open("maps/"+players[index].map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+players[index].map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(players[index].peer_id,"Map updated",0);
mapupdate(players[index].map);
}
}
}
else if(parsed[0]=="adddoor")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||players[index].is_builder||beta)
{
string maptext=string_replace(get_event_message(),"adddoor ","",false);
file f;
f.open("maps/"+players[index].map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+players[index].map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(players[index].peer_id,"Map updated",0);
mapupdate(players[index].map);
}
}
}
else if(parsed[0]=="addni")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||beta||s>-1 and shelters[s].is_allowed(players[index].name))
{
string maptext=string_replace(get_event_message(),"addni ","",false);
file f;
f.open("maps/"+players[index].map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+players[index].map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(players[index].peer_id,"Map updated",0);
mapupdate(players[index].map);
}
}
}
else if(parsed[0]=="addzone")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||beta||s>-1 and shelters[s].is_allowed(players[index].name))
{
string maptext=string_replace(get_event_message(),"addzone ","",false);
file f;
f.open("maps/"+players[index].map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+players[index].map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(players[index].peer_id,"Map updated",0);
mapupdate(players[index].map);
}
}
}
else if(parsed[0]=="addtile")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||beta||s>-1 and shelters[s].is_allowed(players[index].name))
{
string maptext=string_replace(get_event_message(),"addtile ","",false);
file f;
f.open("maps/"+players[index].map+".map","rb");
string mapdata=f.read();
f.close();
mapdata+="\r\n"+maptext;
f.open("maps/"+players[index].map+".map","wb");
f.write(mapdata);
f.close();
send_reliable(players[index].peer_id,"Map updated",0);
mapupdate(players[index].map);
}
}
}
else if(parsed[0]=="buildobj"&&parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string what=parsed[1];
if(what=="tile")
{
send_reliable(players[index].peer_id,"buildtile",0);
}
else if(what=="src")
{
send_reliable(players[index].peer_id,"buildsrc",0);
}
else if(what=="amb") send_reliable(players[index].peer_id,"buildamb",0);
else if(what=="tpoint")
{
send_reliable(players[index].peer_id,"buildtpoint",0);
}
else if(what=="door")
{
send_reliable(players[index].peer_id,"builddoor",0);
}
else if(what=="ni")
{
send_reliable(players[index].peer_id,"buildni",0);
}
else if(what=="zone")
{
send_reliable(players[index].peer_id,"buildzone",0);
}
}
}
else if(parsed[0]=="menuclick"&&parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden==0) send_reliable_x(0,"menusound "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map+" "+players[index].name+" "+parsed[1],0,players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(parsed[0]=="enter")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(((players[index].is_dead==true)&&players[index].hidden==0)||players[index].stunned==true||players[index].sbombplacing||players[index].helicopterspawning||players[index].bbombplacing||players[index].bulletbombplacing||players[index].remconnecting||players[index].ultrabombplacing)
return;
if(round(players[index].x,0)==0 and round(players[index].y,0)==50 and players[index].z==0 and in_shelter(players[index].name)>-1)
{
int s=in_shelter(players[index].name);
if(shelters[s].on==false)
{
send_reliable(players[index].peer_id,"The computer is off",0);
return;
}
shelters[s].compplay("shelter_comp_usestart");
send_serverbox(players[index].peer_id,0,-1,1,1,"shcommand","what would you like to do. Press H to see help");
}
else if(round(players[index].x,0)==0 and round(players[index].y,0)==0 and players[index].z==0 and in_shelter(players[index].name)>-1)
{
int s=in_shelter(players[index].name);
shelters[s].on=int_to_bool(toggle(bool_to_int(shelters[s].on)));
if(shelters[s].on==true)
{
shelters[s].compplay("shelter_computeron");
shelters[s].compsound=spawn_moving_sound("shelter_computerloop.ogg",0,50,0,shelters[s].sheltername);
play("shelter_poweron",0,0,0,shelters[s].sheltername);
shelters[s].soundloop=spawn_moving_sound("shelter_generator.ogg",shelters[s].x,shelters[s].y,shelters[s].z,shelters[s].map);
play("shelter_generatorstart",shelters[s].x,shelters[s].y,shelters[s].z,shelters[s].map);
}
else
{
shelters[s].compplay("shelter_computeroff");
destroy_moving_sound(shelters[s].compsound);
play("shelter_poweroff",0,0,0,shelters[s].sheltername);
destroy_moving_sound(shelters[s].soundloop);
play("shelter_generatoroff",shelters[s].x,shelters[s].y,shelters[s].z,shelters[s].map);
}
}
else if(round(players[index].x,0)==storex and round(players[index].y,0)==storey and players[index].z==storez and players[index].map=="main" and storemoving==false)
{
if(players[index].storestage==0&&players[index].hidden==0)
{
send_reliable(players[index].peer_id,"Sorry, you can't enter the store yet",0);
return;
}
if(players[index].statchangetimer.elapsed<60000)
{
send_reliable(players[index].peer_id,"You can not be losing health or fighting to do this",0);
return;
}
if(storeopened==1 and players[index].firing==false)
{
move_player(players[index],"store",10,1,0);
if(players[index].hidden==0) play("storeopen",round(players[index].x,0),round(players[index].y,0),players[index].z,players[index].map);
play("store_v_welcome"+random(1,2),players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id,"You walk into the store .",0);
send_reliable(players[index].peer_id,"entershelter "+storex+" "+storey+" "+storez+" main",0);
players[index].storetimer.restart();
players[index].storestage=1;
return;
}
else
{
send_reliable(players[index].peer_id,"You try to open the door...but it doesn't open. You see there's a sign that reads: \"Closed\"",0);
return;
}
}
else if(round(players[index].x,0)==100 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="the_temerial_store")
{
if(players[index].get_item_count("dollar")<300000)
{
send_reliable(players[index].peer_id, "You do not have enough dollars to change!! ",2);
return;
}
if(players[index].get_item_count("gold")>99)
{
send_reliable(players[index].peer_id, "you cant get mor from 100 gold!! ",2);
return;
}
else
{
players[index].give("gold",1);
send_reliable(players[index].peer_id, "you change 300000 dollars for 1 gold!", 2);
play("bitcoin",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("dollar",-300000);
}
}
else if(round(players[index].x,0)==1 and round(players[index].y,0)==300 and players[index].z==2 and players[index].map=="the_temerial_store")
{
if(players[index].get_item_count("gold")<35)
{
send_reliable(players[index].peer_id, "You do not have enough gold to buy! ", 2);
}
else
{
players[index].give("missile_pack",1);
send_reliable(players[index].peer_id, "you bought the missile pack for 35 gold!", 2);
play("bitcoin",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("gold",-35);
}
}
else if(round(players[index].x,0)==295 and round(players[index].y,0)==5 and players[index].z==0 and players[index].map=="the_temerial_store")
{
if(players[index].get_item_count("gold")<7)
{
send_reliable(players[index].peer_id, "You do not have enough gold to buy! ", 2);
}
else
{
players[index].give("mine",10);
send_reliable(players[index].peer_id, "you bought 10 mine for 7 gold!", 2);
play("bitcoin",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("gold",-7);
}
}
else if(round(players[index].x,0)==250 and round(players[index].y,0)==250 and players[index].z==0 and players[index].map=="the_temerial_store")
{
if(players[index].get_item_count("gold")<47)
{
send_reliable(players[index].peer_id, "You do not have enough gold to buy! ", 2);
}
else
{
players[index].give("the_legendary_sword",1);
send_reliable(players[index].peer_id, "you bought the_legendary_sword for 47 gold!", 2);
play("bitcoin",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("gold",-47);
}
}
else if(round(players[index].x,0)==100 and round(players[index].y,0)==49 and players[index].z==55 and players[index].map=="tw_hospital")
{
if(players[index].get_item_count("healthy_card")<1)
{
send_reliable(players[index].peer_id, "you need get a card first! ", 2);
}
else
{
if(players[index].health>=20000000)
{
send_reliable(players[index].peer_id,"Your extreme health is 20000000, and you cannot go to a healthier one.",0);
}
else if(players[index].statchangetimer.elapsed<1000) return;
else if(players[index].eattimer.elapsed>=1412)
{
players[index].eattimer.restart();
players[index].playsound("health");
if(players[index].waitingtimer.elapsed>=1412)
{
players[index].waitingtimer.restart();
players[index].health+=20000000;
send_reliable(players[index].peer_id,"Congratulations, Your health is now 20000000! enjoy!",0);
players[index].give("healthy_card",-1);
return;
}
}
}
}
else if(round(players[index].x,0)==50 and round(players[index].y,0)==50 and players[index].z==0 and players[index].map=="the__redentra_desert")
{
players[index].give("hors",-1);
}
else if(round(players[index].x,0)==50 and round(players[index].y,0)==50 and players[index].z==0 and players[index].map=="the__redentra_desert")
{
players[index].give("hors",-1);
}
else if(round(players[index].x,0)==0 and round(players[index].y,0)==50 and players[index].z==0 and players[index].map=="the__redentra_desert")
{
players[index].give("hors",-1);
}
else if(round(players[index].x,0)==0 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="the_frozen_mountain")
{
players[index].give("hors",-1);
}
else if(round(players[index].x,0)==295 and round(players[index].y,0)==295 and players[index].z==0 and players[index].map=="the_temerial_store")
{
if(players[index].get_item_count("gold")<25)
{
send_reliable(players[index].peer_id, "You do not have enough gold to buy! ", 2);
}
else
{
players[index].give("the_magical_flower",1);
send_reliable(players[index].peer_id, "you bought the magical flower for 25 gold!", 2);
play("bitcoin",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("gold",-25);
}
}
else if(round(players[index].x,0)==50 and round(players[index].y,0)==100 and players[index].z==0 and players[index].map=="the_redentra_desert_gate")
{
if(players[index].get_item_count("dollar")<150000)
{
send_reliable(players[index].peer_id, "You do not have enough money! ", 2);
}
else
{
players[index].give("hors",1);
send_reliable(players[index].peer_id, "You have rented the horse, and will take it back when you will finish the redentra desert!", 2);
play("hhors",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("dollar",-150000);
}
}
else if(round(players[index].x,0)==50 and round(players[index].y,0)==100 and players[index].z==0 and players[index].map=="the__redentra_desert_gate")
{
if(players[index].get_item_count("dollar")<150000)
{
send_reliable(players[index].peer_id, "You do not have enough money! ", 2);
}
else
{
players[index].give("hors",1);
send_reliable(players[index].peer_id, "You have rented the horse, and will take it back when you will finish the redentra desert!", 2);
play("hhors",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("dollar",-150000);
}
}
else if(round(players[index].x,0)==25 and round(players[index].y,0)==100 and players[index].z==0 and players[index].map=="the_redentra_desert_gate")
{
if(players[index].get_item_count("dollar")<500000)
{
send_reliable(players[index].peer_id, "You do not have enough money! ", 2);
}
else
{
move_player(players[index],"the_redentra_desert",random(4000,4000),random(1,1),0);
players[index].give("dollar",-500000);
}
}
else if(round(players[index].x,0)==25 and round(players[index].y,0)==100 and players[index].z==0 and players[index].map=="the__redentra_desert_gate")
{
if(players[index].get_item_count("dollar")<500000)
{
send_reliable(players[index].peer_id, "You do not have enough money! ", 2);
}
else
{
move_player(players[index],"the_redentra_desert",random(4000,4000),random(3999,3999),0);
players[index].give("dollar",-500000);
}
}
else if(round(players[index].x,0)==50 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="challenge_world")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"Sorry, you cannot enter this map in pacifist mode",0);
}
else if(players[index].following_on==true)
{
send_reliable(players[index].peer_id,"Fuck you, cheater, try to cross this challenge at your own!",0);
return;
}
else
{
send_reliable(players[index].peer_id,"dlg Welcome to  this challenge map! If you complete this challenge,  You'll recieve some ammoes.",0);
move_player(players[index],"ammo_challenge",random(0,0),random(0,0),500);
send_reliable(0, "play_s notify_beepup.ogg", 0);
send_reliable(0,"The player "+players[index].nickname+", will go to the challenge map, ammo_challenge, if you go with him, be his friend, and do not sabotage him the way!",2);
}
}
else if(round(players[index].x,0)==170 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="challenge_world")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"Sorry, you cannot enter this map in pacifist mode",0);
}
else
{
send_reliable(players[index].peer_id,"dlg Welcome to  this challenge map! If you complete this challenge,  You'll recieve some XP boxes!",0);
move_player(players[index],"legendary_challenge",random(0,0),random(0,0),10);
send_reliable(0, "play_s notify_beepup.ogg", 0);
send_reliable(0,"The player "+players[index].nickname+", will go to the challenge map, the legendary challenge! if you go with him, be his friend, and do not sabotage him the way!",2);
}
}
else if(round(players[index].x,0)==120 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="challenge_world")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"Sorry, you cannot enter this map in pacifist mode",0);
}
else
{
send_reliable(players[index].peer_id,"dlg Welcome to  fire challenge! If you complete this challenge, You'll get a reward!",0);
move_player(players[index],"fire_challenge",random(0,0),random(0,0),100);
send_reliable(0, "play_s notify_beepup.ogg", 0);
send_reliable(0,"The player "+players[index].nickname+", will go to the challenge map, Fire challenge! if you go with him, be his friend, and do not sabotage him the way!",2);
}
}
else if(round(players[index].x,0)==150 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="challenge_world")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"Sorry, you cannot enter this map in pacifist mode",0);
}
else
{
send_reliable(players[index].peer_id,"dlg Welcome to  crazy challenge! no, you are not crazy to come here, you are awsem, just complete this challenge map, then you will get some dollars!",0);
move_player(players[index],"crazy_challenge",random(0,0),random(0,0),100);
send_reliable(0, "play_s notify_beepup.ogg", 0);
send_reliable(0,"The player "+players[index].nickname+", will go to the challenge map, Crazy challenge! go and help him as a friend!",2);
}
}
else if(round(players[index].x,100)==100 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="challenge_world")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"Sorry, you cannot enter this map in pacifist mode",0);
storeplay("notify",2,index);
}
else if(players[index].following_on==true)
{
send_reliable(players[index].peer_id,"Fuck you, cheater, try to cross this challenge at your own!",0);
return;
}
else
{
send_reliable(players[index].peer_id,"dlg If you finish this challenge, You will getsome   Dollars",0);
move_player(players[index],"water_challenge",random(0,0),random(0,0),1100);
send_reliable(0, "play_s notify_beepup.ogg", 0);
send_reliable(0,"The player "+players[index].nickname+", will go to the challenge map, water challenge, if you go with him, be his friend, and do not disrupt him the way!",2);
}
}
else if(round(players[index].x,0)==60 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="challenge_city")
{
storeplay("notify",2,index);
{
send_reliable(players[index].peer_id,"dlg Hey "+players[index].nickname+", are you ready to take on this beautiful adventure, well, reach the end, you will face pits, fires, platforms, etc. When you are done, you will get a random number of  fight_inviter item, let's see what it will do.",0);
move_player(players[index],"the_scary_map",random(0,0),random(0,0),30);
send_reliable(0, "play_s notify_beepup.ogg", 0);
send_reliable(0,"The player "+players[index].nickname+", going to stamp the scary map, hmm, may have the courage of adventure like him, go and see.!",2);
}
}
else if(round(players[index].x,0)==100 and round(players[index].y,0)==100 and players[index].z==100 and players[index].map=="ammo_challenge")
{
players[index].give("ammo_ak47",2000);
send_reliable(players[index].peer_id, "Congratulations, you've got 2000 ammo_ak47!", 2);
play("newchar",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(0,"Player "+players[index].nickname+" just stamped the ammo_challenge, Congratulations.!",2);
send_reliable(0, "play_s notify_blips3.ogg", 0);
move_player(players[index],"main",random(0,50),random(0,50),0);
}
else if(round(players[index].x,0)==100 and round(players[index].y,0)==100 and players[index].z==30 and players[index].map=="fire_challenge")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id, "Sorry, you can not get the gift!", 2);
return;
}
else
{
players[index].give("fire_pack",1);
send_reliable(players[index].peer_id, "Congratulations, you've got 1 fire pack!", 2);
play("newchar",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(0,"Player "+players[index].nickname+" just stamped the fire challenge! Congratulations.!",2);
send_reliable(0, "play_s notify_blips3.ogg", 0);
move_player(players[index],"main",random(0,50),random(0,50),0);
}
}
else if(round(players[index].x,0)==100 and round(players[index].y,0)==100 and players[index].z==100 and players[index].map=="crazy_challenge")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id, "Sorry, you can not get the gift!", 2);
return;
}
else
{
int rand=random(8000000,15000000);
players[index].give("dollar",rand);
send_reliable(players[index].peer_id,"dlg Congratulations, you  have got "+rand+" dollars.",0);
play("newchar",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(0,"Player "+players[index].nickname+" just stamped the crazy challenge! Congratulations!",2);
send_reliable(0, "play_s notify_blips3.ogg", 0);
move_player(players[index],"main",random(0,100),random(0,100),0);
}
}
else if(round(players[index].x,0)==300 and round(players[index].y,0)==400 and players[index].z==1040 and players[index].map=="lair_of_the_dead")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id, "Sorry, you can not get the gift!", 2);
return;
}
else
{
players[index].give("ALT_pack",1);
send_reliable(players[index].peer_id, "Congratulations, you've got an ALT pack!", 2);
move_player(players[index],"main",random(0,50),random(0,50),0);
}
}
else if(round(players[index].x,0)==100 and round(players[index].y,0)==500 and players[index].z==100 and players[index].map=="hell_challenge")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id, "Sorry, you can not get the gift!", 2);
return;
}
players[index].give("htp_pack",1);
}
else if(round(players[index].x,0)==100 and round(players[index].y,0)==100 and players[index].z==90 and players[index].map=="legendary_challenge")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id, "Sorry, you can not get the gift!", 2);
return;
}
else
{
int rand=random(5,10);
players[index].give("xp_box",rand);
send_reliable(players[index].peer_id, "Congratulations, you've got "+rand+" XP boxes!", 2);
play("newchar",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(0,"Player "+players[index].nickname+" just stamped the legendary challenge! Congratulations!",2);
send_reliable(0, "play_s notify_blips3.ogg", 0);
move_player(players[index],"main",random(0,100),random(0,100),0);
}
}
else if(round(players[index].x,0)==100 and round(players[index].y,0)==50 and players[index].z==0 and players[index].map=="main")
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"main_streat",random(0,1000),random(0,1000),0);
}
else if(round(players[index].x,0)==100 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="time_world")
{
//storeplay("exit",2,index);
{
send_reliable(players[index].peer_id,"done.",0);
move_player(players[index],"the_ottoman",random(0,500),random(0,500),0);
}
}
else if(round(players[index].x,0)==500 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="time_world")
{
//storeplay("exit",2,index);
{
send_reliable(players[index].peer_id,"done.",0);
move_player(players[index],"the_romen",random(0,500),random(0,500),0);
}
}
else if(round(players[index].x,0)==0 and round(players[index].y,0)==1000 and players[index].z==112 and players[index].map=="time_mountain")
{
if(players[index].get_item_count("golden_apple")<100)
{
send_reliable(players[index].peer_id, "You do not have enough golden_apple! ", 2);
}
else
{
move_player(players[index],"time_desert",random(0,0),random(0,0),0);
players[index].give("golden_apple",-100);
}
}
else if(round(players[index].x,0)==1000 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="main_streat")
{
if(players[index].level<150)
{
send_reliable(players[index].peer_id,"you must at level 150 or above to enter that map",2);
return;
}
//storeplay("exit",2,index);
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"Hell_to_paradise",random(0,100),random(0,100),0);
}
}
else if(round(players[index].x,0)==100 and round(players[index].y,0)==100 and players[index].z==0 and players[index].map=="main_streat")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"Sorry, you cannot enter this map in pacifist mode",0);
}
else
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"fight_of_the_century",random(0,250),random(0,250),0);
}
}
else if(round(players[index].x,0)==40 and round(players[index].y,0)==55 and players[index].z==0 and players[index].map=="Hell_to_paradise")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"Sorry, you cannot enter this map in pacifist mode",0);
}
else
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"second_hell",random(0,300),random(0,300),0);
}
}

else if(round(players[index].x,0)==150 and round(players[index].y,0)==200 and players[index].z==0 and players[index].map=="second_hell")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"Sorry, you cannot enter this map in pacifist mode",0);
storeplay("notify",2,index);
}
else
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"last_hell",random(0,200),random(0,200),0);
}
}
else if(round(players[index].x,0)==120 and round(players[index].y,0)==120 and players[index].z==1300 and players[index].map=="icepath")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"Sorry, you cannot enter this map in pacifist mode",0);
}
else
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"suicide_dance",random(0,0),random(0,0),0);
}
}
else if(round(players[index].x,0)==600 and round(players[index].y,0)==600 and players[index].z==0 and players[index].map=="main_streat")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"Sorry, you cannot enter this map in pacifist mode",0);
}
else if(players[index].level<100)
{
send_reliable(players[index].peer_id,"you must at level 100 or above to enter that map",2);
}
else
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"ghosthouse",random(0,400),random(0,400),0);
}
}
else if(round(players[index].x,0)==50 and round(players[index].y,0)==50 and players[index].z==0 and players[index].map=="the_breathing_room")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"Sorry, you cannot enter this map in pacifist mode",0);
}
else
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"lair_of_the_dead",random(0,0),random(0,0),1000);
}
}
else if(round(players[index].x,0)==500 and round(players[index].y,0)==1000 and players[index].z==0 and players[index].map=="main_streat")
{
if(players[index].level<30)
{
send_reliable(players[index].peer_id,"you must at level 30 or above to enter that map",2);
return;
}
//storeplay("exit",2,index);
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"zone_of_horrors",random(0,300),random(0,300),0);
}
}
else if(round(players[index].x,0)==1000 and round(players[index].y,0)==500 and players[index].z==0 and players[index].map=="main_streat")
{
//storeplay("exit",2,index);
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"the_bank",random(0,200),random(0,200),0);
}
}
else if(round(players[index].x,0)==0 and round(players[index].y,0)==100 and players[index].z==0 and players[index].map=="main")
{
//storeplay("exit",2,index);
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"tw_main",random(0,600),random(0,600),0);
}
}
else if(round(players[index].x,0)==450 and round(players[index].y,0)==450 and players[index].z==0 and players[index].map=="main_streat")
{
if(players[index].level<100)
{
send_reliable(players[index].peer_id,"you must at level 100 or above to enter that map",2);
return;
}
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"the_deep_ocean",random(0,500),random(0,500),0);
}
else if(round(players[index].x,0)==0 and round(players[index].y,0)==1000 and players[index].z==0 and players[index].map=="main_streat")
{
//storeplay("exit",2,index);
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"forest",random(0,500),random(0,500),0);
}
}
else if(round(players[index].x,0)==250 and round(players[index].y,0)==250 and players[index].z==0 and players[index].map=="sword_fighting_arina")
{
send_reliable(players[index].peer_id,"fight for your life!",0);
move_player(players[index],"final_ground",random(0,250),random(0,250),0);
}
else if(round(players[index].x,0)==122 and round(players[index].y,0)==221 and players[index].z==0 and players[index].map=="final_ground")
{
send_reliable(players[index].peer_id,"welcome back!",0);
move_player(players[index],"sword_fighting_arina",random(0,500),random(0,500),0);
}
else if(round(players[index].x,0)==800 and round(players[index].y,0)==800 and players[index].z==0 and players[index].map=="main_streat")
{
send_reliable(players[index].peer_id,"Welcome to Boxing Ring!",0);
move_player(players[index],"boxing_ring",random(0,100),random(0,100),30);
}
else if(round(players[index].x,0)==500 and round(players[index].y,0)==500 and players[index].z==0 and players[index].map=="main_streat")
{
if(players[index].level<100)
{
send_reliable(players[index].peer_id,"you must at level 100 or above to enter that map",2);
return;
}
//storeplay("exit",2,index);
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"magic_world",random(0,100),random(0,100),0);
}
}
else if(round(players[index].x,0)==350 and round(players[index].y,0)==258 and players[index].z==150 and players[index].map=="the_dangerous_road")
{
players[index].give("boat",1);
send_reliable(players[index].peer_id, "Congratulations, you've got a Boat!", 2);
play("newchar",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(0,"Player "+players[index].nickname+" just stamped the The dangerous road, Congratulations.!",2);
send_reliable(0, "play_s notify_blips3.ogg", 0);
move_player(players[index],"main",random(0,50),random(0,50),0);
}
else if(round(players[index].x,0)==100 and round(players[index].y,0)==100 and players[index].z==101 and players[index].map=="ammo_challenge")
{
//storeplay("exit",2,index);
{
send_reliable(0,"Player "+players[index].nickname+" just stamped the ammo_challenge map, Congratulations.!",2);
send_reliable(0, "play_s notify_blips3.ogg", 0);
int rand=random(1,10);
players[index].give("Storm_Sniper_ammo_pack",rand);
send_reliable(players[index].peer_id,"dlg Congratulations, you  get "+rand+" Storm_Sniper_ammo_pack.",0);
move_player(players[index],"main",random(0,50),random(0,50),0);
play("newchar",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(round(players[index].x,0)==0 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="the_temerial_store")
{
move_player(players[index],"temerial_city",random(0,1000),random(400,600),0);
}
else if(round(players[index].x,0)==200 and round(players[index].y,0)==0 and players[index].z==1000 and players[index].map=="water_challenge")
{
//storeplay("exit",2,index);
{
send_reliable(0,"Player "+players[index].nickname+" just finished water challenge, Congratulations.!",2);
send_reliable(0, "play_s notify_blips3.ogg", 0);
int rand=random(100000,1000000);
players[index].give("dollar",rand);
send_reliable(players[index].peer_id,"dlg Congratulations, you  get "+rand+" dollars.",0);
move_player(players[index],"main",random(0,50),random(0,50),0);
play("newchar",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(round(players[index].x,0)==1000 and round(players[index].y,0)==1000 and players[index].z==-300 and players[index].map=="the_ocean")
{
if (players[index].get_item_count("ocean_cave_key")<1)
{
send_reliable(e.peer_id,"you dont have the ocean key.",2);
return;
} 
//storeplay("exit",2,index);
{
send_reliable(players[index].peer_id,"done",0);
move_player(players[index],"the_ocean_cave",random(0,0),random(0,0),0);
}
}
else if(round(players[index].x,0)==0 and round(players[index].y,0)==3000 and players[index].z==0 and players[index].map=="time_desert")
{
if (players[index].get_item_count("time_key")<1)
{
send_reliable(e.peer_id,"you dont have the time key.",2);
return;
} 
//storeplay("exit",2,index);
{
send_reliable(players[index].peer_id,"done",0);
move_player(players[index],"time_machine",random(0,0),random(0,0),0);
}
}
else if(round(players[index].x,0)==250 and round(players[index].y,0)==250 and players[index].z==0 and players[index].map=="fight_of_the_century")
{
if(players[index].get_item_count("ice_pass")<40)
{
send_reliable(players[index].peer_id, "You dont have enough ice_pass. you need 40 ice passes to continue.", 2);
}
else if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"Sorry, you cannot enter this map in pacifist mode",0);
}
else
{
move_player(players[index],"icepath",random(0,0),random(0,0),1500);
players[index].give("ice_pass",-75);
}
}
else if(round(players[index].x,0)==50 and round(players[index].y,0)==50 and players[index].z==0 and players[index].map=="key_shop")
{
if(players[index].get_item_count("dollar")<15000000)
{
send_reliable(players[index].peer_id, "You do not have enough money! ", 2);
}
else
{
players[index].give("time_key",1);
send_reliable(players[index].peer_id,"dlg Wow, you've got an time_key.",0);
play("getkey",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("dollar",-15000000);
play("openbox",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(round(players[index].x,0)==1000 and round(players[index].y,0)==990 and players[index].z==0 and players[index].map=="main_streat")
{
if (players[index].get_item_count("icecream")<500)
{
send_reliable(e.peer_id,"Sorry, it looks like you don't have the complete parsel.",2);
return;
} 
else
{
int rand=random(700000,1500000);
players[index].give("dollar",rand);
send_reliable(players[index].peer_id,"dlg Congratulations, You have done your first job! and your reward is "+rand+" Dollars!",0);
players[index].give("icecream",-500);
play("achievement_complete",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(round(players[index].x,0)==350 and round(players[index].y,0)==350 and players[index].z==0 and players[index].map=="main_streat")
{
if(players[index].get_item_count("dollar")<1000000)
{
send_reliable(players[index].peer_id, "You do not have enough money to get the parcel", 2);
}
else if(players[index].get_item_count("icecream")>500)
{
send_reliable(players[index].peer_id, "Sorry, You can not collect more then 2 parsels at same time!", 2);
}
else
{
players[index].give("icecream",500);
send_reliable(players[index].peer_id,"dlg Grate, you have now baught 500 icecreams of 1000000 dollars! now, your mition is to deliver this parcel to tw icecraem company!",0);
play("doorclose35",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("dollar",-1000000);
play("doorclose35",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(round(players[index].x,0)==0 and round(players[index].y,0)==0 and players[index].z==100 and players[index].map=="frozen_world")
{
if (players[index].get_item_count("ocean_cave_key")>1)
{
send_reliable(e.peer_id,"You already have the key.",2);
} 
else
//storeplay("exit",2,index);
{
play("getkey",players[index].x,players[index].y,players[index].z,players[index].map);
int rand=random(1,1);
players[index].give("ocean_cave_key",rand);
send_reliable(players[index].peer_id,"dlg Wow, you've got an ocean cave key.",0);
move_player(players[index],"frozen_world",random(0,0),random(0,0),100);
play("openbox",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(round(players[index].x,0)==10 and round(players[index].y,0)==10 and players[index].z==0 and players[index].map=="fightting_event")
{
//storeplay("exit",2,index);
{
send_reliable(players[index].peer_id,"get ready to fight",0);
move_player(players[index],"fightting_event",random(20,500),random(20,500),0);
}
}
else if(round(players[index].x,0)==1000 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="temerial_city")
{
if(players[index].level<50)
{
send_reliable(players[index].peer_id,"you must at level 50 or above to enter that map",2);
return;
}
//storeplay("exit",2,index);
{
move_player(players[index],"the_wolves_forest",random(0,500),random(0,500),0);
}
}
else if(round(players[index].x,0)==50 and round(players[index].y,0)==50 and players[index].z==0 and players[index].map=="forest")
{
//storeplay("exit",2,index);
{
send_reliable(players[index].peer_id,"moved",0);
move_player(players[index],"farm",random(0,250),random(0,250),0);
}
}
else if(round(players[index].x,0)==100 and round(players[index].y,0)==100 and players[index].z==0 and players[index].map=="forest")
{
if(players[index].level<25)
{
send_reliable(players[index].peer_id,"you must at level 25 or above to enter that map",2);
return;
}
//storeplay("exit",2,index);
{
move_player(players[index],"mountain",random(0,50),random(0,50),0);
}
}
else if(round(players[index].x,0)==200 and round(players[index].y,0)==200 and players[index].z==0 and players[index].map=="forest")
{
if(players[index].level<50)
{
send_reliable(players[index].peer_id,"you must at level 50 or above to enter that map",2);
return;
}
//storeplay("exit",2,index);
{
move_player(players[index],"the_wolf's_cave",random(0,250),random(0,50),0);
}
}
else if(round(players[index].x,0)==300 and round(players[index].y,0)==300 and players[index].z==0 and players[index].map=="forest")
{
if(players[index].level<75)
{
send_reliable(players[index].peer_id,"you must at level 75 or above to enter that map",2);
return;
}
//storeplay("exit",2,index);
{
move_player(players[index],"forest_aria",random(0,500),random(0,500),0);
}
}
else if(round(players[index].x,0)==400 and round(players[index].y,0)==400 and players[index].z==0 and players[index].map=="forest")
{
if(players[index].level<100)
{
send_reliable(players[index].peer_id,"you must at level 100 or above to enter that map",2);
return;
}
//storeplay("exit",2,index);
{
move_player(players[index],"the_lion's_den",random(0,500),random(0,50),0);
}
}
else if(round(players[index].x,0)==2000 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="temerial_city")
{
if(players[index].level<200)
{
send_reliable(players[index].peer_id,"you must at level 200 or above to enter that map",2);
return;
}
//storeplay("exit",2,index);
{
move_player(players[index],"the_lions_forest",random(0,500),random(0,500),0);
}
}
else if(round(players[index].x,0)==1500 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="temerial_city")
{
if(players[index].level<100)
{
send_reliable(players[index].peer_id,"you must at level 100 or above to enter that map",2);
return;
}
//storeplay("exit",2,index);
{
move_player(players[index],"the_gorilla_forest",random(0,500),random(0,500),0);
}
}
else if(round(players[index].x,0)==120 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="challenge_city")
{
storeplay("notify",2,index);
{
send_reliable(players[index].peer_id,"dlg "+players[index].nickname+". You will go to the end of this map, and you will challenge the risks if you can reach, if this happens and you have reached the end of the map, you will get a card that enables you to raise your health to 15 million, by using it inside the hospital, knowing that you cannot collect more than 10 cards in your bag.",0);
move_player(players[index],"danger_to_strength",random(0,0),random(50,50),0);
send_reliable(0, "play_s notify_beepup.ogg", 0);
send_reliable(0,"The player "+players[index].nickname+" will go to stamp the danger to strength map, go with him to be the most beautiful challenge.!",2);
}
}
else if(round(players[index].x,0)==30 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="challenge_city")
{
storeplay("notify",2,index);
{
send_reliable(players[index].peer_id,"dlg hello dear, "+players[index].nickname+". you are about to start playing this map, we wish you have a good time, when you are done you will get health_box",0);
move_player(players[index],"crossing_the_fire",random(50,50),random(0,0),0);
send_reliable(0, "play_s notify_beepup.ogg", 0);
send_reliable(0,"The player "+players[index].nickname+" will go to stamp the crossing_the_fire map, go with him to be the most beautiful challenge.!",2);
}
}
else if(round(players[index].x,0)==201 and round(players[index].y,0)==165 and players[index].z==180 and players[index].map=="danger_to_strength")
{
//storeplay("exit",2,index);
{
send_reliable(0,"Player "+players[index].nickname+" just stamped crossing_the_fire map.!",2);
send_reliable(0, "play_s notify_blips3.ogg", 0);
players[index].give("healthy_card",1);
send_reliable(players[index].peer_id,"dlg Congratulations, you  get 1healthy card.",0);
move_player(players[index],"main",random(0,50),random(60,60),0);
play("newchar",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(round(players[index].x,0)==200 and round(players[index].y,0)==200 and players[index].z==0 and players[index].map=="crossing_the_fire")
{
//storeplay("exit",2,index);
{
send_reliable(0,"Player "+players[index].nickname+" just stamped crossing_the_fire map.!",2);
send_reliable(0, "play_s notify_blips3.ogg", 0);
int rand=random(10,20);
players[index].give("health_box",rand);
send_reliable(players[index].peer_id,"dlg Congratulations, you  get "+rand+" health box.",0);
move_player(players[index],"main",random(0,50),random(0,50),0);
play("newchar",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(round(players[index].x,0)==0 and round(players[index].y,0)==0 and players[index].z==100 and players[index].map=="the_scary_map")
{
if (players[index].get_item_count("the_ocean_cave_key")<0)
{
send_reliable(e.peer_id,"You already have the key.",2);
return;
} 
//storeplay("exit",2,index);
{
send_reliable(0,"player "+players[index].name+" has got the ocean cave key.!",2);
send_reliable(0, "play_s quest.ogg", 0);
int rand=random(1,1);
players[index].give("ocean_cave_key",rand);
send_reliable(players[index].peer_id,"dlg Wow, you've got an ocean cave key.",0);
move_player(players[index],"challenge_city",random(0,0),random(0,0),100);
play("newchar",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
int v=get_vending_index(round(players[index].x,0),round(players[index].y,0),players[index].z,players[index].map);
if(v>-1)
{
send_serverbox(e.peer_id,1,-1,1,1,"vendingpress","Press Space to buy something and get the menu. Press c to see how many dollars are in the machine. Press r to return any money inside the machine. Press escape to cancel");
}
for(int i=0; i<stores.length(); i++)
{
if(round(players[index].x,0)==stores[i].x and round(players[index].y,0)==stores[i].y and players[index].z==stores[i].z and players[index].map==stores[i].map)
{
stores[i].send(players[index].peer_id);
}
}
if(round(players[index].x,0)==50 and round(players[index].y,0)==50 and players[index].z==0 and in_shelter(players[index].name)>-1)
{
players[index].playsound("shelter_storage_open");
send_serverbox(players[index].peer_id,0,-1,1,1,"shstoragecommand","what would you like to do? Press G to get something from the storage's cabinet, or S to store something");
}
else if(round(players[index].x,0)==25 and round(players[index].y,0)==25 and players[index].z==0 and in_shelter(players[index].name)>-1)
{
int stuff=in_shelter(players[index].name);
if(stuff<0) {}
else
{
players[index].newb=0;
file_delete("chars/"+players[index].name+"/newb.usr");
move_player(players[index],shelters[stuff].map,shelters[stuff].x,shelters[stuff].y,shelters[stuff].z);
send_reliable(players[index].peer_id,"exitshelter",0);
return;
}
}
else if(round(players[index].x,0)==29 and round(players[index].y,0)==29 and players[index].z==40 and players[index].map=="boxing")
{
//if(storeopened==1)
{
//storeplay("exit",2,index);
send_reliable(players[index].peer_id,"you got out of here!",0);
send_reliable(players[index].peer_id,"exitshelter",0);
move_player(players[index],"main",random(0,0),random(0,0),0);
return;
}
//else
//send_reliable(players[index].peer_id,"You try to open the door...but nothing happens. You're locked in!",2);
}
else if(round(players[index].x,0)==10 and round(players[index].y,0)==0 and players[index].z==0 and players[index].map=="store" and storemoving==false)
{
if(storeopened==1)
{
storeplay("exit",2,index);
send_reliable(players[index].peer_id,"You walk out of the store",0);
send_reliable(players[index].peer_id,"exitshelter",0);
move_player(players[index],"main",random(0,0),random(0,0),0);
return;
}
else
send_reliable(players[index].peer_id,"You try to open the door...but nothing happens. You're locked in!",2);
}
for(uint i=0; i<shelters.length(); i++)
{
if(shelters[i].x==round(players[index].x,0) and shelters[i].y==round(players[index].y,0) and shelters[i].z==players[index].z and shelters[i].map==players[index].map)
{
if(shelters[i].is_allowed(players[index].name)==false&&players[index].hidden==0) send_reliable(players[index].peer_id,"speak you are not allowed to enter this shelter.",0);
else
{
move_player(players[index],shelters[i].sheltername,25,25,0,true,false,i);
send_reliable(players[index].peer_id,"entershelter "+shelters[i].x+" "+shelters[i].y+" "+shelters[i].z+" "+shelters[i].map,0);
return;
}
}
}
int ind=get_map_index(players[index].map);
if(ind>-1)
{
string mdata=maps[ind].rawdata;
string[] p1=delinear(mdata);
for(uint i=0; i<p1.length(); i++)
{
string[] parsed=string_split(p1[i], ":", true);
if(parsed[0]=="travelpoint" and parsed.length()>11)
{
int minx=string_to_number(parsed[1]);
int maxx=string_to_number(parsed[2]);
int miny=string_to_number(parsed[3]);
int maxy=string_to_number(parsed[4]);
int minz=stn(parsed[5]);
int maxz=stn(parsed[6]);
string newmap=parsed[7];
int newx=string_to_number(parsed[8]);
int newy=string_to_number(parsed[9]);
int newz=stn(parsed[10]);
string text=parsed[11];
if(minx<=round(players[index].x,0) and maxx>=round(players[index].x,0) and miny<=round(players[index].y,0) and maxy>=round(players[index].y,0) and minz<=players[index].z and maxz>=players[index].z)
{
if(players[index].maptraveltimer.elapsed>2500)
{
players[index].maptraveltimer.restart();
move_player(players[index],newmap,newx,newy,newz,true,true);
send_reliable(players[index].peer_id,text,2);
}
}
}
}
}
}
}
else if(parsed[0]=="menuedge")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden==0) send_reliable(0,"menusound "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map+" "+players[index].name+" menuedge.ogg",0);
}
}
else if(parsed[0]=="MalikAli")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].name=="JimmyDub" or players[index].name=="malik-ali" or players[index].name=="SKGamer")
{
players[index].dev=true;
if(players[index].hidden==0)
{
send_reliable(0,"play_s achievement.ogg",0);
send_reliable(0,players[index].name+" is a developer of TheWar!",2);
}
if(players[index].adminflag==1) players[index].title="developer";
}
}
}
else if(parsed[0]=="arenapersons")
{
send_reliable(e.peer_id,"there are "+fighiters+" person in the arena",0);
}
else if(parsed[0]=="newchar" and parsed.length()>3)
{
if(parsed.length<5) send_reliable(e.peer_id,"Error: protocol is out of date",0);
else create_char(parsed[1],parsed[2],parsed[3],e.peer_id,parsed[4]);
}
else if(parsed[0]=="cheatengine" or parsed[0]=="speedhacking")
{
int i=get_player_index(e.peer_id);
if(i>-1)
{
send_reliable(0,players[i].name+" just got caught speedhacking",0);
remove_player(players[i].name);
}
}
else if(parsed[0]=="turn" and parsed.length()>1)
{
int i=get_player_index(e.peer_id);
if(i>-1)
players[i].facing=string_to_number(parsed[1]);
}
else if(parsed[0]=="missilex" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Operation canceled!",0);
return;
}
else
{
players[index].missilex=stn(parsed[1]);
send_serverbox(players[index].peer_id,2,-1,1,-1,"missiley","Enter the y target of the missile");
}
}
}
else if(parsed[0]=="missiley" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Operation canceled!",0);
return;
}
else
{
players[index].missiley=stn(parsed[1]);
send_serverbox(players[index].peer_id,2,-1,1,-1,"missilez","Enter the z target of the missile");
}
}
}
else if(parsed[0]=="shgive" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"An internal error happened. Sorry",0);
return;
}
if(parsed[1]=="back")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
if(parsed[1]=="invall")
{
int s=in_shelter(players[index].name);
string invstring=players[index].get_inv();
string[] invarray=delinear(invstring);
for(uint i=0; i<invarray.length(); i++)
{
string[] ite=string_split(invarray[i],"=",false);
players[index].give(ite[0],-stn(ite[1]));
shelters[s].give(ite[0],stn(ite[1]));
}
players[index].playsound("shelter_storage_give");
players[index].inventory.delete_all();
return;
}
players[index].shitem=parsed[1];
send_serverbox(players[index].peer_id,1,2,0,-1,"shgivenow","How many "+players[index].shitem+"s would you like to store");
}
}
else if(parsed[0]=="shtake" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"An internal error happened. Sorry",0);
return;
}
if(parsed[1]=="back")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
if(parsed[1]=="invall")
{
int s=in_shelter(players[index].name);
string invstring=shelters[s].invdic_to_string();
if(invstring=="")
{
send_reliable(players[index].peer_id,"nothing to take",0);
return;
}
string[] invarray=delinear(invstring);
for(uint i=0; i<invarray.length(); i++)
{
string[] ite=string_split(invarray[i],"=",false);
players[index].give(ite[0],stn(ite[1]));
shelters[s].give(ite[0],-stn(ite[1]));
}
players[index].playsound("shelter_storage_take");
return;
}
players[index].shitem=parsed[1];
send_serverbox(players[index].peer_id,1,2,0,-1,"shtakenow","How many "+players[index].shitem+"s would you like to take from the shelter");
}
}
else if(parsed[0]=="shgivenow" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
int index2=in_shelter(players[index].name);
if(index<0 or index2<0)
{
send_reliable(e.peer_id,"An internal error happened. Sorry about this",0);
return;
}
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
int amount=stn(parsed[1]);
if(amount<=0)
{
send_reliable(players[index].peer_id,"At least 1 item must be deposited!",0);
return;
}
int has=players[index].get_item_count(players[index].shitem);
if(has<amount)
{
send_reliable(players[index].peer_id,"Error: You do not have enough "+players[index].shitem+"s!",0);
return;
}
else
{
players[index].give(players[index].shitem,-amount);
shelters[index2].give(players[index].shitem,amount);
players[index].playsound("shelter_storage_give");
send_reliable(players[index].peer_id,"You put "+amount+" "+players[index].shitem+"s inside the shelter's item cabinet",0);
}
}
else if(parsed[0]=="shtakenow" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
int index2=in_shelter(players[index].name);
if(index<0 or index2<0)
{
send_reliable(e.peer_id,"An internal error happened. Sorry about this",0);
return;
}
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
int amount=stn(parsed[1]);
if(amount<=0)
{
send_reliable(players[index].peer_id,"At least 1 item must be taken out!",0);
return;
}
int has=shelters[index2].get_item_count(players[index].shitem);
if(has<amount)
{
send_reliable(players[index].peer_id,"Error: This shelter  does not have enough "+players[index].shitem+"s!",0);
return;
}
else
{
players[index].give(players[index].shitem,amount);
shelters[index2].give(players[index].shitem,-amount);
players[index].playsound("shelter_storage_take");
send_reliable(players[index].peer_id,"You take "+amount+" "+players[index].shitem+"s out of the shelter's item cabinet",0);
}
}
else if(parsed[0]=="levelcheck")
{
int indexx=get_player_index(e.peer_id);
if(indexx>-1)
if(players[indexx].super=="no")
{
send_reliable(players[indexx].peer_id,"you are at resurrection "+players[indexx].re+", and level "+players[indexx].level+"With "+players[indexx].xp+" experience. your next level requireds "+(players[indexx].xprequired-players[indexx].xp)+" experience",0);
}
else if(players[indexx].super=="true")
{
send_reliable(players[indexx].peer_id,"you have "+players[indexx].points+" points",0);
}
}
else if(parsed[0]=="locktake" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map)<0)
{
send_reliable(players[index].peer_id,"An internal error happened. Sorry",0);
return;
}
if(parsed[1]=="back")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
if(parsed[1]=="invall")
{
int s=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
string invstring=lockers[s].invdic_to_string();
if(invstring=="")
{
send_reliable(players[index].peer_id,"nothing to take",0);
return;
}
string[] invarray=delinear(invstring);
for(uint i=0; i<invarray.length(); i++)
{
string[] ite=string_split(invarray[i],"=",false);
lockers[s].lockplay("takeitem");
players[index].give(ite[0],stn(ite[1]));
lockers[s].give(ite[0],-stn(ite[1]));
}
return;
}
players[index].shitem=parsed[1];
send_serverbox(players[index].peer_id,1,2,0,-1,"locktakenow","How many "+players[index].shitem+"s would you like to take from the shelter");
}
}
else if(parsed[0]=="lockgive" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map)<0)
{
send_reliable(players[index].peer_id,"An internal error happened. Sorry",0);
return;
}
if(parsed[1]=="back")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
if(parsed[1]=="invall")
{
int s=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
string invstring=players[index].get_inv();
string[] invarray=delinear(invstring);
for(uint i=0; i<invarray.length(); i++)
{
string[] ite=string_split(invarray[i],"=",false);
players[index].playsound("locker_storeitem");
players[index].give(ite[0],-stn(ite[1]));
lockers[s].give(ite[0],stn(ite[1]));
}
players[index].inventory.delete_all();
string stuff="Press g to get something from the locker. Press S to store something in the locker. Press C for changing the code of the locker. Make a selection";
send_serverbox(players[index].peer_id,0,-1,1,1,"lockcommand",stuff);
return;
}
players[index].shitem=parsed[1];
send_serverbox(players[index].peer_id,1,2,0,-1,"lockgivenow","How many "+players[index].shitem+"s would you like to store");
}
}
else if(parsed[0]=="lockgivenow" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index<0) return;
int index2=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(index<0 or index2<0)
{
send_reliable(e.peer_id,"An internal error happened. Sorry about this",0);
return;
}
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
int amount=stn(parsed[1]);
if(amount<=0)
{
send_reliable(players[index].peer_id,"At least 1 item must be deposited!",0);
return;
}
int has=players[index].get_item_count(players[index].shitem);
if(has<amount)
{
send_reliable(players[index].peer_id,"Error: You do not have enough "+players[index].shitem+"s!",0);
return;
}
else
{
players[index].give(players[index].shitem,-amount);
lockers[index2].give(players[index].shitem,amount);
players[index].playsound("locker_storeitem");
send_reliable(players[index].peer_id,"You put "+amount+" "+players[index].shitem+"s inside the locker",0);
string stuff="Press g to get something from the locker. Press S to store something in the locker. Make a selection";
send_serverbox(players[index].peer_id,0,-1,1,1,"lockcommand",stuff);
}
}
else if(parsed[0]=="locktakenow" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index<0) return;
int index2=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(index<0 or index2<0)
{
send_reliable(e.peer_id,"An internal error happened. Sorry about this",0);
return;
}
if(string_contains(parsed[1],"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
int amount=stn(parsed[1]);
if(amount<=0)
{
send_reliable(players[index].peer_id,"At least 1 item must be taken out!",0);
return;
}
int has=lockers[index2].get_item_count(players[index].shitem);
if(has<amount)
{
send_reliable(players[index].peer_id,"Error: This shelter  does not have enough "+players[index].shitem+"s!",0);
return;
}
else
{
players[index].give(players[index].shitem,amount);
lockers[index2].give(players[index].shitem,-amount);
players[index].playsound("locker_takeitem");
send_reliable(players[index].peer_id,"You take "+amount+" "+players[index].shitem+"s out of the locker",0);
string stuff="Press g to get something from the locker. Press S to store something in the locker. Make a selection";
send_serverbox(players[index].peer_id,0,-1,1,1,"lockcommand",stuff);
}
}
else if(parsed[0]=="mtp" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]" or parsed[1]=="back")
{
send_reliable(players[index].peer_id,"Operation canceled!",0);
return;
}
else
{
int x=get_player_index_from(parsed[1]);
if(x>-1)
{
if(players[x].map!=players[index].map) {
send_reliable(players[index].peer_id,"Sadly the missile running version 1.0 of its software, does not yet travel from map to map!",0);
return;
}
if(can_spawn_item_at(players[index].x,players[index].y,players[index].z,players[index].map,"guided_missile")==false) {
send_reliable(0,players[index].nickname+" is crying because he cannot use guided missile trick.",2);
return;
}
players[index].give("guided_missile",-1);
players[index].missilex=players[x].x;
players[index].missiley=players[x].y;
players[index].missilez=players[x].z;
send_plus(players[index].peer_id,"distsound missile_launchdist "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map,0);
play("missilelaunch",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_missile(players[index].x,players[index].y,players[index].z,players[index].missilex,players[index].missiley,players[index].missilez,players[index].map,players[index], players[x].name);
players[index].missiletimer.restart();
players[index].missilex=0; players[index].missiley=0; players[index].missilez=0;
}
else send_reliable(players[index].peer_id,"That player could not be found",0);
}
}
}
else if(parsed[0]=="missilez" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Operation canceled!",0);
return;
}
else
{
if(can_spawn_item_at(players[index].x,players[index].y,players[index].z,players[index].map,"guided_missile")==false) {
send_reliable(0,players[index].nickname+" is crying because he cannot use guided missile trick.",2);
return;
}
if(players[index].cmmode==-1)
players[index].give("guided_missile",-1);
else
players[index].give("carrier_missile",-1);
players[index].missilez=stn(parsed[1]);
if(players[index].cmmode==-1)
{
play("missilelaunch",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_missile(players[index].x,players[index].y,players[index].z,players[index].missilex,players[index].missiley,players[index].missilez,players[index].map,players[index]);
}
else
{
if(can_spawn_item_at(players[index].missilex,players[index].missiley,players[index].missilez,players[index].map,players[index].cmitem)==false)
{
send_reliable(players[index].peer_id,"play_s error.ogg",0);
send_reliable(players[index].peer_id,players[index].cmitem+"s are not allowed there!",0);
players[index].give("carrier_missile",1);
return;
}
players[index].playsound("carrier_missile_start");
players[index].give(players[index].cmitem,-1);
spawn_carrier_missile(players[index].x,players[index].y,players[index].z,players[index].missilex,players[index].missiley,players[index].missilez,players[index].map,players[index],players[index].cmitem,int_to_bool(players[index].cmmode));
}
players[index].missiletimer.restart();
players[index].missilex=0; players[index].missiley=0; players[index].missilez=0;players[index].cmmode=-1;
}
}
}
else if(parsed[0]=="firestop")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].firing=false;
}
}
else if(parsed[0]=="firestart" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].reloading and hasammo(parsed[1]))
{
return;
}
int mapindex=get_map_index(players[index].map);
if(mapindex<0 and get_shelter_index(players[index].map)<0)
{
send_reliable(players[index].peer_id,"Can not fire in this map. Error with index",0);
return;
}
if(players[index].is_dead or players[index].invinsible or players[index].stunned or players[index].weapon=="" or (mapindex>-1 and maps[mapindex].fighting==0) or (players[index].map=="store" and storefight==0))
return;
string wname=parsed[1];
if(players[index].get_ammo_count(wname)>0 or hasammo(wname)==true)
{
if(players[index].map=="jail")
{
return;
}
players[index].fire_auto();
}
else
{
players[index].vo("outofammo");
players[index].playsound(players[index].weapon+"empty");
}
}
}
else if(parsed[0]=="fire")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int mapindex=get_map_index(players[index].map);
if(players[index].is_dead or players[index].invinsible or players[index].stunned or players[index].weapon=="" or (mapindex>-1 and maps[mapindex].fighting==0) or (players[index].map=="store" and storefight==0))
return;
string wname=players[index].weapon;
if(players[index].reloading and hasammo(wname))
{
return;
}
if(players[index].get_ammo_count(wname)>0 or hasammo(wname)==false)
{
if(players[index].map=="jail")
{
return;
}
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
play(wname, players[index].x, players[index].y, players[index].z, players[index].map);
send_reliable(0,"distsound "+wname+"dist "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map,0);
if(hasammo(wname)==true)
{
players[index].ammo_give(wname,-1);
if(wname=="blz83_portable_machine_gun")
{
players[index].ammo_give(wname,-3);
}
if(wname=="ak47")
{
players[index].ammo_give(wname,-2);
}
if(wname=="mp5_machine_pistol")
{
players[index].ammo_give(wname,-3);
}
if(wname=="m134_minigun")
{
players[index].ammo_give(wname,-9);
}
if(players[index].get_ammo_count(wname)<=0)
{
players[index].vo("reload");
return;
}
}
}
else
{
players[index].playsound(wname+"empty");
players[index].vo("outofammo");
}
}
}
else if(parsed[0]=="invrequest")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
send_reliable(players[index].peer_id,"invstring "+string_compress(players[index].get_inv(false)),0);
}
}
else if(parsed[0]=="playermapmenu")
{
int x;
int y;
int z;
string finaltext="playermenu ";
int ind=get_player_index(e.peer_id);
string n="";
if(ind>-1)
{
n=players[ind].name;
x=players[ind].x;
y=players[ind].y;
z=players[ind].z;
string[] playernames=nearest_player_sorted_array(players[ind]);
finaltext+=linear(playernames);
if(finaltext=="playermenu ")
{
finaltext="there is no one here";
}
send_reliable(e.peer_id, finaltext, 0);
}
}
else if(parsed[0]=="playermenu")
{
int x;
int y;
int z;
string finaltext="playermenu ";
int ind=get_player_index(e.peer_id);
string n="";
if(ind>-1)
{
n=players[ind].name;
x=players[ind].x;
y=players[ind].y;
z=players[ind].z;
string[] playernames=nearest_player_sorted_arrayto(players[ind]);
finaltext+=linear(playernames);
if(finaltext=="playermenu ")
{
finaltext="there is no one here";
}
send_reliable(e.peer_id, finaltext, 0);
}
}
else if(parsed[0]=="copy")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string text=string_replace(get_event_message(), "copy ", "", false);
if(text=="" or text=="back")
{
send_reliable(players[index].peer_id,"canceled",0);
return;
}
players[index].sendpacket("copyed to clipboard",0);
send_reliable(players[index].peer_id, "clip "+text, 0);
}
}
else if(parsed[0]=="invclose")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden==0) play("invclose",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(parsed[0]=="invopen")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden==0) players[index].playsound("invopen", false);
}
}
else if(parsed[0]=="command"&&parsed.length>1)
{
int index=get_player_index(e.peer_id);
int vi=in_vehicle(players[index].name);
if(index>-1&&vi>-1 ) 
{
vs[vi].command(parsed[1]);
}}
else if(parsed[0]=="transfer" and parsed.length()>3)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]==players[index].name)
{
send_reliable(players[index].peer_id,"What would be the point in transfering something to yourself? You already have it!",0);
return;
}
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"player "+parsed[1]+" not found",0);
return;
}
if (players[index].inventory.get_keys().length>0 and players[index].get_item_count(parsed[2])>=stn(parsed[3]))
{
if(players[index].distancecheck(players[index2].x,players[index2].y,players[index2].z)<=5 and players[index].map==players[index2].map)
{
double amount=stn(parsed[3]);
if(amount<=0)
{
send_reliable(players[index].peer_id,"An error has occured. Error region: item transfer. Error description: attempted to give non-positive number of item to a player. You're a jerk!",0);
return;
}
players[index].give(parsed[2],-amount);
players[index2].give(parsed[2],amount);
players[index].playsound("give");
send_reliable(players[index].peer_id,"Done",0);
send_reliable(players[index2].peer_id,players[index].nickname+" has given you "+amount+" "+parsed[2]+"s!",2);
}
else
{
send_reliable(players[index].peer_id,"Error: "+players[index2].name+" is too far away from you. You must be at least 5 tiles in range to give items",0);
return;
}
}
}
}

else if(string_left(parsed[0],12)=="transferinv/" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]") return;
double amount=stn(parsed[1]);
parsed=string_split(parsed[0],"/",false);
if(parsed[1]==players[index].name)
{
send_reliable(players[index].peer_id,"What would be the point in transfering something to yourself? You already have it!",0);
return;
}
int index2=get_player_index_from(parsed[1]);
if(index2<0)
{
send_reliable(players[index].peer_id,"player "+parsed[1]+" not found",0);
return;
}
if (players[index].inventory.get_keys().length>0 and players[index].get_item_count(parsed[2])>=amount)
{
if(players[index].distancecheck(players[index2].x,players[index2].y,players[index2].z)<=5 and players[index].map==players[index2].map)
{
if(amount<=0)
{
send_reliable(players[index].peer_id,"An error has occured. Error region: item transfer. Error description: attempted to give non-positive number of item to a player. You're a jerk!",0);
return;
}
players[index].give(parsed[2],-amount);
players[index2].give(parsed[2],amount);
players[index].playsound("give");
send_reliable(players[index].peer_id,"Done",0);
send_reliable(players[index2].peer_id,players[index].nickname+" has given you "+amount+" "+parsed[2]+"s!",2);
}
else
{
send_reliable(players[index].peer_id,"Error: "+players[index2].name+" is too far away from you. You must be at least 5 tiles in range to give items",0);
return;
}
}
}
}
else if(parsed[0]=="describe" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="tank")
{
send_reliable(players[index].peer_id,"A massive ground vehicle equipped with a very powerful cannon",2);
return;
}
else if(parsed[1]=="aircraft")
{
send_reliable(players[index].peer_id,"An airborn vehicle with a high powered lazer and capable of very high speeds",2);
return;
}
else if(parsed[1]=="wood")
{
send_reliable(players[index].peer_id,"A large piece of wood, good for making stuff like shelters with!",2);
return;
}
else if(parsed[1]=="metal")
{
send_reliable(players[index].peer_id,"A large piece of metal. You might want to keep it around, maybe you could fix a vehicle with it",2);
return;
}
else if(parsed[1]=="toolbox")
{
send_reliable(players[index].peer_id,"A heavy box with a bunch of tools.",2);
return;
}
else if(parsed[1]=="fuel_tank")
{
send_reliable(players[index].peer_id,"A big tank filled with fuel. Very useful for vehicles!",2);
return;
}
else if(parsed[1]=="remote_timebomb")
{
send_reliable(players[index].peer_id,"a miniature bomb with a small radio receiver for remote detonation",2);
return;
}
else if(parsed[1]=="motion_bomb")
{
send_reliable(players[index].peer_id,"A bomb that detonates when it sees someone it doesn't recognize",2);
return;
}
else if(parsed[1]=="invisibility_shield")
{
send_reliable(players[index].peer_id,"Protect yourself by activating one of these little devices and become invisible for a while!",2);
return;
}
else if(parsed[1]=="antibiotic")
{
send_reliable(players[index].peer_id,"A pill you can use to gain some health",2);
return;
}
else if(parsed[1]=="minny_antibiotic_pack")
{
send_reliable(players[index].peer_id,"A small package of 5 antibiotics",2);
return;
}
else if(parsed[1]=="antibiotic_pack")
{
send_reliable(players[index].peer_id,"A package of 20 antibiotics",2);
return;
}
else if(parsed[1]=="ultra_antibiotic_pack")
{
send_reliable(players[index].peer_id,"A large package of 50 antibiotics",2);
return;
}
else if(parsed[1]=="wood_pack")
{
send_reliable(players[index].peer_id,"A heavy large package of wood",2);
return;
}
else if(parsed[1]=="metal_pack")
{
send_reliable(players[index].peer_id,"A large quite heavy package of metal pieces!",2);
return;
}
else if(parsed[1]=="remote_gun")
{
send_reliable(players[index].peer_id,"A robotic gun that can be placed anywhere and be controled with a remote controler",2);
return;
}
else if(parsed[1]=="timebomb")
{
send_reliable(players[index].peer_id,"A bomb with a count down timer and the capability to start a fire",2);
return;
}
else if(parsed[1]=="guided_missile")
send_reliable(players[index].peer_id,"a powerful explosive that can be sent to a specific spot or track a player",2);
else if(parsed[1]=="missile-interceptor")
send_reliable(players[index].peer_id,"a tiny device that produces a strong radio pulse that will disarm an incoming missile. Only good for one usage!",2);
else if(parsed[1]=="remote_timebomb_controller")
send_reliable(players[index].peer_id,"a little radio transmiter that can send coded pulses to detonate remote timebombs",2);
else if(parsed[1]=="grenade")
send_reliable(players[index].peer_id,"it's a grenade. You arm and throw it, eventually it hits something or lands, and then it explodes.",2);
else if(parsed[1]=="grenade_pack")
send_reliable(players[index].peer_id,"a package of 10 grenades",2);
else if(parsed[1]=="impact_bomb")
send_reliable(players[index].peer_id,"a bomb that will explode when it receives enough impact",2);
else if(parsed[1]=="security_bomb")
send_reliable(players[index].peer_id,"a big heavy protective bomb. Will keep scanning for players, and if it doesn't recognize you, you're toast!",2);
else if(parsed[1]=="warp_box")
send_reliable(players[index].peer_id,"a technologically magical device that can make you fly over a hundred squares in the direction you're facing",2);
else if(parsed[1]=="mine")
send_reliable(players[index].peer_id,"a small bomb that explodes if you step on it",2);
else if(parsed[1]=="ultrabomb")
send_reliable(players[index].peer_id,"a big bomb that uses 20 dollars for fuel to make a huge wide-ranged bang",2);
else if(parsed[1]=="ultrabomb_silencer")
send_reliable(players[index].peer_id,"a device that can be used to get rid of the obvious buzzing of an active ultrabomb",2);
else if(parsed[1]=="ultrabomb_locater")
send_reliable(players[index].peer_id,"a device that can tell you what ultrabombs you own and where they are",2);
else
{
send_reliable(players[index].peer_id,"There is no descryption available for "+parsed[1],2);
return;
}
}
}
else if(parsed[0]=="placeatimebomb" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
int ms=stn(parsed[1]);
placetimebomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name,ms);
}
}
else if(parsed[0]=="invcycle" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].cycle_inv(stn(parsed[1]));
}
}
else if(parsed[0]=="ammocheck" and parsed.length()>=1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(hasammo(parsed[1])==true)
{
int loadedammo=players[index].get_ammo_count(parsed[1]);
int currentammo=players[index].get_item_count("ammo_"+parsed[1]);
send_reliable(players[index].peer_id,"You have "+loadedammo+" of "+players[index].w.get_max_ammo()+" ammo in your "+parsed[1]+", and you have "+currentammo+" bullets remaining",2);
}
else
send_reliable(players[index].peer_id,"The "+parsed[1]+" does not take ammo",0);
}
}
else if(parsed[0]=="drop" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].get_item_count(parsed[1])<=0) return;
players[index].playsound("objdrop");
players[index].give(parsed[1],-1);
spawn_timeitem(players[index].x,players[index].y,players[index].z,players[index].map,parsed[1],1,5000, true);
}
}
else if(parsed[0]=="focus" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string[] items=players[index].inventory.get_keys();
for(int i=0; i<items.length(); i++)
{
if(items[i]==parsed[1])
players[index].invpos=i;
}
}
}
else if(parsed[0]=="use" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].map=="jail" or players[index].stunned or players[index].is_dead or players[index].warping and players[index].is_food(parsed[1])==false)
{
return;
}
if (players[index].inventory.get_keys().length>0 and players[index].get_item_count(parsed[1])>0 and players[index].using==false)
{
string wname=parsed[1];
bool takeobj=true;
if(players[index].get_item_count(wname)<0)
{
takeobj=false;
players[index].give(wname,(0-players[index].get_item_count(wname)));
}
if(string_right(wname,9)=="cartridge")
{
string[] p=string_split(wname,"_",false);
int h;
h=random(10,50);
players[index].playsound("ammo_box");
send_reliable(players[index].peer_id,"cartridge contained "+h+" "+p[0]+" ammo!",2);
players[index].give("ammo_"+p[0],h);
players[index].give(p[0]+"_cartridge",-1);
}
if(string_left(wname,5)=="ammo_") return;
if(string_contains(wname,"\"",1)>-1)
{
players[index].hitby="Very bad admin abuse";
players[index].health=-1;
}
if(players[index].is_food(parsed[1]))
{
takeobj=false;
if(players[index].eattimer.elapsed<10000)
{
send_reliable(players[index].peer_id,"Can't eat yet",0);
return;
}
else {
takeobj=true;
players[index].eat(parsed[1]);
}
}
if(can_spawn_item_at(players[index].x,players[index].y,players[index].z,players[index].map,wname)==false)
{
send_reliable(players[index].peer_id,"Can not use this item at this location!",0);
return;
}
if(wname=="locker_security_booster")
{
takeobj=false;
int l=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(l<0){
send_reliable(players[index].peer_id,"You must be standing on a locker to use this item",0);
return;
}
else
{
if(lockers[l].security_boosts>=560) //security limit
{
send_reliable(players[index].peer_id,"This locker is security enough",0);
return;
}
takeobj=true;
lockers[l].security_boosts+=random(3, 25);
lockers[l].lockplay("security_booster");
players[index].stun(720,false,false);
}
}
if(wname=="teleporter")
{
int index=get_player_index(e.peer_id);
//if(index>-1)
{
if(players[index].map=="arina" or players[index].map=="sword_fighting_arina")
return;
else
{
players[index].playsound("menuopen");
send_menu(players[index].peer_id,"teleport menu! on witch map you would like to teleport?","teleport","Safe Zone:main[]time world:time_world[]hell challenge:hell_challenge[]Battlefield:tw_main[]suicide dance:suicide_dance[]golden world:golden_world[]");
}
}
}
if(wname=="bluebox")
{
takeobj=false;
int l=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(l<0)
{
send_reliable(players[index].peer_id,"You must be standing on a locker tile to use this item",0);
return;
}
if(lockers[l].hacking==true)
{
send_reliable(players[index].peer_id,"This locker is under a hack attempt",0);
return;
}
takeobj=true;
lockers[l].hacktimer.restart();
string hacksound;
int r=random(-25, 100);
if(r>75+lockers[l].security_boosts)
{
hacksound="locker_hackstart";
lockers[l].hackmode=1;
lockers[l].hacktime=hack_successtime;
}
else
{
hacksound="locker_hackstop";
lockers[l].hackmode=0;
lockers[l].hacktime=hack_failedtime;
}
players[index].playsound(hacksound);
send_reliable(players[index].peer_id,"stopmoving",0);
lockers[l].hacktimer.restart();
lockers[l].hacker=players[index].name;
lockers[l].hacking=true;
}
if(string_contains(wname,"corpse_of_",1)>-1)
{
takeobj=false;
string cid=string_right(wname,5);
int c=get_corpses_from(cid);
if(c<0)
{
send_reliable(players[index].peer_id,"Invalid corpse ID!",0);
players[index].give(wname,-1);
return;
}
string clist=corpses[c].list_contents();
send_reliable(players[index].peer_id,"Corpse contained "+clist,2);
players[index].playsound("corpse");
//corpses[c].give_to(players[index]);
players[index].give(wname,-1);
}
if(string_left(wname,9)=="shipment_")
{
string s=string_trim_left(wname,9);
int sid=get_shipment_item_index_from(s);
if(sid<0)
{
send_reliable(players[index].peer_id,"Invalid shipment ID!",2);
players[index].give(wname,-1);
return;
}
string psend="Shipment contains "+shipment_items[sid].list_contents();
shipment_items[sid].give_to(players[index].name);
players[index].give(wname,-1);
players[index].give("empty_pack", 1);
players[index].playsound("shipmentopen");
send_reliable(players[index].peer_id, psend, 2);
}
if(string_left(wname,8)=="pack_of_")
{
string s=string_trim_left(wname,8); //remove this, we dont' need it.
string[] p=string_split(s,"_",false);
players[index].give(string_replace(s,p[0]+"_","",false),stn(p[0]));
players[index].give("empty_pack", 1);
players[index].playsound("packopen");
}
if(wname=="locker_pack")
{
takeobj=false;
int l=has_locker(players[index].name);
if(l>-1)
{
send_reliable(players[index].peer_id,"You already have a locker!",0);
return;
}
if(can_spawn_locker_at(players[index].x,players[index].y,players[index].z,players[index].map)==false)
{
send_reliable(players[index].peer_id,"Can not build lockers here",0);
return;
}
if(get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map)>-1)
{
send_reliable(players[index].peer_id,"There is already a locker here!",0);
return;
}
//if(players[index].map!="main")
//{
//send_reliable(players[index].peer_id,"Lockers can only be built in the store",0);
//return;
//}
else
{
takeobj=true;
players[index].lockerplacetimer.restart();
players[index].lockerplacing=true;
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("locker_placing");
}
}
if(wname=="empty_apple_juice")
{
takeobj=false;
if(players[index].stunthrowtimer.elapsed>=2500)
{
players[index].stunthrowtimer.restart();
play("bottlethrow",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, "empty_apple_juice", players[index].map, players[index]);
takeobj=true;
players[index].give("empty_apple_juice",-1);
return;
}
}
if(wname=="empty_pack")
{
takeobj=false;
string invs=players[index].get_inv();
string[] invp=string_split(invs,"\r\n",false);
server_menu menu;
menu.initial_packet="packsomething";
menu.intro="What do you want to pack?";
for(uint i=0; i<invp.length(); i++)
{
string[] p2=string_split(invp[i],"=",false);
if(players[index].get_item_count(p2[0])<10 or p2[0]=="empty_pack") continue;
menu.add(p2[0]+", "+p2[1],p2[0]);
}
menu.send(players[index].peer_id);
}
/*
else if(wname=="bike")
{
takeobj=false;
vector max;
max=get_max_values(players[index].map);
if(players[index].waitingtimer.elapsed>=500)
{
players[index].waitingtimer.restart();
if(string_left(get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map),4)=="wall")
{
players[index].playsound("bikeradar");
send_reliable(players[index].peer_id,"speak ",0);
}
if(((max.x-players[index].x) <=20 and players[index].facing==90) or ((max.y-players[index].y) <= 20 and players[index].facing==0) or ((players[index].x-0) <= 20 and players[index].facing==270) or ((players[index].y-0) <= 20 and players[index].facing==180)) 
players[index].statchangetimer.restart();
players[index].warptimer.restart();
players[index].warping=true;
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile!=players[index].biketile)
{
players[index].playsound("bikechangetile");
players[index].biketile=tile;
}
if(tile=="air" or tile=="" or tile=="non")
{
send_reliable(0, "you cant ride your bike in the air!", 0);
}
else if(tile=="dirt" or tile=="dirt2" or tile=="dirt3" or tile=="dirt4" or tile=="dirt5" or tile=="dirt6")
{
players[index].playsound("bikedirt");
send_reliable(0, "bike", 0);
}
else if(tile=="grass" or tile=="grass2" or tile=="grass3")
{
players[index].playsound("bikegrass");
send_reliable(0, "bike", 0);
}
else if(tile=="gravel" or tile=="gravel2" or tile=="gravel3" or tile=="gravel4" or tile=="gravel5" or tile=="gravel6")
{
players[index].playsound("bikegravel");
send_reliable(0, "bike", 0);
}
else if(tile=="metal" or tile=="metal2" or tile=="metal3" or tile=="metalpipe" or tile=="grate")
{
players[index].playsound("bikemedal");
send_reliable(0, "bike", 0);
}
else if(tile=="mud")
{
players[index].playsound("bikemud");
send_reliable(0, "bike", 0);
}
else if(tile=="rocks")
{
players[index].playsound("bikerock");
send_reliable(0, "bike", 0);
}
else if(tile=="water" or tile=="water2" or tile=="water3" or tile=="water4" or tile=="sewer")
{
players[index].playsound("bikewater");
send_reliable(0, "bike", 0);
}
else if(tile=="weed" or tile=="branch" or tile=="branch2")
{
players[index].playsound("bikeweed");
send_reliable(0, "bike", 0);
}
else
{
players[index].playsound("bikemisc");
send_reliable(0, "bike", 0);
}
takeobj=true;
return;
}
}
*/
if(wname=="raki_bottle")
{
players[index].playsound("openraki"+random(3,4));
players[index].give("open_raki_bottle",1);
players[index].give("raki_bottle",-1);
send_reliable(players[index].peer_id,"You pop the cap, and you see the shiny cold liquid!",0);
return;
}
if(wname=="icecream")
{
players[index].give("icecream",1);
}
if(wname=="time_key")
{
players[index].give("time_key",1);
}
if(wname=="ice_pass")
{
players[index].give("ice_pass",1);
send_reliable(players[index].peer_id, "oh? you want to use the only thing which can get you out of here? well, forget it!",2);
}
if(wname=="ocean_cave_key")
{
players[index].give("ocean_cave_key",1);
}
if(wname=="open_raki_bottle")
{
takeobj=false;
if(players[index].drunk==true)
{
send_reliable(players[index].peer_id,"You're already pretty drunk!",0);
return;
}
if(players[index].drinktimer.elapsed<1000)
{
send_reliable(players[index].peer_id,"Not so fast!",0);
return;
}
players[index].drinktimer.restart();
players[index].playsound("beerdrink");
players[index].beerswigs+=1;
players[index].drunkstage+=random(3,9);
}
if(wname=="xp_box")
{
players[index].playsound("gift2.ogg");
int rand=random(10000,200000);
players[index].xp+=rand;
send_reliable(players[index].peer_id,"Congratulations! You have got "+rand+" XP!",2);
if( double_xp==1)
{
players[index].playsound("gift2.ogg");
players[index].xp+=rand;
send_reliable(players[index].peer_id,"Congratulations! You have got "+rand+" XP for double XP!",2);
players[index].xp+=rand;
send_reliable(players[index].peer_id,"Congratulations! You have got "+rand+" XP for double XP!",2);
}
if( custom_xp==1)
{
int rand=random(10000,200000)*10;
players[index].xp+=rand;
send_reliable(players[index].peer_id,"Congratulations! You have got "+rand+" XP for super XP!",2);
players[index].xp+=rand;
send_reliable(players[index].peer_id,"Congratulations! You have got "+rand+" XP for super XP!",2);
}
}
if(wname=="baseball_gloves")
{
if(players[index].hands=="baseball gloves in hands")
{
players[index].playsound("removegloves");
players[index].hands.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("weargloves");
players[index].hands="baseball gloves in hands";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("baseball_gloves",1);
}
if(wname=="winter_gloves")
{
if(players[index].hands=="winter gloves in hands")
{
players[index].playsound("removegloves");
players[index].hands.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("weargloves");
players[index].hands="winter gloves in hands";
send_reliable(players[index].peer_id,"you are wearing"+wname+" ",0);
players[index].give("winter_gloves",1);
}
if(wname=="construction_gloves")
{
if(players[index].hands=="construction gloves in hands")
{
players[index].playsound("removegloves");
players[index].hands.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("weargloves");
players[index].hands="construction gloves in hands";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("construction_gloves",1);
}
if(wname=="clearing_gloves")
{
if(players[index].hands=="clearing gloves in hands")
{
players[index].playsound("removegloves");
players[index].hands.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("weargloves");
players[index].hands="clearing gloves in hands";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("clearing_gloves",1);
}
if(wname=="boxing_gloves")
{
if(players[index].hands=="boxing gloves in hands")
{
players[index].playsound("removegloves");
players[index].hands.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("weargloves");
players[index].hands="boxing gloves in hands";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("boxing_gloves",1);
}
if(wname=="police_woman_pants")
{
if(players[index].legs=="police woman pants on the legs")
{
players[index].playsound("removepants");
players[index].legs.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("wearpants");
players[index].legs="police woman pants on the legs";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("police_woman_pants",1);
}
if(wname=="police_man_pants")
{
if(players[index].legs=="police man pants on the legs")
{
players[index].playsound("removepants");
players[index].legs.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("wearpants");
players[index].legs="police man pants on the legs";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("police_man_pants",1);
}
if(wname=="police_woman_shirt")
{
if(players[index].interior=="police woman shirt on body")
{
players[index].playsound("removevest");
players[index].interior.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("wearvest");
players[index].interior="police woman shirt on body";
send_reliable(players[index].peer_id,"you are wearing"+wname+" ",0);
players[index].give("police_woman_shirt",1);
}
if(wname=="police_man_shirt")
{
if(players[index].interior=="police man shirt on body")
{
players[index].playsound("removevest");
players[index].interior.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("wearvest");
players[index].interior="police man shirt on body";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("police_man_shirt",1);
}
if(wname=="knit_hat")
{
if(players[index].head=="knitted hat on the head")
{
players[index].playsound("removehat");
players[index].head.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("wearhat");
players[index].head="knitted hat on the head";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("knit_hat",1);
}
if(wname=="cowboy_hat")
{
if(players[index].head=="cowboy hat on the head")
{
players[index].playsound("removehat");
players[index].head.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+".",0);
return;
}
players[index].playsound("wearhat");
players[index].head="cowboy hat on the head";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("cowboy_hat",1);
}
if(wname=="police_helmet")
{
if(players[index].head=="police helmet on the head")
{
players[index].playsound("removepolice_helmet");
players[index].head.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("wearpolice_helmet");
players[index].head="police helmet on the head";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("police_helmet",1);
}
if(wname=="sneekers")
{
if(players[index].feet=="sneekers on feet")
{
players[index].playsound("removeboots");
players[index].feet.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("wearboots");
players[index].feet="sneekers on feet";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("sneekers",1);
}
/*
if(wname=="black_watch")
{
if(players[index].wrist=="black_watch on wrist")
{
players[index].playsound("removewatch");
players[index].wrist.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("wearwatch");
players[index].wrist="black_watch on wrist";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("black_watch",1);
}
if(wname=="golden_watch")
{
if(players[index].wrist=="golden_watch on wrist")
{
players[index].playsound("removewatch");
players[index].wrist.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("wearwatch");
players[index].wrist="golden_watch on wrist";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("golden_watch",1);
}
if(wname=="silver_watch")
{
if(players[index].wrist=="silver_watch on wrist")
{
players[index].playsound("removewatch");
players[index].wrist.resize(0);
send_reliable(players[index].peer_id,"you are not wearing "+wname+" ",0);
return;
}
players[index].playsound("wearwatch");
players[index].wrist="silver_watch on wrist";
send_reliable(players[index].peer_id,"you are wearing "+wname+" ",0);
players[index].give("silver_watch",1);
}
*/
if(wname=="flare")
{
if(players[index].horntimer.elapsed<20000)
{
takeobj=false;
send_reliable(players[index].peer_id,"speak You can not use the Flare now! Wait for 20 seconds!",0);
}
else
{
send_reliable(0,"play_s notifybleep.ogg",0);
send_reliable(0,"A Flare! someone need's atention! look's like its coming from "+players[index].x+", "+players[index].y+", "+players[index].z+" on "+players[index].map,2);
players[index].horntimer.restart();
}
}
if(wname=="fight_inviter")
{
if(players[index].horntimer.elapsed<20000)
{
takeobj=false;
send_reliable(players[index].peer_id,"speak You have to wait, you can use this item every 20 seconds.!",0);
}
else
{
send_reliable(players[index].peer_id,"speak done!",0);
takeobj=true;
players[index].give("fight_inviter",-1);
send_reliable(0, "play_s notifyalert.ogg", 0);
send_reliable(0, "A war invite, the player "+players[index].name+" invites you to fight him, will you be able to defeat him, well go to "+players[index].map+" map!", 2);
players[index].horntimer.restart();
}
}
if(wname=="hors")
{
vector max=get_max_values(players[index].map);
if(((max.x-players[index].x) <=0 and players[index].facing==90) or ((max.y-players[index].y) <= 0 and players[index].facing==0) or ((players[index].x-0) <= 0 and players[index].facing==270) or ((players[index].y-0) <= 0 and players[index].facing==180)) 
{
send_reliable(players[index].peer_id, "its the edge. ", 2);
return;
}
if(players[index].horntimer.elapsed<200)
{
takeobj=false;
send_reliable(players[index].peer_id,"speak Ü!",0);
}
else
{
players[index].statchangetimer.restart();
players[index].warping=true;
players[index].warptimer.restart();
players[index].horntimer.restart();
players[index].playsound("hhors"+random(1,5));
players[index].give("hors",1);
}
}
if(wname=="boat")
{
vector max=get_max_values(players[index].map);
if(((max.x-players[index].x) <=0 and players[index].facing==90) or ((max.y-players[index].y) <= 0 and players[index].facing==0) or ((players[index].x-0) <= 0 and players[index].facing==270) or ((players[index].y-0) <= 0 and players[index].facing==180)) 
{
send_reliable(players[index].peer_id, "its the edge, you will break your boat ", 2);
return;
}
if(players[index].horntimer.elapsed<2000)
{
takeobj=false;
return;
}
else
{
players[index].statchangetimer.restart();
players[index].warping=true;
players[index].warptimer.restart();
players[index].horntimer.restart();
players[index].playsound("boat"+random(1,3));
players[index].give("boat",1);
}
}if(wname=="the_magical_flower")
{
players[index].itemgrabbing=true;
players[index].itemgrabtimer.restart();
play("mflower", players[index].x, players[index].y, players[index].z, players[index].map, index, false);
players[index].give("the_magical_flower",-1);
}
if(wname=="warp_box")
{
vector max=get_max_values(players[index].map);
if(players[index].statchangetimer.elapsed<20000)
{
send_reliable(players[index].peer_id,"you can't use this yet",0);
return;
}
if(in_vehicle(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"Not in a "+vs[in_vehicle(players[index].name)].type+"!",2);
return;
}
if(((max.x-players[index].x) <=100 and players[index].facing==90) or ((max.y-players[index].y) <= 100 and players[index].facing==0) or ((players[index].x-0) <= 100 and players[index].facing==270) or ((players[index].y-0) <= 100 and players[index].facing==180)) 
{
send_reliable(players[index].peer_id, "you can't use the warp_box here, because you are near edges ", 2);
return;
}
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].statchangetimer.restart();
players[index].warptimer.restart();
players[index].warping=true;
players[index].playsound("wppowerup");
}
if(wname=="beer_bottle")
{
players[index].playsound("openbeer"+random(1,3));
players[index].give("open_beer_bottle",1);
players[index].give("beer_bottle",-1);
send_reliable(players[index].peer_id,"You pop the cap, and you see the shiny cold liquid!",0);
return;
}
if(wname=="open_rum_bottle")
{
takeobj=false;
if(players[index].drunk==true)
{
send_reliable(players[index].peer_id,"You're already pretty drunk!",0);
return;
}
if(players[index].drinktimer.elapsed<1500)
{
send_reliable(players[index].peer_id,"Not so fast!",0);
return;
}
players[index].drinktimer.restart();
players[index].playsound("beerdrink");
players[index].beerswigs+=2;
players[index].drunkstage+=random(5,9);
}
if(wname=="beer_can")
{
takeobj=false;
if(players[index].drunk==true)
{
send_reliable(players[index].peer_id,"You're already pretty drunk!",0);
return;
}
if(players[index].drinktimer.elapsed<1500)
{
send_reliable(players[index].peer_id,"Not so fast!",0);
return;
}
players[index].drinktimer.restart();
players[index].playsound("eatcola");
players[index].beerswigs+=1;
players[index].drunkstage+=random(2,8);
}
if(wname=="rum_bottle")
{
players[index].playsound("openbeer"+random(1,3));
players[index].give("open_rum_bottle",1);
players[index].give("rum_bottle",-1);
send_reliable(players[index].peer_id,"You pop the cap, and you see the shiny cold liquid!",0);
return;
}
if(wname=="music_box")
{
players[index].playsound("urdusong"+random(1,35));
send_reliable(players[index].peer_id,"wait for the song to end! or if you don't want to listen, quit the game and re-enter!",0);
return;
}
if(wname=="open_beer_bottle")
{
takeobj=false;
if(players[index].drunk==true)
{
send_reliable(players[index].peer_id,"You're already pretty drunk!",0);
return;
}
if(players[index].drinktimer.elapsed<1500)
{
send_reliable(players[index].peer_id,"Not so fast!",0);
return;
}
players[index].drinktimer.restart();
players[index].playsound("beerdrink");
players[index].beerswigs+=1;
players[index].drunkstage+=random(3,9);
}
if(wname=="impact_bomb" and players[index].map!="store")
{
if(players[index].mbombtimer.elapsed>=2000)
{
spawn_impact_bomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
players[index].mbombtimer.restart();
}
else return;
}
else if(wname=="police_car"||wname=="police_car_super"||wname=="aircraft"||wname=="BMV"||wname=="helecopter"||wname=="lamborghini"||wname=="spaceship"||wname=="elecboat"||wname=="old_car"||wname=="tank"||wname=="Truck"||wname=="dogan_slx"||wname=="armored_tank"||wname=="police_motorcycle")
{
takeobj=false;
if(players[index].drunk==true)
{
send_reliable(players[index].peer_id,"Drunk driving is certainly not recommended!",0);
return;
}
if(in_vehicle(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"speak that won't work, jerk!",0);
return;
}
else if(players[index].map=="jail" or players[index].map=="main")
{
send_reliable(players[index].peer_id,"I don't think that would be such a good idea",2);
return;
}
if(players[index].z<0)
{
send_reliable(players[index].peer_id,"Sorry, this will not work under ground",0);
return;
}
else if(in_shelter(players[index].name)>-1)
{
send_reliable(players[index].peer_id, "you can't drive in a shelter. it's too small for a vehicle.", 2);
return;
}
string currenttile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(currenttile=="" or currenttile=="blank")
{
send_reliable(players[index].peer_id,"Not in the air!",0);
return;
}
else
{
spawn_vehicle(wname,index);
}
}
if(wname=="elecboat")
{
takeobj=false;
if(players[index].drunk==true)
{
send_reliable(players[index].peer_id,"Drunk driving is certainly not recommended!",0);
return;
}
if(in_vehicle(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"speak that won't work!",0);
return;
}
else if(players[index].map=="jail" or players[index].map=="main")
{
send_reliable(players[index].peer_id,"I don't think that would be such a good idea",2);
return;
}
if(players[index].z<0)
{
send_reliable(players[index].peer_id,"Sorry, this will not work under ground",0);
return;
}
else if(in_shelter(players[index].name)>-1)
{
send_reliable(players[index].peer_id, "you can't drive in a shelter. it's too small for a vehicle.", 2);
return;
}
string currenttile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(currenttile=="" or currenttile=="blank")
{
send_reliable(players[index].peer_id,"Not in the air!",0);
return;
}
else
{
spawn_vehicle(wname,index);
}
}
if(wname=="Storm_Sniper")
{
send_reliable(players[index].peer_id,"draw Storm_Sniper",0);
return;
}
if(wname=="stp")
{
send_reliable(players[index].peer_id,"draw stp",0);
return;
}
if(wname=="ak47")
{
send_reliable(players[index].peer_id,"draw ak47",0);
return;
}
if(wname=="the_legendary_sword")
{
send_reliable(players[index].peer_id,"draw the_legendary_sword",0);
return;
}
if(wname=="knife")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw knife",0);
}
}
if(wname=="beretta_m9_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw beretta_m9_pistol",0);
}
}
if(wname=="pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw pistol",0);
}
}
if(wname=="beretta_m1951_machine_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw beretta_m1951_machine_pistol",0);
}
}
if(wname=="beretta_nano_pocket_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw beretta_nano_pocket_pistol",0);
}
}
if(wname=="blz83_portable_machine_gun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw blz83_portable_machine_gun",0);
}
}
if(wname=="barrett_m82_sniper_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw barrett_m82_sniper_rifle",0);
}
}
if(wname=="famas")
{
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw famas",0);
}
}
}
if(wname=="bazooka")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw bazooka",0);
}
}
if(wname=="svd")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw svd",0);
}
}
if(wname=="rpg7")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw rpg7",0);
}
}
if(wname=="rocketlauncher")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw rocketlauncher",0);
}
}
if(wname=="mp5")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw mp5",0);
}
}
if(wname=="flamethrower")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw flamethrower",0);
}
}
if(wname=="glock")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw glock",0);
}
}
if(wname=="dart_launcher")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw dart_launcher",0);
}
}
if(wname=="taser")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw taser",0);
}
}
if(wname=="grenade_launcher")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw grenade_launcher",0);
}
}
if(wname=="kalashnikov_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw kalashnikov_rifle",0);
}
}
if(wname=="sks")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sks",0);
}
}
if(wname=="sniper")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sniper",0);
}
}
if(wname=="cannon")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw cannon",0);
}
}
if(wname=="strong_machinegun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw strong_machinegun",0);
}
}
if(wname=="browning_high_power_bda_handgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw browning_high_power_bda_handgun",0);
}
}
if(wname=="browning_m2_heavy_50_cal_machinegun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw browning_m2_heavy_50_cal_machinegun",0);
}
}
if(wname=="colt_ar_15_assault_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw colt_ar_15_assault_rifle",0);
}
}
if(wname=="colt_python_revolver")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw colt_python_revolver",0);
}
}
if(wname=="cop_357_derringer_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw cop_357_derringer_pistol",0);
}
}
if(wname=="m16")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m16",0);
}
}
if(wname=="m8a7")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m8a7",0);
}
}
if(wname=="brass_knuckles")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw brass_knuckles",0);
}
}
if(wname=="broken_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw broken_rifle",0);
}
}
if(wname=="crow_bar")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw crow_bar",0);
}
}
if(wname=="crt17_combat_knife")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw crt17_combat_knife",0);
}
}
if(wname=="golden_war_axe")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw golden_war_axe",0);
}
}
if(wname=="hammer")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw hammer",0);
}
}
if(wname=="iron_shovel")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw iron_shovel",0);
}
}
if(wname=="large_iron_club")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw large_iron_club",0);
}
}
if(wname=="machete")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw machete",0);
}
}
if(wname=="nunchaku")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw nunchaku",0);
}
}
if(wname=="rusty_axe")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw rusty_axe",0);
}
}
if(wname=="sky_286_laser_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sky_286_laser_pistol",0);
}
}
if(wname=="sky_372_laser_machinegun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sky_372_laser_machinegun",0);
}
}
if(wname=="sky_386_laser_assault_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sky_386_laser_assault_rifle",0);
}
}
if(wname=="sky_429_laser_shotgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sky_429_laser_shotgun",0);
}
}
if(wname=="crt43_automatic_shotgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw crt43_automatic_shotgun",0);
}
}
if(wname=="glock_17_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw glock_17_pistol",0);
}
}
if(wname=="m4")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m4",0);
}
}
if(wname=="FRNTAssaultRifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw FRNTAssaultRifle",0);
}
}
if(wname=="crossbow")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw crossbow",0);
}
}
if(wname=="s&w_model66_revolver")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw s&w_model66_revolver",0);
}
}
if(wname=="m4a1_assault_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m4a1_assault_rifle",0);
}
}
if(wname=="m16_assault_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m16_assault_rifle",0);
}
}
if(wname=="m24_sniper_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m24_sniper_rifle",0);
}
}
if(wname=="m134_minigun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m134_minigun",0);
}
}
if(wname=="m1208_shotgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m1208_shotgun",0);
}
}
if(wname=="dragunovp_sniper")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw dragunovp_sniper",0);
}
}
if(wname=="mlk_203_combat_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw mlk_203_combat_pistol",0);
}
}
if(wname=="mlk_207_combat_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw mlk_207_combat_rifle",0);
}
}
if(wname=="modern_sub_machine_gun_carbine")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw modern_sub_machine_gun_carbine",0);
}
}
if(wname=="mp5_machine_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw mp5_machine_pistol",0);
}
}
if(wname=="nak_nk1000_decimater")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw nak_nk1000_decimater",0);
}
}
if(wname=="m2browning")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m2browning",0);
}
}
if(wname=="ruger_security_6_revolver")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw ruger_security_6_revolver",0);
}
}
if(wname=="ml_Automatic_machinegun")
{
{
takeobj=false;
//send_reliable(players[index].peer_id,"draw ml_Automatic_machinegun",0);
return;
}
}
if(wname=="ak47")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw ak47",0);
}
}
if(wname=="saiga_12_5_round_shotgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw saiga_12_5_round_shotgun",0);
}
}
if(wname=="sig_p226_combat_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sig_p226_combat_pistol",0);
}
}
if(wname=="sky_28_laser")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sky_28_laser",0);
}
}
if(wname=="sky_127_laser_handgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw sky_127_laser_handgun",0);
}
}
if(wname=="m29_sniper_rifle")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m29_sniper_rifle",0);
}
}
if(wname=="m1891")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m1891",0);
}
}
if(wname=="m1921a1")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw m1921a1",0);
}
}
if(wname=="machinegun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw machinegun",0);
}
}
if(wname=="stp_s84q_automatic_suppressed_pistol")
{
{
takeobj=false;
//send_reliable(players[index].peer_id,"draw stp_s84q_automatic_suppressed_pistol",0);
}
}
if(wname=="stp21_handgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw stp21_handgun",0);
}
}
if(wname=="stp106_long_barreled_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw stp106_long_barreled_pistol",0);
}
}
if(wname=="str_32_pump_action_shotgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw str_32_pump_action_shotgun",0);
}
}
if(wname=="str_301_long_barreled_machine_pistol")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw str_301_long_barreled_machine_pistol",0);
}
}
if(wname=="walther_p99_handgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw walther_p99_handgun",0);
}
}
if(wname=="shotgun")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw shotgun",0);
}
}
if(wname=="revolver")
{
{
takeobj=false;
send_reliable(players[index].peer_id,"draw revolver",0);
}
}
if(wname=="stun_dart")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"You can not use it while you are pacifist",0);
return;
}
else if(players[index].stunthrowtimer.elapsed>=7500)
{
players[index].stunthrowtimer.restart();
play("stun_dartthrow",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
}
else
{
takeobj=false;
}
}
if(wname=="grenade" and players[index].map!="store")
{
if(players[index].invinsible==true)
return;
if(players[index].grenadetimer.elapsed<1600)
{
takeobj=false;
}
else
{
play("grenadethrow.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].grenadetimer.restart();
}
}
if(wname=="poison_dagger")
{
if(players[index].poison_daggertimer.elapsed<1)
{
takeobj=false;
}
else
{
play("poison_daggerthrow.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].poison_daggertimer.restart();
}
}
if(wname=="dagger")
{
{
players[index].give("poison_dagger",1);
play("daggerpoison",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(e.peer_id,"dagger has now become poison!",2);
}
}
if(wname=="death_free_card")
{
takeobj=false;
}
if(wname=="stp429" and players[index].map!="store")
{
if(players[index].stp429timer.elapsed<2000)
{
takeobj=false;
}
else
{
play("stp429throw.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].stp429timer.restart();
}
}
else if(wname=="helicopter"&&players[index].helicopterspawning==false)
{
if(players[index].statchangetimer.elapsed<30000){
send_reliable(0,"play_s thunder3.ogg",0);
send_reliable(players[index].peer_id,"you can't launch the helicopter",0);
return;
}
takeobj=true;
send_reliable(0, players[index].name+" Is launching a helicopter!", 2);
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("helicopterstart");
players[index].helicoptertimer.restart();
players[index].statchangetimer.restart();
players[index].helicopterspawning=true;
}
else if(wname=="dog")
{
if(players[index].statchangetimer.elapsed<20){
send_reliable(players[index].peer_id,"you can't launch the dog",0);
return;
}
takeobj=true;
send_reliable(0, players[index].name+" Is launching a dog!", 2);
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("dog_voice1");
players[index].helicoptertimer.restart();
players[index].statchangetimer.restart();
players[index].helicopterspawning=true;
}
else if(wname=="cop")
{
if(players[index].statchangetimer.elapsed<20){
send_reliable(0,"play_s thunder3.ogg",0);
send_reliable(players[index].peer_id,"you can't launch the cop",0);
return;
}
takeobj=true;
send_reliable(0, players[index].name+" Is launching a cop!", 2);
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("helicopterstart");
players[index].helicoptertimer.restart();
players[index].statchangetimer.restart();
players[index].helicopterspawning=true;
}
if(wname=="hand_grenade")
{
if(players[index].hand_grenadetimer.elapsed<2000)
{
takeobj=false;
}
else
{
play("draw_grenade",players[index].x,players[index].y,players[index].z,players[index].map);
play("hand_grenadethrow.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].hand_grenadetimer.restart();
}
}
if(wname=="pipe_bomb" and players[index].map!="store")
{
if(players[index].pipe_bombtimer.elapsed<2000)
{
takeobj=false;
}
else
{
play("pipe_bombthrow.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].pipe_bombtimer.restart();
}
}
if(wname=="rocket" and players[index].map!="store")
{
if(players[index].rockettimer.elapsed<1600)
{
takeobj=false;
}
else
{
play("rocketthrow.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].rockettimer.restart();
}
}
if(wname=="sticky_bomb")
{
play("stickybombthrow",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
}
if(wname=="shield")
{
if(players[index].shieldshots>=players[index].maxshields)
{
send_reliable(players[index].peer_id,"I think you'll be ok for now",0);
takeobj=true;
return;
}
else if(players[index].statchangetimer.elapsed<30000)
{
takeobj=true;
send_reliable(players[index].peer_id,"speak You can't use this yet!",0);
return;
}
else
{
players[index].shieldshots+=random(500,500);
play("shieldon",players[index].x,players[index].y,players[index].z,players[index].map);
}
play("shieldon2",players[index].x,players[index].y,players[index].z,players[index].map);
}
if(wname=="shield_remover")
{
if(players[index].shieldshots<=1)
{
send_reliable(players[index].peer_id,"You don't have any shields equipped!",0);
return;
}
else
{
takeobj=true;
players[index].shieldshots-=random(3000,3000);
play("notify_packman",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id,"speak Your shields are now removed!",0);
}
}
if(wname=="fire_extinguisher")
{
play("fire_extinguisher",players[index].x,players[index].y,players[index].z,players[index].map);
for(uint i=0; i<fires.length(); i++)
{
if(get_3d_distance(players[index].x,players[index].y,players[index].z,fires[i].x,fires[i].y,fires[i].z)<=5 and players[index].map==fires[i].map)
fires[i].lifetimer.force(fires[i].lifetime);
}
}
if(wname=="guided_missile")
{
takeobj=false;
if(players[index].map=="store")
return;
else if(players[index].invinsible==true)
return;
else if(players[index].missiletimer.elapsed<missiletime) return;
else if(missiles.length()>=missilemax)
{
if(missilemax==0) send_reliable(e.peer_id,"speak Missiles are currently disabled",0);
else send_reliable(e.peer_id,"speak Too many missiles are already active. Wait for some to explode first",0);
}
else
send_menu(players[index].peer_id,"This missile has 2 different modes. You can select a player to send this missile to, or you can manually enter the x, y, z of the missile. What would you like to do","missilemode","Track a player:missileplayer[]Enter information manually:missileenter");
}
if(wname=="carrier_missile" and players[index].map!="store")
{
takeobj=false;
string menuitems;
string items=players[index].get_inv(false);
if(items=="")
{
send_reliable(players[index].peer_id,"Sorry, your inventory is empty",2);
return;
}
string[] p=string_split(items,"\r\n",false);
for(uint i=0; i<p.length(); i++)
{
string[] another_p=string_split(p[i],"=",false);
menuitems+=another_p[0]+", you have "+another_p[1]+":"+another_p[0]+"[]";
}
send_menu(players[index].peer_id,"Select the item you would like to send","cmstart",menuitems);
}
if(wname=="gas_mask")
{
takeobj=false;
if(players[index].air>0)
players[index].airlifetimer.restart();
players[index].airtimer.restart();
players[index].mask=toggle(players[index].mask);
string action=(players[index].mask==1 ? "on" : "off");
players[index].playsound("gas_mask"+action);
send_reliable(players[index].peer_id,"mask "+action,2);
}
if(wname=="air_canister")
{
spawn_canister(players[index].x,players[index].y,players[index].z,players[index].map,"air");
}
if(wname=="antibiotic_canister")
{
if(players[index].health>=100000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
if(players[index].statchangetimer.elapsed<10000)
{
send_reliable(players[index].peer_id,"Sorry...can't be gaining or losing health to do this",0);
return;
}
spawn_canister(players[index].x,players[index].y,players[index].z,players[index].map,"antibiotic");
}
if(wname=="wirebomb")
{
takeobj=false;
if(players[index].statchangetimer.elapsed<15000 or players[index].stunthrowtimer.elapsed<15000)
{
send_reliable(players[index].peer_id,"You can't spawn wirebombs just yet!",0);
return;
}
for(uint i=0; i<wirebombs.length(); i++)
{
if(players[index].distancecheck(wirebombs[i].x,wirebombs[i].y,wirebombs[i].z)<=15 and wirebombs[i].map==players[index].map)
{
send_reliable(players[index].peer_id,"You can't put too many wire bombs close together!",0);
return;
}
}
place_wirebomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
takeobj=true;
}
if(wname=="wood")
{
takeobj=false;
string items=players[index].get_inv();
int s=in_shelter(players[index].name);
if(s>-1)
{
if(shelters[s].health>500000000) return;
send_serverbox(players[index].peer_id,2,2,1,-1,"shelterfix","How much wood would you like to add to this shelter?");
}
else
{
if(inv_item_number(items,"wood")<500)
{
send_reliable(players[index].peer_id,"not enough wood!",2);
return;
}
send_serverbox(players[index].peer_id,0,-1,0,-1,"build_shelter ","Enter the name of your shelter. Note: your name must not include spaces!");
}
}
if(wname=="metal")
{
takeobj=false;
string items=players[index].get_inv();
int v=in_vehicle(players[index].name);
if(v<0)
{
send_reliable(players[index].peer_id,"",2);
return;
}
else if(inv_item_number(items,"toolbox")<1)
{
send_reliable(players[index].peer_id,"you need a toolbox to begin this operation!",2);
return;
}
else if(vs[v].type=="tank"&&inv_item_number(items,"metal")<50)
{
send_reliable(players[index].peer_id,"you need at least 50 metal to repair a tank.",2);
return;
}
else if(vs[v].type=="aircraft"&&inv_item_number(items,"metal")<30)
{
send_reliable(players[index].peer_id,"you need at least 30 metal to repair an aircraft",2);
return;
}
else
{
int am=vs[v].type=="tank" ? 50 : 30;
players[index].give("metal",-am);
vs[v].command("repair");
}
}
if(wname=="toolbox")
{
takeobj=false;
}
if(wname=="fuel_tank")
{
if(in_vehicle(players[index].name)<0)
{
for(uint shi=0; shi<shelters.length; shi++)
{
if(shelters[shi].x==players[index].x&&shelters[shi].y==players[index].y&&shelters[shi].z==players[index].z&&shelters[shi].map==players[index].map)
{
takeobj=true;
shelters[shi].fuel+=random(10,15);
play("vehicle_refuel",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("fuel_tank",-1);
return;
}
}
takeobj=false;
send_reliable(players[index].peer_id,"a fuel tank cannot be used in this condition. If you are trying to refuel a shelter, use this fuel tank on it's outside generator",0);
}
if(in_vehicle(players[index].name)>-1)
{
int v=in_vehicle(players[index].name);
if(vs[v].speed>0)
{
takeobj=false;
send_reliable(players[index].peer_id,"you must be stopped to refuel your vehicle",0);
}
else
{
playext("vehicle_refuel",vs[v].x,vs[v].y,vs[v].z,vs[v].map,vs[v].owner);
playint("vehicle_refuel",vs[v].owner);
vs[v].fuel=100;
takeobj=true;
}
}
}
if(wname=="remote_timebomb")
{
if(players[index].rbombs>=players[index].rbomblimit)
{
takeobj=false;
send_reliable(players[index].peer_id,"Uh, don't go too crazy with these!",0);
return;
}
else
{
if(players[index].map!="store")
{
send_serverbox(players[index].peer_id,2,-1,1,-1,"rbomb","Enter the code you would like this bomb to have");
}
else takeobj=false;
}
}
if(wname=="sat_bomb")
{
if(players[index].sbombs>=players[index].rbomblimit)
{
takeobj=false;
send_reliable(players[index].peer_id,"Uh, don't go too crazy with these!",0);
return;
}
else
{
if(players[index].map!="store")
{
send_serverbox(players[index].peer_id,2,-1,1,-1,"rbomb","Enter the code you would like this bomb to have");
}
else takeobj=false;
}
}
if(wname=="mine")
{
if(players[index].map!="store")
{
if(mines_at(players[index].x,players[index].y,players[index].z,players[index].map)>=5)
{
players[index].sendpacket("speak There are already enough mines here!",0);
return;
}
place_mine(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
else takeobj=false;
}
else if(wname=="blindgamers_pack")
{
players[index].give("health_drink",100);
players[index].give("police_car_super",10);
players[index].give("dollar",100000);
players[index].give("shield",1000);
players[index].give("tk_ultra_health_potion",20);
send_reliable(players[index].peer_id,"you opened to _pack!",2);
send_reliable(players[index].peer_id,"play_s purchase.ogg",0);
}
//packs code goes here for purchased made with the online store.
else if(wname=="stored_health")
{
if(players[index].health>=100000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
if(players[index].statchangetimer.elapsed<60000) return;
players[index].playsound("stored_health");
players[index].health=100000;
}
if(wname=="stun_grenade")
{
if(players[index].stungrenadetimer.elapsed<5000)
{
takeobj=false;
return;
}
players[index].stungrenadetimer.restart();
placestun_grenade(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
if(wname=="mass_bomb")
{
if(players[index].masstimer.elapsed<3000)
{
takeobj=false;
return;
}
players[index].masstimer.restart();
placemass_bomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
if(wname=="concussive_grenade")
{
if(players[index].concussivegrenadetimer.elapsed<3000)
{
takeobj=false;
return;
}
players[index].concussivegrenadetimer.restart();
placeconcussive_grenade(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
if(wname=="frequency_scrambler")
{
if(players[index].statchangetimer.elapsed<60000)
{
send_reliable(players[index].peer_id,"Error!",0);
return;
}
if(players[index].invusetimer.elapsed>=100000)
{
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].invusetimer.restart();
}
else
{
takeobj=false;
send_reliable(players[index].peer_id,"speak error. You can not use an frequency scrambler yet.",0);
}
}
if(wname=="suicide_bomb")
{
if(players[index].invinsible==true)
return;
if(players[index].suicidetimer.elapsed<5000)
{
takeobj=false;
return;
}
players[index].suicidetimer.restart();
placesuicide_bomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
if(wname=="store_card")
{
if(players[index].suicidetimer.elapsed<5000)
{
takeobj=false;
return;
}
move_player(players[index],"main2",0,0,0);
players[index].suicidetimer.restart();
}
if(wname=="healthy_card")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"You can not use it while you are pacifist",0);
return;
}
else if(players[index].horntimer.elapsed<7000000)
{
takeobj=false;
send_reliable(players[index].peer_id,"speak You can not use the healthy card now,!",0);
return;
}
else if(in_vehicle(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"speak That don't work!",0);
return;
}
else if(players[index].health>=20000000)
{
send_reliable(players[index].peer_id,"Your extreme health is 20000000, and you cannot go to healthier one.",0);
}
else
{
players[index].playsound("health");
players[index].health+=20000000;
send_reliable(players[index].peer_id,"Congratulations, Your health is now 20000000! enjoy!",0);
players[index].give("healthy_card",-1);
players[index].horntimer.restart();
}
}
if(wname=="arina_card")
{
if(players[index].invinsible==true)
{
send_reliable(players[index].peer_id,"You can not go to sword fighting arena while you are pacifist",0);
return;
}
else if(players[index].horntimer.elapsed<20000)
{
takeobj=false;
send_reliable(players[index].peer_id,"speak You can not use the Arina card now! Wait for 20 seconds!",0);
}
else if(players[index].map=="arina")
{
send_reliable(players[index].peer_id,"You are all reddy in arina!",2);
return;
}
else if(players[index].map=="jail")
{
send_reliable(players[index].peer_id,"O? Want to brake your jail period? just fuck off!",2);
return;
}
else if(in_vehicle(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"speak That don't work!",0);
return;
}
 else if(players[index].shieldshots>=1)
{
players[index].shieldshots-=3000;
players[index].give("shield",random(1,6));
}
else
{
send_reliable(0, "play_s event.ogg", 0);
send_reliable(0,"The player "+players[index].nickname+" has just joined the sword fighting arina!",2);
move_player(players[index],"arina",random(0,300),random(0,300),0);
players[index].horntimer.restart();
}
}
if(wname=="safe_card")
{
if(players[index].suicidetimer.elapsed<5000)
{
takeobj=false;
return;
}
move_player(players[index],"main",0,0,0);
players[index].suicidetimer.restart();
}
if(wname=="sound_grenade")
{
if(players[index].sound_grenadetimer.elapsed<5000)
{
takeobj=false;
return;
}
players[index].sound_grenadetimer.restart();
placesound_grenade(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
if(wname=="store_porting")
{
if(players[index].sound_grenadetimer.elapsed<5000)
{
takeobj=false;
return;
}
players[index].sound_grenadetimer.restart();
send_reliable(0,"done",0);
move_player(players[index],"main",0,0,0);
}
if(wname=="nuclear_bomb")
{
if(players[index].invinsible==true)
return;
if(players[index].nucleartimer.elapsed<1000)
{
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile=="" and in_shelter(players[index].name)<0)
send_reliable(players[index].peer_id,"You can't do this in the air!",0);
takeobj=false;
return;
}
else
{
players[index].nucleartimer.restart();
placenuclear_bomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
}
if(wname=="bottle_bomb")
{
if(players[index].bottlebombtimer.elapsed<500)
{
takeobj=false;
}
else
{
play("bottlebombthrow",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].bottlebombtimer.restart();
}
}
if(wname=="stone")
{
if(players[index].stonetimer.elapsed<1000)
{
takeobj=false;
}
else
{
play("stonethrow",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].stonetimer.restart();
}
}
if(wname=="motion_bomb")
{
if(players[index].mbombtimer.elapsed<1600)
{
takeobj=false;
return;
}
players[index].mbombtimer.restart();
spawn_motion_bomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
play("motion_bombplacing",players[index].x,players[index].y,players[index].z,players[index].map);
}
if(wname=="health_dart")
{
if(players[index].stunthrowtimer.elapsed>=7500)
{
players[index].stunthrowtimer.restart();
play("stun_dartthrow",players[index].x,players[index].y,players[index].z,players[index].map);
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
}
else
{
takeobj=false;
}
}
if(wname=="invisibility_shield")
{
if(players[index].statchangetimer.elapsed<30000)
{
send_reliable(players[index].peer_id,"Error!",0);
return;
}
if(players[index].invusetimer.elapsed>=60000)
{
spawn_weapon(players[index].x, players[index].y, players[index].z, players[index].facing, wname, players[index].map, players[index]);
players[index].invusetimer.restart();
}
else
{
takeobj=false;
send_reliable(players[index].peer_id,"speak error. You can not use an invisibility shield yet.",0);
}
}
else if(wname=="ultrabomb_silencer")
{
bool hasu=false;
string[] ultrabombset;
takeobj=false;
for(uint i=0; i<ultrabombs.length(); i++)
{
if(ultrabombs[i].x==players[index].x and ultrabombs[i].y==players[index].y and ultrabombs[i].z==players[index].z and players[index].map==ultrabombs[i].map and ultrabombs[i].silenced==false and ultrabombs[i].started==true)
{
ultrabombset.insert_last(ultrabombs[i].id);
hasu=true;
}
}
if(hasu==true)
{
takeobj=true;
for(uint j=0; j<ultrabombset.length(); j++)
{
for(uint j2=0; j2<ultrabombs.length(); j2++)
{
if(ultrabombs[j2].id==ultrabombset[j])
{
play("ultrabombgenerator_off",ultrabombs[j2].x,ultrabombs[j2].y,ultrabombs[j2].z,ultrabombs[j2].map);
destroy_moving_sound(ultrabombs[j2].loopid);
ultrabombs[j2].silenced=true;
}
}
}
}
}
else if(wname=="tk_deluxe_pack")
{
players[index].give("tank",50);
players[index].give("aircraft",100);
players[index].give("tk_ultra_health_potion",20);
players[index].give("guided_missile",100);
players[index].give("missile_interceptor",250);
players[index].give("bitcoin",10);
players[index].give("motion_bomb",50);
players[index].give("mine",20);
players[index].give("wirebomb",100);
players[index].give("shield",500);
players[index].give("ultrabomb",10);
send_reliable(players[index].peer_id,"TK deluxe pack activated!",2);
scd(index);
}
else if(wname=="bitcoin")
{
takeobj=false;
bool useable=false;
int s=in_shelter(players[index].name);
if(s>-1 and players[index].x==0 and players[index].y==50 and players[index].z==0)
{
useable=true;
players[index].give("bitcoin",-1);
shelters[s].dollars+=50000;
}
int v=get_vending_index(players[index].x,players[index].y,players[index].z,players[index].map);
if(v>-1)
{
players[index].give("bitcoin",-1);
useable=true;
vending_machines[v].dollars+=50000;
}
for(int i=0; i<stores.length(); i++)
{
if(round(players[index].x,0)==50 and round(players[index].y,0)==50 and players[index].z==50 and players[index].map=="the_bank")
{
useable=true;
players[index].give("bitcoin", -1);
players[index].give("dollar", 50000);
send_reliable(players[index].peer_id, "you received 50000 dollars for exchanging a bitcoin", 2);
}
}
if(useable)
players[index].playsound("shelter_comp_bitcoin_insert");
else
send_reliable(players[index].peer_id,"Sorry, you must be standing on a shelter computer, vending machine or bitcoin machine to use this item",0);
}
else if(wname=="dollar")
{
int j=get_jplayer_index(round(players[index].x,0), players[index].y,players[index].z,players[index].map);
if(j>-1)
{
if(jplayers[j].jstarted==true)
{
send_reliable(players[index].peer_id,"already in use",0);
return;
}
else
{
takeobj=true;
jplayers[j].coins+=1;
jplayers[j].start();
players[index].playsound("ultrabombcoinadd");
}
}
int vending=get_vending_index(players[index].x,players[index].y,players[index].z,players[index].map);
if(vending>-1)
{
send_serverbox(players[index].peer_id, 2, -1, -1, -1, "insertamount", "how many dollars do you want to insert into this vending machine?");
}
if(in_shelter(players[index].name)>-1)
{
if(players[index].x==0 and players[index].y==50 and players[index].z==0)
{
send_serverbox(players[index].peer_id, 2, -1, -1, -1, "insertamount", "how many dollars do you want to add to this shelter?");
}
}
bool hasu=false;
string[] ultrabombset;
takeobj=false;
for(uint i=0; i<ultrabombs.length(); i++)
{
if(ultrabombs[i].x==round(players[index].x,0) and ultrabombs[i].y==round(players[index].y, 0) and ultrabombs[i].z==players[index].z and players[index].map==ultrabombs[i].map and ultrabombs[i].dollars<20)
{
ultrabombset.insert_last(ultrabombs[i].id);
hasu=true;
}
}
if(hasu==true)
{
takeobj=true;
for(uint j=0; j<ultrabombset.length(); j++)
{
for(uint j2=0; j2<ultrabombs.length(); j2++)
{
if(ultrabombs[j2].id==ultrabombset[j])
{
ultrabombs[j2].dollars+=1;
ultrabombs[j2].owner=players[index].name;
play("ultrabombcoinadd",ultrabombs[j2].x,ultrabombs[j2].y,ultrabombs[j2].z,ultrabombs[j2].map);
}
}
}
}
}
else if(wname=="ultrabomb")
{
if(in_shelter(players[index].name)>-1 and players[index].x==7 and players[index].y==7 and players[index].z==0)
{
send_reliable(players[index].peer_id,"Can not place ultrabombs here",0);
takeobj=false;
return;
}
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile=="" and in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"You can't do this in the air!",0);
takeobj=false;
return;
}

for(uint u=0; u<ultrabombs.length(); u++)
{
if(ultrabombs[u].x==players[index].x and ultrabombs[u].y==players[index].y and ultrabombs[u].z==players[index].z and ultrabombs[u].map==players[index].map)
{
send_reliable(players[index].peer_id,"Oops? It seems as though there is already an ultrabomb placed there",0);
return;
}
}
players[index].ultrabombtimer.restart();
players[index].ultrabombplacing=true;
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("ultrabombdeploy");
}
else if(wname=="health_orb")
{
if(players[index].statchangetimer.elapsed<30000)
{
takeobj=false;
send_reliable(players[index].peer_id,"speak You can't use this yet!",0);
return;
}
spawn_horb(players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="antibiotic")
{
if(players[index].antibioticed==true)
{
takeobj=false;
send_reliable(players[index].peer_id,"Wait until your antibiotic ware's off!",0);
return;
}
if(players[index].health>=100000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<20000)
{
takeobj=false;
send_reliable(players[index].peer_id,"speak You can't use this yet!",0);
return;
}
else
{
players[index].playsound("antibiotic");
players[index].antibiotictimer.restart();players[index].awarnouttimer.restart();
players[index].antibioticed=true;
}
}
else if(wname=="mini_antibiotic_pack")
{
players[index].give("antibiotic",5);
players[index].give("empty_pack", 1);
play("getantibiotic",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="tk_donation_pack")
{
players[index].give("tank",10);
players[index].give("aircraft",10);
players[index].give("dollar",10000);
send_reliable(players[index].peer_id,"You have activated a donation pack! Thank you for donating!",2);
send_reliable(players[index].peer_id,"play_s teamcreate.ogg",0);
}
//packs code goes here for purchased made with the online store.
else if(wname=="tk_warp_box_pack")
{
players[index].playsound("gift");
players[index].give("warp_box",20);
send_reliable(players[index].peer_id,"you have opened a "+string_replace(wname,"_"," ",true)+"!",2);
}
else if(wname=="missile_pack")
{
players[index].give("guided_missile",20);
players[index].give("missile_interceptor",10);
play("openpack",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id,"you have opened a "+string_replace(wname,"_"," ",true)+"!",2);
scd(index);
}
else if(wname=="Storm_Sniper_ammo_pack")
{
players[index].give("ammo_Storm_Sniper",20);
play("ammo_box",players[index].x,players[index].y,players[index].z,players[index].map);
scd(index);
}

else if(wname=="gift_pack")
{
players[index].give("health_box",100);
players[index].give("health_healer",200);
players[index].give("dollar",5000000);
players[index].give("suicide_bomb",50);
players[index].give("Storm_Sniper_ammo_pack",50);
players[index].give("nuclear_bomb",50);
play("packopen",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id,"this pack contains 50 Storm_Sniper_ammo_pack,200 health_healer,100 health_box,5000000 dollars,50 suicide_bombs,50 neuclear_bombs,"+string_replace(wname,"_"," ",true)+"!",2);
scd(index);
}else if(wname=="tw_pack")
{
players[index].give("Storm_Sniper_ammo_pack",200);
players[index].give("health_box",200);
players[index].give("dollar",20000000);
players[index].give("stun_dart",200);
players[index].give("suicide_bomb",100);
players[index].give("invisibility_shield",100);
players[index].give("wood",1000);
players[index].give("ammo_rpg7",1000);
players[index].give("gold",100);
players[index].give("timebomb",10);
players[index].give("motion_bomb",10);
players[index].give("nuclear_bomb",50);
play("packopen",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id,"this pack contains 200 Storm_Sniper_ammo_pack,200 health_box,20000000 dollars,200 stun_darts,100 suicide_bombs,100 invisibility_shields,1000 woods,1000 ammo_rpg7 ,100 gold,10 time_bombs,10 motion_bombs,50 neuclear_bombs,"+string_replace(wname,"_"," ",true)+"!",2);
scd(index);
}
else if(wname=="fire_starter")
{
takeobj=false;
if(players[index].statchangetimer.elapsed<30000)
{
send_reliable(players[index].peer_id,"speak You can't use this yet!",0);
return;
}
if(starter_exist_on(players[index].x,players[index].y,players[index].z,players[index].map)==false)
{
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile=="wood" or tile=="wood2" or tile=="wood3" or tile=="wood4" or tile=="wood5" or tile=="wood6" or tile=="wood7" or tile=="wood8" or tile=="wood9" or tile=="wood10" or tile=="branch" or tile=="branch2" or tile=="carpet" or tile=="carpet2" or tile=="carpet3" or tile=="tile2")
{
spawn_fire(players[index].x,players[index].y,players[index].z,players[index].map,random(100,500));
}
else if(tile=="water" or tile=="water2" or tile=="water3" or tile=="water4" or tile=="sewer")
{
send_reliable(players[index].peer_id,"speak You can't use this in this wet tile!!",0);
}
else
{
spawn_starter(players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("fire_starter", -1);
return;
}
}
else
{
send_reliable(players[index].peer_id,"fire is already here",2);
return;
}
}
else if(wname=="gold")
{
takeobj=false;
bool useable=false;
for(int i=0; i<stores.length(); i++)
{
if(round(players[index].x,0)==100 and round(players[index].y,0)==100 and players[index		].z==100 and players[index].map=="the_bank")
{
useable=true;
players[index].give("gold", -1);
players[index].give("dollar", 250000);
send_reliable(players[index].peer_id, "you received 250000 dollars for exchanging a 1gold", 2);
}
}
if(useable)
players[index].playsound("gtake");
else
send_reliable(players[index].peer_id,"Sorry, you must be standing on a Gold machine to use the gold",0);
}
else if(wname=="tk_mini_warp_box_pack")
{
players[index].playsound("gift");
players[index].give("warp_box",5);
send_reliable(players[index].peer_id,"you have opened a "+string_replace(wname,"_"," ",true)+"!",2);
}
else if(wname=="tk_ultra_warp_box_pack")
{
players[index].playsound("gift");
players[index].give("warp_box",50);
send_reliable(players[index].peer_id,"you have opened a "+string_replace(wname,"_"," ",true)+"!",2);
}
if(wname=="bitcoin_pack")
{
players[index].give("bitcoin",5);
play("gift",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="grenade_pack")
{
players[index].give("grenade",10);
players[index].give("empty_pack", 1);
play("getgrenade",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="antibiotic_pack")
{
players[index].give("antibiotic",20);
play("getantibiotic",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="tk_ultra_health_potion_set")
{
players[index].playsound("getultra");
players[index].give("tk_ultra_health_potion",5);
send_reliable(players[index].peer_id,"you have opened a "+string_replace(wname,"_"," ",true)+"!",2);
}
else if(wname=="tk_ultra_health_potion")
{
if(players[index].health>=20000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
if(players[index].statchangetimer.elapsed<60000) return;
players[index].playsound("ultrapotion");
players[index].health=20000000;
send_reliable(players[index].peer_id,"your health has been restored!",0);
}
else if(wname=="ball_gangster")
{
if(players[index].statchangetimer.elapsed<60000) return;
players[index].playsound("cannondist");
players[index].playsound("cannonhit1");
players[index].health=0;
}
else if(wname=="health_box")
{
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
return;
}
else if(players[index].statchangetimer.elapsed<60000) return;
players[index].playsound("health_box");
players[index].health=10000000;
}
else if(wname=="hand_grenade_pack")
{
players[index].give("hand_grenade",20);
players[index].give("empty_pack", 1);
play("getgrenade",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="clear_stats")
{
players[index].give("clear_stats",-1);
send_reliable(players[index].peer_id,"Your death count was just cleared",2);
players[index].deaths=0;
scd(index);
}
else if(wname=="golden_pack")
{
players[index].give("air_canister",100);
players[index].give("bitcoin",100);
players[index].give("concussive_grenade",50);
players[index].give("dollar",1000000);
players[index].give("frequency_scrambler",50);
players[index].give("fight_inviter",50);
players[index].give("gold",25);
players[index].give("gas_mask",2);
players[index].give("stun_dart",100);
players[index].give("wood_pack",150);
play("packopen",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id,"this pack contains 100 air_canister,100 bitcoin,50 concussive_grenade,1000000 dollar,50 frequency_scrambler,50 fight_inviter,25 gold,2 gas_mask,100 stun_dart,150 wood_pack, "+string_replace(wname,"_"," ",true)+"!",2);
scd(index);
}
else if(wname=="new_year_gift_pack")
{
players[index].give("ultrabomb",100);
players[index].give("ultrabomb_silencer",100);
players[index].give("health_box",500);
players[index].give("dollar",25000000);
players[index].give("stun_dart",100);
players[index].give("health_healer",1000);
players[index].give("invisibility_shield",100);
players[index].give("htp_pack",1);
players[index].give("timebomb",100);
players[index].give("motion_bomb",100);
players[index].give("golden_pack",1);
players[index].give("frequency_scrambler",100);
players[index].give("gold",20);
players[index].give("bitcoin",50);
players[index].give("empty_pack",250);
players[index].give("beer_bottle",150);
players[index].give("cola",100);
players[index].give("biscuit",100);
players[index].give("chips",100);
players[index].give("apple_juice",100);
players[index].give("popcorn",100);
players[index].give("milk",100);
players[index].give("juce_box",100);
play("packopen",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id,"this pack contains 100 ultrabomb,100 ultrabomb_silencer,500 health_box,25000000 dollar,100 stun_dart,1000 health_healer,100 invisibility_shield,1 htp_pack,100 timebomb,100 motion_bomb,1 golden_pack,100 frequency_scrambler,20 gold,50 bitcoin,250 empty_pack,150 beer_bottle,100 cola,100 biscuit,100 chips,100 apple_juce,100 juce_box,100 popcorn,100 milk!"+string_replace(wname,"_"," ",true)+"!",2);
scd(index);
}
else if(wname=="ALT_pack")
{
players[index].give("suicide_bomb",300);
players[index].give("nuclear_bomb",200);
players[index].give("ammo_bazooka",100);
players[index].give("dollar",75000000);
players[index].give("health_healer",500);
players[index].give("Truck",5);
players[index].give("police_car",5);
players[index].give("tank",5);
players[index].give("tank",5);
players[index].give("armored_tank",5);
players[index].give("aircraft",5);
players[index].give("health_box",200);
players[index].give("shield",500);
players[index].give("invisibility_shield",250);
players[index].give("stp429",100);
players[index].give("missile_interceptor",100);
play("packopen",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id,"this pack contains 300 suicide_bomb,200 nuclear_bomb,100 ammo_bazooka,500 health_healer,200 health_box,75000000 dollar,500 shield,250 invisibility_shield,100 stp429,100 missile_interceptor,5 tank,5 aircraft,5 armored_tank,5 police_car,5 Truck "+string_replace(wname,"_"," ",true)+"!",2);
scd(index);
}
else if(wname=="fire_pack")
{
players[index].give("dollar",10000000);
players[index].give("health_box",100);
players[index].give("health_healer",200);
players[index].give("frequency_scrambler",100);
players[index].give("gold",20);
players[index].give("bitcoin",20);
players[index].give("suicide_bomb",50);
players[index].give("nuclear_bomb",50);
players[index].give("shield",50);
players[index].give("guided_missile",25);
players[index].give("missile_interceptor",50);
players[index].give("shield_remover",200);
players[index].give("arina_card",50);
players[index].give("wood_pack",100);
players[index].give("fight_inviter",100);
play("packopen",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id,"this pack contains 50 suicide_bomb,100 health_box,10000000 dollar,200 health_healer,50 shield,100 wood_pack,100 frequency_scrambler,20 gold,20 bitcoin,100 arina_card,200 shield_remover,25 guided_missile,50 missile_interceptor,100 fight_inviter, "+string_replace(wname,"_"," ",true)+"!",2);
scd(index);
}
else if(wname=="htp_pack")
{
players[index].give("suicide_bomb",50);
players[index].give("health_box",100);
players[index].give("dollar",5000000);
players[index].give("stun_dart",200);
players[index].give("health_healer",300);
players[index].give("invisibility_shield",50);
players[index].give("shield",20);
players[index].give("timebomb",50);
players[index].give("motion_bomb",50);
players[index].give("wood_pack",30);
players[index].give("frequency_scrambler",100);
players[index].give("gold",10);
players[index].give("bitcoin",25);
players[index].give("empty_pack",100);
play("packopen",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id,"this pack contains 50 suicide_bomb,100 health_box,5000000 dollar,200 stun_dart,300 health_healer,50 invisibility_shield,20 shield,50 timebomb,50 motion_bomb,30 wood_pack,100 frequency_scrambler,10 gold,25 bitcoin,100 empty_pack, "+string_replace(wname,"_"," ",true)+"!",2);
}
else if(wname=="ramadan_pack")
{
players[index].give("shield",300);
players[index].give("xp_box",30);
players[index].give("health_healer",1000);
players[index].give("health_box",1000);
players[index].give("healthy_card",5);
players[index].give("nuclear_bomb",500);
players[index].give("suicide_bomb",500);
players[index].give("stp429",150);
players[index].give("dollar",100000000);
players[index].give("gold",100);
players[index].give("shield_remover",100);
players[index].give("arina_card",500);
players[index].give("the_legendary_sword",1);
players[index].give("iron_shovel",1);
players[index].give("stun_dart",500);
players[index].give("frequency_scrambler",1000);
players[index].give("fule_tank",1000);
players[index].give("chocolate",1000);
players[index].give("chips",1000);
players[index].give("ammo_bazooka",150);
players[index].give("cola",1000);
players[index].give("aircraft",20);
players[index].give("fight_inviter",500);
players[index].give("wood_pack",200);
players[index].give("invisibility_shield",1000);
players[index].give("concussive_grenade",1000);
play("packopen",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id,"this pack contains 300 shields, 30 xp boxes, 1000 health healers, 1000 health boxes, five healthy cards, 500 nuclear_bombs, 500 suicide_bombs, 150 stp429, 100000000 dollar, 100 gold, 100 shield remover, 500 arina_card, 1 the legendary sword, 1 iron shubble, 500 stun_darts, 1000 frequency scramblers, 100 fule tanks, 1000 chocolate, 1000 chips, 150 ammo bazooka, 1000 kolas, 20 aircraft, 500 fight inviters, 200 wood packs, 1000 invisibility shield, 1000 concussive_grenade, ramadan pack!",2);
}
else if(wname=="tk_pack")
{
players[index].give("poison_dagger",20);
players[index].give("item_grabber",2);
players[index].give("dollar",20000);
players[index].give("stun_dart",20);
players[index].give("antibiotic",50);
players[index].give("invisibility_shield",10);
players[index].give("shield",50);
players[index].give("water",10);
players[index].give("timebomb",10);
players[index].give("motion_bomb",10);
players[index].give("wood_pack",15);
players[index].give("beretta_m9_pistol",1);
players[index].give("beretta_nano_pocket_pistol",1);
players[index].give("glock_17_pistol",1);
players[index].give("empty_pack", 1);
play("packopen",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="tk_shelter_pack")
{
players[index].give("wood",500);
players[index].give("security_bomb",5);
players[index].give("mine",20);
players[index].give("toolbox",1);
players[index].give("remote_gun",10);
players[index].give("remote_timebomb",10);
players[index].give("fuel_tank",4);
players[index].give("fire_extinguisher",5);
if(players[index].get_item_count("remote_timebomb_controller")<1) players[index].give("remote_timebomb_controller",1);
players[index].playsound("gift");
send_reliable(players[index].peer_id,"you have opened a "+string_replace(wname,"_"," ",true)+"!",2);
}
else if(wname=="missile_interceptor")
{
if(players[index].intercepting) return;
play("missile_interceptor_fire",players[index].x,players[index].y,players[index].z,players[index].map);
send_plus(players[index].peer_id,"distsound missile_interceptor_firedist "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map,0);
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].interceptortimer.restart();
players[index].intercepting=true;
}
else if(wname=="wood_pack")
{
int rand;
if(players[index].paid==1)
rand=random(25, 50);
else
rand=random(5,15);
players[index].give("wood",rand);
players[index].give("empty_pack", 1);
send_reliable(players[index].peer_id,"the pack contained "+rand+" wood!",2);
play("getwood",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="bazooka_ammo_pack")
{
int rand;
rand=random(10,50);
players[index].give("ammo_bazooka",rand);
players[index].give("empty_pack", 1);
send_reliable(e.peer_id,"the pack contain's  "+rand+" bazooka ammo!",2);
play("packopen",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="metal_pack")
{
int rand=random(20,50);
players[index].give("metal",rand);
players[index].give("empty_pack", 1);
send_reliable(players[index].peer_id,"the pack contained "+rand+" metal!",2);
play("getmedal.ogg",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="ultra_antibiotic_pack")
{
players[index].give("antibiotic",50);
play("getantibiotic",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].give("empty_pack", 1);
}
else if(wname=="remote_gun_controller")
{
takeobj=false;
server_menu m;
int hasrems=0;
for(uint i=0; i<remguns.length(); i++)
{
if(remguns[i].owner==players[index].name)
{
m.add("Remote gun "+remguns[i].id+", ("+remguns[i].map+" at "+remguns[i].x+", "+remguns[i].y+", "+remguns[i].z+")",""+remguns[i].id);
hasrems+=1;
}
}
if(hasrems<=0)
{
players[index].sendpacket("You don't have any remote guns to connect to",0);
return;
}
m.add("cancel","back");
m.intro="Select remotegun to connect to. You have "+hasrems+" remote guns available";
m.initial_packet="remgunidset";
m.send(players[index].peer_id);
}
else if(wname=="remote_gun")
{
if(players[index].remconnecting or players[index].rmtimer.elapsed<6343) return;
if(remgun_at(players[index].x,players[index].y,players[index].z,players[index].map))
{
send_reliable(players[index].peer_id,"speak there is already a remote gun here.",0);
return;
}
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].rmtimer.restart();
players[index].remconnecting=true;
play("remgun_place",players[index].x,players[index].y,players[index].z,players[index].map);
}
else if(wname=="remote_timebomb_controller")
{
takeobj=false;
send_serverbox(players[index].peer_id,2,-1,1,-1,"rtdcode","Enter the code for the remote timebomb or remote timebombs. Note: all bombs with this code will be detenated!");
}
else if(wname=="sat_bomb_remote")
{
takeobj=false;
send_serverbox(players[index].peer_id,2,-1,1,-1,"rtdcode","Enter the code for the sat_bomb_remote or sat_bomb_remote. Note: all bombs with this code will be detenated!");
}
else if(wname=="barricade_bomb"&&players[index].bbombplacing==false)
{
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile=="" and in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"You can't do this in the air!",0);
takeobj=false;
return;
}
for(uint i=0; i<barricade_bombs.length; i++)
{
if(barricade_bombs[i].x==players[index].x&&barricade_bombs[i].y==players[index].y&&barricade_bombs[i].z==players[index].z&&barricade_bombs[i].map==players[index].map)
{
send_reliable(players[index].peer_id,"there is already a barricade bomb here. No point in wasting such powerful things on only one square",0);
takeobj=false;
return;
}
}
if(in_vehicle(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"Not in a "+vs[in_vehicle(players[index].name)].type+"!",2);
return;
}
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("barricade_bombplace");
players[index].bbombtimer.restart();
players[index].bbombplacing=true;
}
else if(wname=="bullet_bomb"&&players[index].bulletbombplacing==false)
{
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile=="" and in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"You can't do this in the air!",0);
takeobj=false;
return;
}
for(uint i=0; i<bullet_bombs.length; i++)
{
if(bullet_bombs[i].x==players[index].x&&bullet_bombs[i].y==players[index].y&&bullet_bombs[i].z==players[index].z&&bullet_bombs[i].map==players[index].map)
{
send_reliable(players[index].peer_id,"there is already a bullet bomb here. No point in wasting such powerful things on only one square",0);
takeobj=false;
return;
}
}
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("bullet_bombplace");
players[index].bullettimer.restart();
players[index].bulletbombplacing=true;
}
else if(wname=="small_projectile")
{
if(players[index].invinsible==true)
return;
if(players[index].projectiletimer.elapsed<3000){
send_reliable(players[index].peer_id,"you can't use small projectile",0);
return;
}
takeobj=true;
spawn_projectile(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
players[index].projectiletimer.restart();
}
else if(wname=="tasing_small_projectile")
{
if(players[index].invinsible==true)
return;
if(players[index].projectiletimer.elapsed<4000){
send_reliable(players[index].peer_id,"you can't use tasing small projectile",0);
return;
}
takeobj=true;
spawn_tprojectile(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
players[index].projectiletimer.restart();
}
else if(wname=="poisoned_small_projectile")
{
if(players[index].projectiletimer.elapsed<6000){
send_reliable(players[index].peer_id,"you can't use poisoned small projectile",0);
return;
}
takeobj=true;
spawn_pprojectile(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
players[index].projectiletimer.restart();
}
else if(wname=="censor_bomb"&&players[index].sbombplacing==false)
{
if(players[index].invinsible==true)
return;
string tile=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(tile=="" and in_shelter(players[index].name)<0)
{
send_reliable(players[index].peer_id,"You can't do this in the air!",0);
takeobj=false;
return;
}
for(uint i=0; i<security_bombs.length; i++)
{
if(security_bombs[i].x==players[index].x&&security_bombs[i].y==players[index].y&&security_bombs[i].z==players[index].z&&security_bombs[i].map==players[index].map)
{
send_reliable(players[index].peer_id,"there is already a security bomb here. No point in wasting such powerful things on only one square",0);
takeobj=false;
return;
}
}
send_reliable(players[index].peer_id,"stopmoving",0);
players[index].playsound("security_bombplace");
players[index].sbombtimer.restart();
players[index].sbombplacing=true;
}
else if(wname=="bullet_bomb_locator")
{
takeobj=false;
send_reliable(players[index].peer_id,"searching...",0);
string list;
players[index].playsound("bullet_bomblocate");
for(uint i=0; i<bullet_bombs.length(); i++)
{
if(bullet_bombs[i].owner==players[index].name)
{
list+=bullet_bombs[i].owner+"'s bullet_bomb: "+bullet_bombs[i].x+", "+bullet_bombs[i].y+", "+bullet_bombs[i].z+" on "+bullet_bombs[i].map+".\r\n";
}
}
if(list=="")
list="none";
send_reliable(players[index].peer_id,"Your bullet bombs: "+list,2);
}
else if(wname=="dead_wolf")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("skin");
if(players[index].skin<23)
{
players[index].skin++;
}
else if(players[index].skin==23)
{
players[index].skin=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak skinned!",0);
players[index].give("dead_wolf", -1);
players[index].give("skinned_wolf", 1);
players[index].give("wolf_skin", 1);
return;
}
}
}
else if(wname=="skinned_wolf")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("knifehit");
players[index].playsound("blood_"+random(1,10));
if(players[index].cut<26)
{
players[index].cut++;
}
else if(players[index].cut==26)
{
players[index].cut=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cutted!",0);
players[index].give("skinned_wolf", -1);
players[index].give("cutted_wolf_meat", 1);
return;
}
}
}
else if(wname=="cutted_wolf_meat")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=900)
{
players[index].waitingtimer.restart();
if(starter_exist_on(players[index].x,players[index].y,players[index].z,players[index].map))
{
players[index].playsound("fry"+random(1,3));
if(players[index].firecook<23)
{
players[index].firecook++;
}
else if(players[index].firecook==23)
{
players[index].firecook=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cooked!",0);
players[index].give("cutted_wolf_meat", -1);
players[index].give("cooked_wolf_meat", 1);
return;
}
}
else send_reliable(players[index].peer_id, "first, start a fire",0);
}
}
else if(wname=="cooked_wolf_meat")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<10000) return;
else if(players[index].eattimer.elapsed>=8907)
{
players[index].eattimer.restart();
players[index].playsound("eat");
if(players[index].waitingtimer.elapsed>=9000)
{
players[index].waitingtimer.restart();
players[index].health+=50000;
takeobj=true;
players[index].give("cooked_wolf_meat", -1);
return;
}
}
}
else if(wname=="dead_goat")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("skin");
if(players[index].skin<10)
{
players[index].skin++;
}
else if(players[index].skin==10)
{
players[index].skin=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak skinned!",0);
players[index].give("dead_goat", -1);
players[index].give("skinned_goat", 1);
players[index].give("goat_skin", 1);
return;
}
}
}
else if(wname=="skinned_goat")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("knifehit");
players[index].playsound("blood_"+random(1,10));
if(players[index].cut<20)
{
players[index].cut++;
}
else if(players[index].cut==20)
{
players[index].cut=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cutted!",0);
players[index].give("skinned_goat", -1);
players[index].give("cutted_goat_meat", 1);
return;
}
}
}
else if(wname=="cutted_goat_meat")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=900)
{
players[index].waitingtimer.restart();
if(starter_exist_on(players[index].x,players[index].y,players[index].z,players[index].map))
{
players[index].playsound("fry"+random(1,3));
if(players[index].firecook<15)
{
players[index].firecook++;
}
else if(players[index].firecook==15)
{
players[index].firecook=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cooked!",0);
players[index].give("cutted_goat_meat", -1);
players[index].give("cooked_goat_meat", 1);
return;
}
}
else send_reliable(players[index].peer_id, "first, start a fire",0);
}
}
else if(wname=="cooked_goat_meat")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<10000) return;
else if(players[index].eattimer.elapsed>=8907)
{
players[index].eattimer.restart();
players[index].playsound("eat");
if(players[index].waitingtimer.elapsed>=9000)
{
players[index].waitingtimer.restart();
players[index].health+=12000;
takeobj=true;
players[index].give("cooked_goat_meat", -1);
return;
}
}
}
else if(wname=="dead_rabit")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("skin");
if(players[index].skin<8)
{
players[index].skin++;
}
else if(players[index].skin==8)
{
players[index].skin=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak skinned!",0);
players[index].give("dead_rabit", -1);
players[index].give("skinned_rabit", 1);
players[index].give("rabit_skin", 1);
return;
}
}
}
else if(wname=="skinned_rabit")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("knifehit");
players[index].playsound("blood_"+random(1,10));
if(players[index].cut<15)
{
players[index].cut++;
}
else if(players[index].cut==15)
{
players[index].cut=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cutted!",0);
players[index].give("skinned_rabit", -1);
players[index].give("cutted_rabit_meat", 1);
return;
}
}
}
else if(wname=="cutted_rabit_meat")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=900)
{
players[index].waitingtimer.restart();
if(starter_exist_on(players[index].x,players[index].y,players[index].z,players[index].map))
{
players[index].playsound("fry"+random(1,3));
if(players[index].firecook<15)
{
players[index].firecook++;
}
else if(players[index].firecook==15)
{
players[index].firecook=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cooked!",0);
players[index].give("cutted_rabit_meat", -1);
players[index].give("cooked_rabit_meat", 1);
return;
}
}
else send_reliable(players[index].peer_id, "first, start a fire",0);
}
}
else if(wname=="cooked_rabit_meat")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<10000) return;
else if(players[index].eattimer.elapsed>=8907)
{
players[index].eattimer.restart();
players[index].playsound("eat");
if(players[index].waitingtimer.elapsed>=9000)
{
players[index].waitingtimer.restart();
players[index].health+=10000;
takeobj=true;
players[index].give("cooked_rabit_meat", -1);
return;
}
}
}
else if(wname=="dead_bear")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("skin");
if(players[index].skin<40)
{
players[index].skin++;
}
else if(players[index].skin==40)
{
players[index].skin=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak skinned!",0);
players[index].give("dead_bear", -1);
players[index].give("skinned_bear", 1);
players[index].give("bear_skin", 1);
return;
}
}
}
else if(wname=="skinned_bear")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("knifehit");
players[index].playsound("blood_"+random(1,10));
if(players[index].cut<45)
{
players[index].cut++;
}
else if(players[index].cut==45)
{
players[index].cut=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cutted!",0);
players[index].give("skinned_bear", -1);
players[index].give("cutted_bear_meat", 1);
return;
}
}
}
else if(wname=="cutted_bear_meat")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=900)
{
players[index].waitingtimer.restart();
if(starter_exist_on(players[index].x,players[index].y,players[index].z,players[index].map))
{
players[index].playsound("fry"+random(1,3));
if(players[index].firecook<55)
{
players[index].firecook++;
}
else if(players[index].firecook==55)
{
players[index].firecook=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cooked!",0);
players[index].give("cutted_bear_meat", -1);
players[index].give("cooked_bear_meat", 1);
return;
}
}
else send_reliable(players[index].peer_id, "first, start a fire",0);
}
}
else if(wname=="cooked_bear_meat")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<10000) return;
else if(players[index].eattimer.elapsed>=8907)
{
players[index].eattimer.restart();
players[index].playsound("eat");
if(players[index].waitingtimer.elapsed>=9000)
{
players[index].waitingtimer.restart();
players[index].health+=40000;
takeobj=true;
players[index].give("cooked_bear_meat", -1);
return;
}
}
}
else if(wname=="dead_horse")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("skin");
if(players[index].skin<18)
{
players[index].skin++;
}
else if(players[index].skin==18)
{
players[index].skin=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak skinned!",0);
players[index].give("dead_horse", -1);
players[index].give("skinned_horse", 1);
players[index].give("horse_skin", 1);
return;
}
}
}
else if(wname=="skinned_horse")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("knifehit");
players[index].playsound("blood_"+random(1,10));
if(players[index].cut<25)
{
players[index].cut++;
}
else if(players[index].cut==25)
{
players[index].cut=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cutted!",0);
players[index].give("skinned_horse", -1);
players[index].give("cutted_horse_meat", 1);
return;
}
}
}
else if(wname=="cutted_horse_meat")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=900)
{
players[index].waitingtimer.restart();
if(starter_exist_on(players[index].x,players[index].y,players[index].z,players[index].map))
{
players[index].playsound("fry"+random(1,3));
if(players[index].firecook<30)
{
players[index].firecook++;
}
else if(players[index].firecook==30)
{
players[index].firecook=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cooked!",0);
players[index].give("cutted_horse_meat", -1);
players[index].give("cooked_horse_meat", 1);
return;
}
}
else send_reliable(players[index].peer_id, "first, start a fire",0);
}
}
else if(wname=="cooked_horse_meat")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<10000) return;
else if(players[index].eattimer.elapsed>=8907)
{
players[index].eattimer.restart();
players[index].playsound("eat");
if(players[index].waitingtimer.elapsed>=9000)
{
players[index].waitingtimer.restart();
players[index].health+=9000;
takeobj=true;
players[index].give("cooked_horse_meat", -1);
return;
}
}
}
else if(wname=="dead_boar")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("skin");
if(players[index].skin<35)
{
players[index].skin++;
}
else if(players[index].skin==35)
{
players[index].skin=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak skinned!",0);
players[index].give("dead_boar", -1);
players[index].give("skinned_boar", 1);
players[index].give("boar_skin", 1);
return;
}
}
}
else if(wname=="skinned_boar")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("knifehit");
players[index].playsound("blood_"+random(1,10));
if(players[index].cut<30)
{
players[index].cut++;
}
else if(players[index].cut==30)
{
players[index].cut=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cutted!",0);
players[index].give("skinned_boar", -1);
players[index].give("cutted_boar_meat", 1);
return;
}
}
}
else if(wname=="cutted_boar_meat")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=900)
{
players[index].waitingtimer.restart();
if(starter_exist_on(players[index].x,players[index].y,players[index].z,players[index].map))
{
players[index].playsound("fry"+random(1,3));
if(players[index].firecook<45)
{
players[index].firecook++;
}
else if(players[index].firecook==45)
{
players[index].firecook=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cooked!",0);
players[index].give("cutted_boar_meat", -1);
players[index].give("cooked_boar_meat", 1);
return;
}
}
else send_reliable(players[index].peer_id, "first, start a fire",0);
}
}
else if(wname=="cooked_boar_meat")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<60000) return;
else if(players[index].eattimer.elapsed>=8907)
{
players[index].eattimer.restart();
players[index].playsound("eat");
if(players[index].waitingtimer.elapsed>=9000)
{
players[index].waitingtimer.restart();
players[index].health+=76000;
takeobj=true;
players[index].give("cooked_boar_meat", -1);
return;
}
}
}
else if(wname=="dead_lion")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("skin");
if(players[index].skin<70)
{
players[index].skin++;
}
else if(players[index].skin==70)
{
players[index].skin=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak skinned!",0);
players[index].give("dead_lion", -1);
players[index].give("skinned_lion", 1);
players[index].give("lion_skin", 1);
return;
}
}
}
else if(wname=="skinned_lion")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("knifehit");
players[index].playsound("blood_"+random(1,10));
if(players[index].cut<50)
{
players[index].cut++;
}
else if(players[index].cut==50)
{
players[index].cut=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cutted!",0);
players[index].give("skinned_lion", -1);
players[index].give("cutted_lion_meat", 1);
return;
}
}
}
else if(wname=="cutted_lion_meat")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=900)
{
players[index].waitingtimer.restart();
if(starter_exist_on(players[index].x,players[index].y,players[index].z,players[index].map))
{
players[index].playsound("fry"+random(1,3));
if(players[index].firecook<50)
{
players[index].firecook++;
}
else if(players[index].firecook==50)
{
players[index].firecook=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cooked!",0);
players[index].give("cutted_lion_meat", -1);
players[index].give("cooked_lion_meat", 1);
return;
}
}
else send_reliable(players[index].peer_id, "first, start a fire",0);
}
}
else if(wname=="cooked_lion_meat")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<10000) return;
else if(players[index].eattimer.elapsed>=8907)
{
players[index].eattimer.restart();
players[index].playsound("eat");
if(players[index].waitingtimer.elapsed>=9000)
{
players[index].waitingtimer.restart();
players[index].health+=100000;
takeobj=true;
players[index].give("cooked_lion_meat", -1);
return;
}
}
}
else if(wname=="dead_gorilla")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("skin");
if(players[index].skin<20)
{
players[index].skin++;
}
else if(players[index].skin==20)
{
players[index].skin=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak skinned!",0);
players[index].give("dead_gorilla", -1);
players[index].give("skinned_gorilla", 1);
players[index].give("gorilla_skin", 1);
return;
}
}
}
else if(wname=="skinned_gorilla")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("knifehit");
players[index].playsound("blood_"+random(1,10));
if(players[index].cut<35)
{
players[index].cut++;
}
else if(players[index].cut==35)
{
players[index].cut=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cutted!",0);
players[index].give("skinned_gorilla", -1);
players[index].give("cutted_gorilla_meat", 2);
return;
}
}
}
else if(wname=="cutted_gorilla_meat")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=900)
{
players[index].waitingtimer.restart();
if(starter_exist_on(players[index].x,players[index].y,players[index].z,players[index].map))
{
players[index].playsound("fry"+random(1,3));
if(players[index].firecook<30)
{
players[index].firecook++;
}
else if(players[index].firecook==30)
{
players[index].firecook=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cooked!",0);
players[index].give("cutted_gorilla_meat", -1);
players[index].give("cooked_gorilla_meat", 1);
return;
}
}
else send_reliable(players[index].peer_id, "first, start a fire",0);
}
}
else if(wname=="cooked_gorilla_meat")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<10000) return;
else if(players[index].eattimer.elapsed>=8907)
{
players[index].eattimer.restart();
players[index].playsound("eat");
if(players[index].waitingtimer.elapsed>=9000)
{
players[index].waitingtimer.restart();
players[index].health+=75000;
takeobj=true;
players[index].give("cooked_gorilla_meat", -1);
return;
}
}
}
else if(wname=="dead_leopard")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("skin");
if(players[index].skin<25)
{
players[index].skin++;
}
else if(players[index].skin==25)
{
players[index].skin=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak skinned!",0);
players[index].give("dead_leopard", -1);
players[index].give("skinned_leopard", 1);
players[index].give("leopard_skin", 1);
return;
}
}
}
else if(wname=="skinned_leopard")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].playsound("knifehit");
players[index].playsound("blood_"+random(1,10));
if(players[index].cut<40)
{
players[index].cut++;
}
else if(players[index].cut==40)
{
players[index].cut=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cutted!",0);
players[index].give("skinned_leopard", -1);
players[index].give("cutted_leopard_meat", 1);
return;
}
}
}
else if(wname=="cutted_leopard_meat")
{
takeobj=false;
if(players[index].waitingtimer.elapsed>=900)
{
players[index].waitingtimer.restart();
if(starter_exist_on(players[index].x,players[index].y,players[index].z,players[index].map))
{
players[index].playsound("fry"+random(1,3));
if(players[index].firecook<45)
{
players[index].firecook++;
}
else if(players[index].firecook==45)
{
players[index].firecook=0;
takeobj=true;
players[index].playsound("bareland");
send_reliable(players[index].peer_id,"speak cooked!",0);
players[index].give("cutted_leopard_meat", -1);
players[index].give("cooked_leopard_meat", 1);
return;
}
}
else send_reliable(players[index].peer_id, "first, start a fire",0);
}
}
else if(wname=="cooked_leopard_meat")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<10000) return;
else if(players[index].eattimer.elapsed>=8907)
{
players[index].eattimer.restart();
players[index].playsound("eat");
if(players[index].waitingtimer.elapsed>=9000)
{
players[index].waitingtimer.restart();
players[index].health+=50000;
takeobj=true;
players[index].give("cooked_leopard_meat", -1);
return;
}
}
}
else if(wname=="corpse_of_soldier")
{
takeobj=false;
players[index].playsound("dollar");
players[index].give("dollar",50);
takeobj=true;
players[index].give("corpse_of_soldier",-1);
return;
}
else if(wname=="health_healer")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<1000) return;
else if(players[index].eattimer.elapsed>=1412)
{
players[index].eattimer.restart();
players[index].playsound("health_healer");
if(players[index].waitingtimer.elapsed>=1412)
{
players[index].waitingtimer.restart();
players[index].health+=500000;
takeobj=true;
players[index].give("health_healer",-1);
return;
}
}
}
else if(wname=="golden_apple")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<60000) return;
else if(players[index].eattimer.elapsed>=4274)
{
players[index].eattimer.restart();
players[index].playsound("eat_apple");
if(players[index].waitingtimer.elapsed>=4274)
{
players[index].waitingtimer.restart();
players[index].health+=500000;
takeobj=true;
players[index].give("golden_apple",-1);
return;
}
}
}
else if(wname=="apple")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<60000) return;
else if(players[index].eattimer.elapsed>=4274)
{
players[index].eattimer.restart();
players[index].playsound("eat_apple");
if(players[index].waitingtimer.elapsed>=4274)
{
players[index].waitingtimer.restart();
players[index].health+=12500;
takeobj=true;
players[index].give("apple",-1);
return;
}
}
}
else if(wname=="kiwi")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<60000) return;
else if(eattimer.elapsed>=3904)
{
eattimer.restart();
players[index].playsound("eat_kiwi");
if(players[index].waitingtimer.elapsed>=3904)
{
players[index].waitingtimer.restart();
players[index].health+=15200;
if(players[index].waitingtimer.elapsed>=660)
{
players[index].health-=300;
takeobj=true;
players[index].give("kiwi",-1);
return;
}
}
}
}
else if(wname=="raisin")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<60000) return;
else if(eattimer.elapsed>=1400)
{
eattimer.restart();
players[index].playsound("eat_raisin");
if(players[index].waitingtimer.elapsed>=1374)
{
players[index].waitingtimer.restart();
players[index].health+=4700;
takeobj=true;
players[index].give("raisin",-1);
return;
}
}
}
else if(wname=="chocolate")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<60000) return;
else if(eattimer.elapsed>=3500)
{
eattimer.restart();
players[index].playsound("eat_chocolate");
if(players[index].waitingtimer.elapsed>=3238)
{
players[index].waitingtimer.restart();
players[index].health+=15500;
takeobj=true;
players[index].give("chocolate",-1);
return;
}
}
}
else if(wname=="apple_juice")
{
takeobj=false;
players[index].playsound("openjuice"+random(1,4));
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
takeobj=true;
players[index].give("opened_apple_juice",1);
players[index].give("can",1);
players[index].give("apple_juice",-1);
return;
}
}
else if(wname=="milk")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<60000) return;
else if(eattimer.elapsed>=2300)
{
eattimer.restart();
players[index].playsound("drink_milk");
if(players[index].waitingtimer.elapsed>=1350)
{
players[index].waitingtimer.restart();
players[index].health+=11800;
takeobj=true;
players[index].give("milk",-1);
return;
}
}
}
else if(wname=="cola")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<60000) return;
else if(eattimer.elapsed>=10605)
{
eattimer.restart();
players[index].playsound("drink_cola");
if(players[index].waitingtimer.elapsed>=10604)
{
players[index].waitingtimer.restart();
players[index].health+=13500;
takeobj=true;
players[index].health-=350;
players[index].give("cola",-1);
return;
}
}
}
else if(wname=="soda")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(eattimer.elapsed>=3214)
{
eattimer.restart();
players[index].playsound("drink_cola");
if(players[index].waitingtimer.elapsed>=2313)
{
players[index].waitingtimer.restart();
players[index].health+=13500;
takeobj=true;
players[index].give("soda",-1);
return;
}
}
}
else if(wname=="raisin_pack")
{
takeobj=false;
play("openpack",players[index].x,players[index].y,players[index].z,players[index].map);
if(players[index].waitingtimer.elapsed>=1000)
{
players[index].waitingtimer.restart();
players[index].give("raisin",20);
takeobj=true;
players[index].give("raisin_pack",-1);
return;
}
}
else if(wname=="opened_apple_juice")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<60000) return;
else if(eattimer.elapsed>=6500)
{
eattimer.restart();
players[index].playsound("drink_apple_juice");
if(players[index].waitingtimer.elapsed>=6366)
{
players[index].waitingtimer.restart();
players[index].health+=14000;
takeobj=true;
players[index].give("opened_apple_juice",-1);
players[index].give("empty_apple_juice",1);
return;
}
}
}
else if(wname=="spead_drink")
{
takeobj=false;
if(players[index].statchangetimer.elapsed<60000) return;
else if(eattimer.elapsed>=6500)
{
eattimer.restart();
players[index].playsound("eatjuce_box");
if(players[index].waitingtimer.elapsed>=6366)
{
players[index].waitingtimer.restart();
takeobj=true;
players[index].give("spead_drink",-1);
return;
}
}
}
else if(wname=="coffee")
{
takeobj=false;
if(players[index].health>=10000000)
{
send_reliable(players[index].peer_id,"you are at max health",0);
}
else if(players[index].statchangetimer.elapsed<60000) return;
else if(eattimer.elapsed>=6500)
{
eattimer.restart();
players[index].playsound("eatjuce_box");
if(players[index].waitingtimer.elapsed>=6366)
{
players[index].waitingtimer.restart();
players[index].health+=14000;
takeobj=true;
players[index].give("coffee",-1);
return;
}
}
}
else if(wname=="ultrabomb_locator")
{
takeobj=false;
send_reliable(players[index].peer_id,"searching...",0);
string list;
players[index].playsound("ultrabomblocator");
for(uint i=0; i<ultrabombs.length(); i++)
{
if(ultrabombs[i].owner==players[index].name)
{
list+=ultrabombs[i].owner+"'s ultrabomb: "+ultrabombs[i].x+", "+ultrabombs[i].y+", "+ultrabombs[i].z+" on "+ultrabombs[i].map+".\r\n";
}
}
if(list=="")
list="none";
send_reliable(players[index].peer_id,"Your ultrabombs: "+list,2);
}
else if(wname=="timebomb")
{
if(players[index].mbombtimer.elapsed<500)
{
takeobj=false;
return;
}
players[index].mbombtimer.restart();
placetimebomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name,5000);
}
if(takeobj==true)
players[index].give(wname,-1);
//send_reliable(players[index].peer_id,"invstring "+players[index].get_inv(false),0);
}
players[index].using=false;
}
}
else if(parsed[0]=="insertamount" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id, "canceled", 0);
return;
}
int s=in_shelter(players[index].name);
int v=get_vending_index(players[index].x, players[index].y, players[index].z, players[index].map);
double amount=stn(parsed[1]);
if(players[index].get_item_count("dollar")<amount)
{
send_reliable(players[index].peer_id, "not enough money", 2);
return;
}
if(amount<=0)
{
send_reliable(e.peer_id,"Sorry, can't enter neggitive amounts!",2);
return;
}
if(v<0 and s<0) return;
if(s>-1)
{
shelters[s].compplay("ultrabombcoinadd");
shelters[s].dollars+=amount;
players[index].give("dollar", -amount);
}
else if(v>-1)
{
vending_machines[v].dollars+=amount;
players[index].give("dollar", -amount);
}
}
}
else if(parsed[0]=="purchase" and parsed.length()>2)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
purchase(parsed[1],stn(parsed[2]),index);
}
}
else if(parsed[0]=="buysomething" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="back")
{
return;
}
else
{
send_serverbox(players[index].peer_id, 2, 1, 0, -1, "purchase "+parsed[1], "type the amount you wish to buy");
}
}
}
else if(parsed[0]=="revive")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].is_dead=true)
{
players[index].vo("revive");
respawn(index);
}
}
}
else if(parsed[0]=="motd")
{
send_reliable(e.peer_id,"Message of the Day: "+motd(),2);
}
else if(parsed[0]=="compinfo" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string comptext=players[index].name+" ("+string_replace(get_event_message(), "compinfo ", "", false)+") from IP "+n.get_peer_address(e.peer_id)+", computer ID "+players[index].compid+"\r\n";
file f;
f.open("chars/"+players[index].name+"/info.usr","wb");
f.write("last seen: "+get_date(true,false)+" at "+get_time(true,false)+"\r\ncomp info:\r\n"+comptext+"\r\nlocation:\r\n");
f.close();
f.open("compchars.log", "rb");
string orgtext=f.read();
f.close();
if(string_contains(orgtext, comptext, 1)<0)
{
f.open("compchars.log", "ab");
f.write(comptext);
f.close();
}
players[index].ctext=comptext;
}
}
else if(parsed[0]=="ping")
{
send_reliable(e.peer_id,"pong",0);
}
else if(parsed[0]=="testmenu")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
send_reliable(players[index].peer_id,"Menus seem to work just fine. You clicked "+string_replace(get_event_message(),"testmenu ","",false)+". Correct?",0);
}
}
else if(parsed[0]=="build_shelter")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
//if(currentShelterPromptMap != players[index].map) {
if(can_spawn_item_at(players[index].x,players[index].y,players[index].z,players[index].map,"wood")==false) {
send_reliable(0,players[index].nickname+" is crying because he cannot use shelter trick.",2);
return;
}
string name=string_trim_left(get_event_message(),14);
name=string_replace(name,"[SPCE]"," ",true);
name=string_replace(name," ","_",true);
if(name[0]=="_") name=string_trim_left(name,1);
if(string_contains(name,".",1)>-1)
{
send_reliable(players[index].peer_id,"Invalid shelter name!",2);
return;
}
if(name=="" or name=="main" or name=="store" or name=="tw_main" or name=="main_streat" or name=="admin_room" or name=="zone_of_horrors" or name=="Hell_to_paradise" or name=="second_hell" or name=="last_hell" or name=="hell_challenge" or name=="golden_world" or name=="road_to_golden_world" or name=="main2" or name=="tw_hospital" or name=="icepath" or name=="suicide_dance" or name=="sword_fighting_arina" or name=="fightting_event" or name=="malik-ali" or name=="MalikAli" or name=="JimmyDub" or name=="tw_house" or name=="Relaxing_room" or name=="tw" or name=="TheWar" or name=="fuck" or name=="rofl" or name=="balls" or name=="cocks" or name=="time_world" or name=="the_romen" or name=="arena" or name=="jail" or name=="juarasjuasjuasjuasjuas" or name=="uncosp" or name=="jail2" or name=="legendary_challenge" or name=="juarasjuas" or name=="legends" or name=="Samantha")
{
send_reliable(players[index].peer_id, "you can't create a shelter with this name!", 2);
return;
}
if(get_event_message().length()>100)
{
send_reliable(players[index].peer_id,"this shelter name is too long!",0);
return;
}
if(string_contains(name,"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"speak Canceled",0);
return;
}
if(players[index].map=="store")
{
send_reliable(players[index].peer_id,"you can't just build a shelter inside a moving store!",2);
return;
}
if(is_travelpoint(players[index].x,players[index].y,players[index].z,players[index].map))
{
send_reliable(players[index].peer_id,"Building shelters on travelpoints just doesn't work like that!",2);
return;
}
if(in_shelter(players[index].name)>-1)
{
send_reliable(players[index].peer_id,"I don't think building another shelter inside a shelter's such a good idea...",2);
return;
}
if(get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map)=="")
{
send_reliable(players[index].peer_id,"You can't exactly build something in mid air, can you?",2);
return;
}
if(string_left(get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map),4)=="wall")
{
send_reliable(players[index].peer_id,"you may not build a shelter on a wall",2);
return;
}
if(is_staircase(players[index].x,players[index].y,players[index].z,players[index].map))
{
send_reliable(players[index].peer_id,"you may not build a shelter on a staircase.",2);
return;
}
for(uint shi=0; shi<shelters.length; shi++)
{
if(shelters[shi].x==players[index].x&&shelters[shi].y==players[index].y&&shelters[shi].z==players[index].z&&shelters[shi].map==players[index].map)
{
send_reliable(players[index].peer_id,"there is already a shelter here.",2);
return;
}
}
if(players[index].x==storex and players[index].y==storey and players[index].z==storez and players[index].map=="main")
{
send_reliable(players[index].peer_id,"You can not build a shelter on top of the store!",2);
return;
}
if(shelter_exists(name))
{
send_reliable(players[index].peer_id,"error! A shelter with this name already exists",2);
return;
}
if(!filterchar(name,true,"'"))
{
players[index].shelter_building=true;
players[index].buildtimer.restart();
players[index].give("wood",-500);
play("shelter_build",players[index].x,players[index].y,players[index].z,players[index].map);
players[index].sheltername=name;
send_reliable(players[index].peer_id,"stopmoving",0);
}
else
{
send_reliable(players[index].peer_id,"Error! Invalid name!",0);
return;
}
}
}
else if(parsed[0]=="remdisconnect")
{
int index=get_player_index_from(e.peer_id);
if(index>-1) players[index].cremguns=false;
}
else if(parsed[0]=="remconnect")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(has_remgun(players[index].name)==true)
{
send_reliable(players[index].peer_id,"play_s remgun_connect.ogg",0);
send_reliable(e.peer_id,"remcontrol",0);
players[index].cremguns=true;
}
else
{
send_reliable(e.peer_id,"No remote guns connected!",2);
}
}
}
else if(parsed[0]=="firerem")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
for(uint r=0; r<remguns.length(); r++)
{
if(remguns[r].owner==players[index].name)
remguns[r].can_fire=true;
}
}
}
else if(parsed[0]=="destrem")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
for(uint r=0; r<remguns.length(); r++)
{
if(remguns[r].owner==players[index].name)
{
remguns[r].health=-1;
remguns[r].hitby="internal:rg:destruct";
}
}
}
}
else if(parsed[0]=="rbomb" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"canceled",0);
return;
}
players[index].rbombs+=1;
place_remote_timebomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name,stn(parsed[1]));
send_reliable(players[index].peer_id,"Bomb placed at "+players[index].x+" "+players[index].y+" "+players[index].z+" with code "+parsed[1],2);
}
}
else if(parsed[0]=="rtdcode" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Canceled!",0);
return;
}
int code=stn(parsed[1]);
int exploded=0;
send_reliable(players[index].peer_id,"Searching...",0);
play("remote_timebombcode",players[index].x,players[index].y,players[index].z,players[index].map);
for(uint i=0; i<remote_timebombs.length; i++)
{
if(remote_timebombs[i].code==code)
{
exploded++;
remote_timebombs[i].bombtimer.restart();
remote_timebombs[i].d=true;
play("remote_timebombcharge",remote_timebombs[i].x,remote_timebombs[i].y,remote_timebombs[i].z,remote_timebombs[i].map);
}
}
send_reliable(players[index].peer_id,exploded+" detenated!",0);
}
}
else if(parsed[0]=="satcode" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Canceled!",0);
return;
}
int code=stn(parsed[1]);
int exploded=0;
send_reliable(players[index].peer_id,"Searching...",0);
play("sat_bombcode",players[index].x,players[index].y,players[index].z,players[index].map);
for(uint i=0; i<sat_bombs.length; i++)
{
if(sat_bombs[i].code==code)
{
exploded++;
sat_bombs[i].bombtimer.restart();
sat_bombs[i].d=true;
play("sat_bombcharge",sat_bombs[i].x,sat_bombs[i].y,sat_bombs[i].z,sat_bombs[i].map);
}
}
send_reliable(players[index].peer_id,exploded+" detenated!",0);
}
}
else if(parsed[0]=="sheltercheck")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(in_shelter(players[index].name)>-1)
{
int shind=in_shelter(players[index].name);
send_reliable(players[index].peer_id,"entershelter "+shelters[shind].x+" "+shelters[shind].y+" "+shelters[shind].z+" "+shelters[shind].map,0);
}
}
}
else if(parsed[0]=="teamcheck")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string charfolder="chars/"+players[index].name;
if(file_exists(charfolder+"/team.usr"))
{
file tf;
tf.open(charfolder+"/team.usr","rb");
string t=tf.read();
tf.close();
if(team_exists(t))
{
int tx=get_team_index(t);
teams[tx].add_member(players[index].name,false);
send_reliable(players[index].peer_id,"welcome back to the "+t+" team!",2);
if(players[index].hidden==0) send_reliable(0, players[index].name+" is part of the "+t+" team", 2);
}
}
}
}
else if(parsed[0]=="teleport")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string what=parsed[1];
if(what=="main")
{
players[index].teleporttimer.restart();
players[index].playsound("teleporter_field");
players[index].main=true;
}
if(what=="tw_main")
{
players[index].teleporttimer.restart();
players[index].tw_main=true;
players[index].playsound("teleporter_field");
}
else if(what=="hell_challenge")
{
players[index].teleporttimer.restart();
players[index].hell_challenge=true;
players[index].playsound("teleporter_field");
}
else if(what=="suicide_dance")
{
players[index].teleporttimer.restart();
players[index].suicide_dance=true;
players[index].playsound("teleporter_field");
}
else if(what=="time_world")
{
players[index].teleporttimer.restart();
players[index].playsound("teleporter_field");
players[index].time_world=true;
}
else if(what=="golden_world")
{
players[index].teleporttimer.restart();
players[index].playsound("teleporter_field");
players[index].golden_world=true;
}
}
}
else if(parsed[0]=="clothing")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
string c;
string c2;
string c3;
if(players[index].head=="" and players[index].ears=="" and players[index].interior=="" and players[index].upper_outer=="" and players[index].hands=="" and players[index].wrist=="" and players[index].finger=="" and players[index].arms=="" and players[index].legs=="" and players[index].feet=="")
{
c="you are naked";
}
else
{
c="you are wearing: "+players[index].head+", "+players[index].ears+", "+players[index].interior+", "+players[index].upper_outer+", "+players[index].hands+", "+players[index].wrist+", "+players[index].finger+", "+players[index].arms+", "+players[index].legs+", "+players[index].feet;
}
for (uint i=0; i<players.length(); i++)
{
if (players[i].x<players[index].x+20 and players[i].x>players[index].x-20 and players[i].y<players[index].y+20 and players[i].y>players[index].y-20 and get_1d_distance(players[index].z,players[i].z)<=20 and players[i].map==players[index].map and players[i].name!=players[index].name and players[i].invisible==false)
{
if(players[i].head=="" and players[i].ears=="" and players[i].interior=="" and players[i].upper_outer=="" and players[i].hands=="" and players[i].wrist=="" and players[i].finger=="" and players[i].arms=="" and players[i].legs=="" and players[i].feet=="")
{
c2=""+players[i].name+" is naked";
}
else if(players[i].gender=="female")
{
c2=""+players[i].name+", she is wearing: "+players[i].head+", "+players[i].ears+", "+players[i].interior+", "+players[i].upper_outer+", "+players[i].hands+", "+players[i].wrist+", "+players[i].finger+", "+players[i].arms+", "+players[i].legs+", "+players[i].feet;
}
else
{
c2=""+players[i].name+", he is wearing: "+players[i].head+", "+players[i].ears+", "+players[i].interior+", "+players[i].upper_outer+", "+players[i].hands+", "+players[i].wrist+", "+players[i].finger+", "+players[i].arms+", "+players[i].legs+", "+players[i].feet;
}
}
}
c3=""+c+", "+c2+" ";
send_reliable(players[index].peer_id,c3,2);
}
}
else if(parsed[0]=="admincheck")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string n=players[index].name;
string charfolder="chars/"+n;
if(file_exists(charfolder+"/master.usr") and players[index].dev==false)
{
send_reliable(e.peer_id,"isadmin",0);
players[index].master=true;
send_reliable(0,"play_s notify_applause.ogg",0);
send_reliable(0,players[index].name+" is a master of The War",2);
if(players[index].adminflag==1) players[index].title="master";
}
if(file_exists(charfolder+"/dev.usr") and players[index].dev==true)
{
send_reliable(e.peer_id,"isdev",0);
players[index].dev=true;
}
else if(file_exists(charfolder+"/admin.usr") and players[index].dev==false)
{
send_reliable(e.peer_id,"isadmin",0);
players[index].is_admin=true;
send_reliable(0,"play_s notify_applause.ogg",0);
send_reliable(0,players[index].name+" is an administrator of The War",2);
if(players[index].adminflag==1) players[index].title="administrator";
}
if(file_exists(charfolder+"/mod.usr") and players[index].dev==false)
{
send_reliable(e.peer_id,"isadmin",0);
players[index].is_mod=true;
if(players[index].adminflag==1) players[index].title="INS";
}
if(file_exists(charfolder+"/builder.usr"))
{
players[index].is_builder=true;
send_reliable(0,"play_s notify_applause.ogg",0);
send_reliable(0,players[index].name+" is a builder of The War",2);
if(players[index].adminflag==1) players[index].title="builder";
}
}
}
else if(parsed[0]=="close")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
log("disconnections",players[index].name+" disconnected",true,true);
//if (cheatercheck(index)||players[index].cheater==1)
//{
//players[index].health=0;
//send_reliable(0,players[index].name+" is a cheater! Health is 0.",2);
//players[index].persisttimer.restart();
//players[index].disconnected=true;
//}
//else
if(players[index].map=="ch4" or players[index].map=="ch5" or players[index].map=="dangerous_place" or players[index].map=="laberinths" or players[index].map=="stun" or players[index].map=="weapon" or players[index].map=="water_challenge")
{
move_player(players[index],"store",5,0,0);
players[index].disconnected=true;
}
if(players[index].map=="arena" and players[index].x==50 and players[index].y==50 and players[index].z==10)
{
move_player(players[index],"store",5,0,0);
players[index].disconnected=true;
}
if(players[index].map=="arena" or players[index].map=="arena_wait")
{
move_player(players[index],"store",5,0,0);
players[index].give("death_free_card",-10);
send_reliable(0,"play_s autonotify.ogg",0);
send_reliable(0,"Attention! Attention! "+players[index].name+" got scared of the arena and quit the game! But we don't know if he has a bad internet connection. But still, the shame!",2);
players[index].disconnected=true;
fighiters+=-1;
}
else
{
remove_player(players[index].name);
}
}
}
else if(parsed[0]=="hidechar" and parsed.length()>1)
{
if(directory_exists("chars/"+parsed[1])==false)
{
send_reliable(e.peer_id,"nochar",0);
return;
}
fl.open("chars/"+parsed[1]+"/hidden.usr","wb");
fl.write("1");
fl.close();
send_reliable(e.peer_id,"hidden",0);
}
else if(parsed[0]=="changeeml" and parsed.length()>2)
{
if(directory_exists("chars/"+parsed[1])==false)
{
send_reliable(e.peer_id,"nochar",0);
return;
}
fl.open("chars/"+parsed[1]+"/eml.usr","wb");
fl.write(parsed[2]);
fl.close();
send_reliable(e.peer_id,"changed",0);
}
else if(parsed[0]=="newplayer" and parsed.length() > 7)
{
bool spawnable=true;
for(uint i=0; i<players.length(); i++)
{
if(players[i].name==parsed[5])
{
spawnable=false;
}
}
if(spawnable==true)
{
int hide=stn(get_char_val(parsed[5],"hidden"));
spawn_player(string_to_number(parsed[1]), string_to_number(parsed[2]), string_to_number(parsed[3]), parsed[4], parsed[5], e.peer_id,parsed[6],string_replace(parsed[7],"[spce]"," ",true),n.get_peer_address(e.peer_id),string_replace(get_event_message(),parsed[0]+" "+parsed[1]+" "+parsed[2]+" "+parsed[3]+" "+parsed[4]+" "+parsed[5]+" "+parsed[6]+" "+parsed[7],"",false),hide);
int index=get_player_index(e.peer_id);
if(index>-1)
{
load_char_data(index);
string loc=get_location(e.peer_id);
write_to(parsed[5],"location.usr",loc);
fl.open("chars/"+parsed[5]+"/info.usr","ab");
fl.write(loc);
fl.close();
index=get_player_index_from(parsed[5]);
if(index>-1 and players[index].warnlevel>0)
{
send_reliable(players[index].peer_id,"play_s warn"+players[index].warnlevel+".ogg",0);
send_reliable(players[index].peer_id,"dlg you have a pending warning: "+players[index].warning+". Type /warned to show you have read and understand this warning",0);
}
if(msounds.length()>0)
for(uint i=0; i<msounds.length; i++)
{
send_reliable(players[index].peer_id,"createmsound "+msounds[i].id+" "+msounds[i].soundloop+" "+msounds[i].x+" "+msounds[i].y+" "+msounds[i].z+" "+msounds[i].map+" "+msounds[i].pitch,4);
}
if(sirens.length()>0)
for(uint i=0; i<sirens.length; i++)
{
send_reliable(players[index].peer_id,"createsiren "+sirens[i].id+" "+sirens[i].soundloop+" "+sirens[i].x+" "+sirens[i].y+" "+sirens[i].z+" "+sirens[i].map,4);
}
send_reliable(players[index].peer_id,"weaponlist "+wnames,0);
players[index].oldhealth=players[index].health;
players[index].statchangetimer.force(60000);
players[index].invusetimer.force(60000);
if(beta==true)
{
send_reliable(players[index].peer_id,"Welcome to the killer beta server! Version "+version+ "beta. Type /changes to see what's new, /rules to view rules, and /help to see available commands. Last revision of rules is "+file_get_contents("rules_revision.txt")+". server message: "+motd(),2);
}
else
send_reliable(players[index].peer_id,"welcome to The War, Type /changes to see what's new, and type /rules to see game rules! Message of the day: "+motd(),2);
send_reliable(players[index].peer_id,"play_s welcome"+random(1,27)+".ogg",0);
if(double_xp==1)
{
send_reliable(players[index].peer_id,"Double Experience points are now enabled! Enjoy before they ends!",2);
send_reliable(players[index].peer_id,"play_s double.ogg",0);
}
if(custom_xp==1)
{
send_reliable(players[index].peer_id,"Super Experience points are now enabled! Enjoy before they ends!",2);
send_reliable(players[index].peer_id,"play_s double.ogg",0);
}
if(guessthenumber_active==1)
{
send_reliable(players[index].peer_id,"The guess the number minigame is active! Everyone has 5 minutes to enter a number in to the box. Press shift g <number> to submit your guess, no less than 1 and no higher than 50. The cloesest person to the number gets 500000 dollars. Go!",2);
send_reliable(players[index].peer_id,"play_s notify.ogg",0);
}
if(hide>0)
{
players[index].is_dead=true;
send_reliable(players[index].peer_id,"play_s pm.ogg",0);
send_reliable(players[index].peer_id,"you are currently hiding",2);
}
}
}
}
else if(parsed[0]=="fall")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden==0) send_reliable(0,"fall "+players[index].name+" "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map,0);
}
}
else if(parsed[0]=="hardland")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].hidden>0) return;
int falld=stn(parsed[1]);
players[index].health-=falld*10000;
players[index].should_subtract=false;
players[index].hitby="the laws of gravity";
send_reliable(0,"hardland "+players[index].name+" "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map,0);
if(players[index].health>=1500000)
{
add_achievement("Survived a fall with 50 percent default health",index,"1 antibiotic_pack");
}
players[index].sitting=1;
send_reliable(players[index].peer_id,"sitstart",0);
}
}
else if(parsed[0]=="land")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
if(players[index].hidden==0) send_reliable(0, "land "+players[index].name+" "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map, 0, index);
}
}
else if(parsed[0]=="shelterfix" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"Canceled!",0);
return;
}
double h=stn(parsed[1]);
if(h<0)
{
players[index].sendpacket("Overflow error!",0);
return;
}
double wood=players[index].get_item_count("wood");
if(wood<h)
{
send_reliable(players[index].peer_id,"Not enough wood!",0);
return;
}
int s=in_shelter(players[index].name);
if(s>-1)
{
play("shelterfix",players[index].x,players[index].y,players[index].z,players[index].map);
play("shelterfix",shelters[s].x,shelters[s].y,shelters[s].z,shelters[s].map);
int rep=h*random(50,200);
if((shelters[s].health+rep)>shelters[s].maxhealth)
{
int delta=(shelters[s].health+rep-shelters[s].maxhealth);
int ret=round((delta/(rep/h)),0);
players[index].give("wood",ret);
}
shelters[s].health+=rep;
players[index].give("wood",-h);
}
}
}
else if(parsed[0]=="draw" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].map=="jail" or players[index].is_dead)
return;
players[index].stun(404,false,false);
play(parsed[1]+"draw", players[index].x, players[index].y, players[index].z, players[index].map);
send_reliable(players[index].peer_id,"weapondata "+dget_string(wdata,parsed[1]),0);
players[index].weapon=parsed[1];
players[index].get_weapon_propperties(players[index].weapon);
players[index].firing=false;
}
}
else if(parsed[0]=="jump")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
int r=random(0,50);
if(r>=45)
{
int sticky=has_stickybomb(players[index].name);
if(sticky>-1)
{
stickybombs[sticky].stickyplayer="";
players[index].playsound("stickybombunstick");
}
}
if(players[index].hidden==0) send_reliable(0, "jump "+players[index].name+" "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map, 0, index);
}
}
else if(parsed[0]=="reload")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].stunned==false and players[index].firing==false and players[index].reloading==false)
{
if(players[index].weapon=="knife" or players[index].weapon=="fists" or players[index].weapon=="sword")
{
send_reliable(players[index].peer_id,"This weapon does not take ammo",0);
return;
}
else if(players[index].weapon=="")
{
send_reliable(players[index].peer_id, "you have no weapon equipped", 0);
return;
}
if(players[index].get_ammo_count_from(players[index].weapon)>0)
{
return;
}
if(players[index].get_item_count("ammo_"+players[index].weapon)<=0)
{
send_reliable(players[index].peer_id,"no ammo left for "+players[index].weapon+"!",0);
return;
}
else
{
players[index].reloadtime=players[index].w.get_reloadtime();
players[index].reloadtimer.restart();
send_reliable(players[index].peer_id, "cannotdraw", 0);
players[index].reloading=true;
players[index].playsound(players[index].weapon+"reload");
}
}
}
}
else if(parsed[0]=="robotcheck")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
string a;
for (uint r=0; r<robots.length(); r++)
{
if (robots[r].x<players[index].x+50 and robots[r].x>players[index].x-50 and robots[r].y<players[index].y+50 and robots[r].y>players[index].y-50 and robots[r].map==players[index].map)
{
int level=1;
if(robots[r].z>players[index].z)
{
level=2;
}
else if(robots[r].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
if(level==2)
{
a+="above, ";
}
else if(level==0)
{
a+="below, ";
}
a+=robots[r].name+" with "+robots[r].health+" health is "+calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, robots[r].x, robots[r].y, players[index].facing))+", "+get_3d_distance(players[index].x, players[index].y, players[index].z, robots[r].x, robots[r].y, robots[r].z)+" feet away. ";
}
}
if(a=="")
a="There are no robots near you";
send_reliable(players[index].peer_id,a,2);
}
}
else if(parsed[0]=="healthcheck")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int v=in_vehicle(players[index].name);
int sh=in_shelter(players[index].name);
if(v<0&&sh<0) send_reliable(e.peer_id,"speak "+players[index].health+" health, "+players[index].shieldshots+" shielded shots.",0);
else if(sh>-1&&v<0) send_reliable(players[index].peer_id,"speak this shelter has "+shelters[sh].health+" health, and you have "+players[index].health+" health, with "+players[index].shieldshots+" shielded shots",0);
else if(v>-1) {
int ms=vs[v].fuel*(100/0.1)*(vs[v].fueltime-(vs[v].vfueltime*(vs[v].speed-1)));
send_reliable(players[index].peer_id,"speak your "+vs[v].type+" has "+vs[v].health+" health, and "+vs[v].fuel+"% fuel. Last hit by "+vs[v].hitby,0);
}
}
}
else if(parsed[0]=="shsendstore")
{
int index=get_player_index(e.peer_id);
if(index>-1 and in_shelter(players[index].name)>-1)
{
if(parsed[1]=="back")
{
send_serverbox(players[index].peer_id, 0, -1, 1, 1, "shcommand", "you exit the store screen. \r\nwhat would you like to do?");
return;
}
else if(parsed[1]=="shoppingcart")
{
string cart_items;
int s=in_shelter(players[index].name);
if(s>-1)
{
string[] temp=shelters[s].shopping_cart.get_keys();
for(int i=0; i<temp.length(); i++)
{
cart_items+=shelters[s].get_cart_item_amount(temp[i])+" "+temp[i]+". costs "+get_shelter_price(temp[i], shelters[s].get_cart_item_amount(temp[i]))+" dollars.:"+temp[i]+"[]";
}
cart_items+="total price is "+shelters[s].get_total_cart_price()+" dollars. press enter to checkout:checkout[]";
send_menu(players[index].peer_id, "shopping cart menu", "shcartaction", cart_items);
}
}
else
{
int si=get_store_index_from(parsed[1]);
if(si>-1) stores[si].send(players[index].peer_id, "shcartadding", true);
}
}
}
else if(parsed[0]=="shcartaction")
{
int index=get_player_index(e.peer_id);
if(index>-1 and in_shelter(players[index].name)>-1)
{
int s=in_shelter(players[index].name);
if(parsed.length<3 and parsed[1]=="back" or parsed.length()>=3 and parsed[2]=="[cncel]")
{
send_serverbox(players[index].peer_id, 0, -1, 1, 1, "shcommand", "operation canceled. \r\nwhat would you like to do?");
return;
}
if(parsed[1]=="checkout" and s>-1) shelters[s].checkout(players[index].peer_id);
else
{
if(parsed.length()<3)
{
send_serverbox(players[index].peer_id, 2, -1, -1, -1, "shcartaction "+parsed[1], "how much of "+parsed[1]+"do you want to remove");
return;
}
else
{
int amount=stn(parsed[2]);
if(amount>shelters[s].get_cart_item_amount(parsed[1]))
{
send_serverbox(players[index].peer_id, 0, -1, 1, 1, "shcommand", "you don't have that many of this item on your shopping cart. \r\nwhat would you like to do now?");
return;
}
string result;
if(amount==shelters[s].get_cart_item_amount(parsed[1]))
{
result+="you removed the hole set of "+parsed[1]+"s from the shopping cart";
}
else
{
result+="you removed "+amount+" "+parsed[1];
if(amount>1) result+="s";
result+=" from the shopping cart.";
}
shelters[s].add_to_cart(parsed[1], -amount);
send_serverbox(players[index].peer_id, 0, -1, 1, 1, "shcommand", result+"\r\nwhat would you like to do now?");
}
}
}
}
else if(parsed[0]=="shcartadding")
{
int index=get_player_index(e.peer_id);
if(index>-1 and in_shelter(players[index].name)>-1)
{
if(parsed[1]=="back")
{
send_serverbox(players[index].peer_id, 0, -1, 1, 1, "shcommand", "canceled. \r\nwhat would you like to do?");
return;
}
send_serverbox(players[index].peer_id, 2, -1, -1, -1, "shcartadded "+parsed[1], "how much of this item do you want to add?");
}
}
else if(parsed[0]=="shcartadded")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(s>-1)
{
if(parsed[2]!="[cncel]")
{
shelters[s].add_to_cart(parsed[1], stn(parsed[2]));
int num=stn(parsed[2]);
string result=parsed[2]+" "+parsed[1];
if(num>2) result+="s";
result+=" have been added to the shopping cart";
send_serverbox(players[index].peer_id, 0, -1, 1, 1, "shcommand", result+"\r\nwhat would you like to do now?");
}
else
{
send_reliable(players[index].peer_id, "operation canceled", 0);
return;
}
}
}
}
else if(parsed[0]=="xplay" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1&&players[index].hidden==0) playext(parsed[1],players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
}
else if(parsed[0]=="track" and parsed.length()>1)
{
int i=get_player_index(e.peer_id);
if(i>-1)
{
int index=get_player_index_from(parsed[1]);
if(index<0)
{
send_reliable(e.peer_id,"Player not found",0);
return;
}
else
if(players[index].invinsible)
{
send_reliable(e.peer_id,"you cant track pacifist player",0);
}
else
if(players[index].invisible or players[index].is_dead)
send_reliable(e.peer_id,"This player can not be tracked",0);
else
{
string soundname;
if(are_teamed(players[index].name,players[i].name)==true)
soundname="teambeacon";
else
soundname="track";
send_reliable(e.peer_id,"trackplayer "+players[index].name+" "+players[index].x+" "+players[index].y+" "+players[index].z+" "+players[index].map+" "+soundname,0);
}
}
}
else if(parsed[0]=="whatnear")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
string s;
if (storex<players[index].x+30 and storex>players[index].x-30 and storey<players[index].y+30 and storey>players[index].y-30 and get_1d_distance(0,players[index].z)<=30 and players[index].map=="main"&&storemovestage<=1)
{
int level=1;
if(storez>players[index].z)
{
level=2;
}
else if(storez<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="The ";
s+="store is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, storex, storey, players[index].facing))+", "+players[index].distancecheck(storex,storey,storez)+" feet away. ";
}
for (uint i=0; i<helicopters.length(); i++)
{
if (helicopters[i].x<players[index].x+30 and helicopters[i].x>players[index].x-30 and helicopters[i].y<players[index].y+30 and helicopters[i].y>players[index].y-30 and get_1d_distance(helicopters[i].z,players[index].z)<=30 and helicopters[i].map==players[index].map)
{
int level=1;
if(helicopters[i].z>players[index].z)
{
level=2;
}
else if(helicopters[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="a helicopter ";
s+=helicopters[i].id+" with "+helicopters[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, helicopters[i].x, helicopters[i].y, players[index].facing))+", "+players[index].distancecheck(helicopters[i].x,helicopters[i].y,helicopters[i].z)+" feet away. ";
}
}
for (uint i=0; i<shelters.length(); i++)
{
if (shelters[i].x<players[index].x+20 and shelters[i].x>players[index].x-20 and shelters[i].y<players[index].y+20 and shelters[i].y>players[index].y-20 and get_1d_distance(shelters[i].z,players[index].z)<=20 and shelters[i].map==players[index].map)
{
int level=1;
if(shelters[i].z>players[index].z)
{
level=2;
}
else if(shelters[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="The ";
if(shelters[i].broken==true)
s+="broken ";
s+=shelters[i].sheltername+" shelter belonging to "+shelters[i].owner+" with "+shelters[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, shelters[i].x, shelters[i].y, players[index].facing))+", "+players[index].distancecheck(shelters[i].x,shelters[i].y,shelters[i].z)+" feet away. ";
}
}
for (uint i=0; i<vending_machines.length(); i++)
{
if (vending_machines[i].x<players[index].x+20 and vending_machines[i].x>players[index].x-20 and vending_machines[i].y<players[index].y+20 and vending_machines[i].y>players[index].y-20 and get_1d_distance(vending_machines[i].z,players[index].z)<=20 and vending_machines[i].map==players[index].map)
{
int level=1;
if(vending_machines[i].z>players[index].z)
{
level=2;
}
else if(vending_machines[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="a ";
s+="vending machine selling food and drinks is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, vending_machines[i].x, vending_machines[i].y, players[index].facing))+", "+players[index].distancecheck(vending_machines[i].x,vending_machines[i].y,vending_machines[i].z)+" feet away. ";
}
}
for (uint i=0; i<ultrabombs.length(); i++)
{
if (ultrabombs[i].x<players[index].x+20 and ultrabombs[i].x>players[index].x-20 and ultrabombs[i].y<players[index].y+20 and ultrabombs[i].y>players[index].y-20 and get_1d_distance(players[index].z,ultrabombs[i].z)<=20 and ultrabombs[i].map==players[index].map)
{
int level=1;
if(ultrabombs[i].z>players[index].z)
{
level=2;
}
else if(ultrabombs[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+=cn2n(ultrabombs[i].owner)+"'s ultrabomb with "+ultrabombs[i].dollars+" dollars is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, ultrabombs[i].x, ultrabombs[i].y, players[index].facing))+", "+players[index].distancecheck(ultrabombs[i].x,ultrabombs[i].y,ultrabombs[i].z)+" feet away. ";
}
}
for (uint i=0; i<objs.length(); i++)
{
if (objs[i].x<players[index].x+20 and objs[i].x>players[index].x-20 and objs[i].y<players[index].y+20 and objs[i].y>players[index].y-20 and get_1d_distance(players[index].z,objs[i].z)<=20 and objs[i].map==players[index].map)
{
int level=1;
if(objs[i].z>players[index].z)
{
level=2;
}
else if(objs[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+=objs[i].name+" is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, objs[i].x, objs[i].y, players[index].facing))+", "+players[index].distancecheck(objs[i].x,objs[i].y,objs[i].z)+" feet away. ";
}
}
for (uint i=0; i<remguns.length(); i++)
{
if (remguns[i].x<players[index].x+20 and remguns[i].x>players[index].x-20 and remguns[i].y<players[index].y+20 and remguns[i].y>players[index].y-20 and get_1d_distance(players[index].z,remguns[i].z)<=20 and remguns[i].map==players[index].map)
{
int level=1;
if(remguns[i].z>players[index].z)
{
level=2;
}
else if(remguns[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+=remguns[i].owner+"'s remote gun with "+(50-remguns[i].shotsfired)+" remaining bullets is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, remguns[i].x, remguns[i].y, players[index].facing))+", "+players[index].distancecheck(remguns[i].x,remguns[i].y,remguns[i].z)+" feet away. ";
}
}
for (uint i=0; i<remote_timebombs.length(); i++)
{
if (remote_timebombs[i].x<players[index].x+20 and remote_timebombs[i].x>players[index].x-20 and remote_timebombs[i].y<players[index].y+20 and remote_timebombs[i].y>players[index].y-20 and get_1d_distance(players[index].z,remote_timebombs[i].z)<=20 and remote_timebombs[i].map==players[index].map)
{
int level=1;
if(remote_timebombs[i].z>players[index].z)
{
level=2;
}
else if(remote_timebombs[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="a remote timebomb is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, remote_timebombs[i].x, remote_timebombs[i].y, players[index].facing))+", "+players[index].distancecheck(remote_timebombs[i].x,remote_timebombs[i].y,remote_timebombs[i].z)+" feet away. ";
}
}
for (uint i=0; i<lockers.length(); i++)
{
if (lockers[i].x<players[index].x+20 and lockers[i].x>players[index].x-20 and lockers[i].y<players[index].y+20 and lockers[i].y>players[index].y-20 and get_1d_distance(players[index].z,lockers[i].z)<=20 and "store"==players[index].map)
{
int level=1;
if(lockers[i].z>players[index].z)
{
level=2;
}
else if(lockers[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
s+="a locker with "+lockers[i].security_boosts+" added security is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, lockers[i].x, lockers[i].y, players[index].facing))+", "+players[index].distancecheck(lockers[i].x,lockers[i].y,lockers[i].z)+" feet away. ";
}
}
if (s=="")
s="There is nothing around";
if(in_vehicle(players[index].name)<0&&players[index].hidden==0) play("lookaround",players[index].x,players[index].y,players[index].z,players[index].map);
send_reliable(players[index].peer_id, s, 2);
}
}
else if(parsed[0]=="whonear")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
string s;
for (uint i=0; i<players.length(); i++)
{
if(players[i].is_dead==true||in_vehicle(players[i].name)>-1||(players[i].invinsible&&!players[index].adminable())) continue;
if (players[i].x<players[index].x+30 and players[i].x>players[index].x-30 and players[i].y<players[index].y+30 and players[i].y>players[index].y-30 and get_1d_distance(players[index].z,players[i].z)<=30 and players[i].map==players[index].map and players[i].name!=players[index].name and players[i].invisible==false)
{
int level=1;
if(players[i].z>players[index].z)
{
level=2;
}
else if(players[i].z<players[index].z)
{
level=0;
}
else
{
level=1;
}
if(players[i].shielded==true)
s+="shielded with "+players[i].health+" health ";
if(players[i].invinsible==true)
s+="pacifist ";
s+=players[i].ttitle+" "+players[i].ptitle+" "+players[i].name+" with "+players[i].health+" health is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, players[i].x, players[i].y, players[index].facing))+", "+get_3d_distance(players[index].x, players[index].y, players[index].z, players[i].x, players[i].y, players[i].z)+" feet away. ";
}
}
for(uint i=0; i<vs.length; i++)
{
if(get_3d_distance(players[index].x,players[index].y,players[index].z,vs[i].x,vs[i].y,vs[i].z)<=30&&vs[i].map==players[index].map&&vs[i].owner!=players[index].name)
{
int level=1;
if(vs[i].z>players[index].z) level=2;
if(vs[i].z<players[index].z) level=0;
s+=cn2n(vs[i].owner)+"'s "+vs[i].type+" is ";
if(level==2)
{
s+="above, ";
}
else if(level==0)
{
s+="below, ";
}
s+=calculate_x_y_string(calculate_x_y_angle(players[index].x, players[index].y, vs[i].x, vs[i].y, players[index].facing))+", "+get_3d_distance(players[index].x, players[index].y, players[index].z, vs[i].x, vs[i].y, vs[i].z)+" feet away. ";
}
}
if(s=="")
s="There is no one around";
send_reliable(players[index].peer_id,s,2);
if(in_vehicle(players[index].name)<0&&players[index].hidden==0) play("lookaround",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
else if(parsed[0]=="whoonline")
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
string s="";
string s2;
string[] outs;
for (uint i=0; i<players.length(); i++)
{
if(players[i].hidden>0)
{
continue;
}
int t2=is_in_team(players[i].name);
if(t2>-1)
{
if(players[i].super=="true")
outs.insert_last(teams[t2].teamname+" "+players[i].nickname+" ("+players[i].name+") with "+players[i].points+" points");
else
outs.insert_last(teams[t2].teamname+" "+players[i].nickname+" ("+players[i].name+") with reserection "+players[i].re+" and level "+players[i].level+" with "+players[i].kills+" kills and "+players[i].deaths+" deaths ");
}
else
if(players[i].super=="true")
outs.insert_last(players[i].nickname+" "+players[i].name+" with "+players[i].points+" points ");
else
outs.insert_last(players[i].nickname+" "+players[i].name+"  with resurrection "+players[i].re+" and level "+players[i].level+" with "+players[i].kills+" kills and "+players[i].deaths+" deaths ");
}
if(players[index].adminable())
{
for(uint i=0; i<players.length; i++)
{
if(players[i].hidden>0) outs.insert_last("hidden "+players[i].nickname+" ("+players[i].name+")");
}
}
if(outs.length>1)
{
for(uint i=0; i<outs.length; i++)
{
if(i==(outs.length-1)) s+="and "+outs[i]+".";
else s+=outs[i]+", ";
}
}
else
s="You're the only one online";
if(outs.length()>1)
s2="There are currently "+outs.length()+" players online. ";
send_reliable(players[index].peer_id, s2+s, 2);
}
}
else if(parsed[0]=="build")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(players[index].adminable()||players[index].is_builder)
send_menu(players[index].peer_id,"Build what?","buildobj","tile:tile[]zone:zone[]disablitem:ni[]sound source:src[]ambience:amb[]door:door[]travelpoint:tpoint");
}
}
else if (parsed[0]=="inv" and parsed.length()>=3)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].give(parsed[1],stn(parsed[2]));
}
}
else if(parsed[0]=="iamdmoving")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].dmoving=true;
}
}
else if(parsed[0]=="iamnotdmoving")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].dmoving=false;
}
}
else if(parsed[0]=="playonmap" and parsed.length()>1)
{
int x=get_player_index(e.peer_id);
if(x>-1)
{
int px=players[x].x;
int y=players[x].y;
int z=players[x].z;
string map=players[x].map;
for(uint i=0; i<players.length(); i++)
{
if(players[i].name!=players[x].name)
{
send_reliable(players[x].peer_id,string_replace(parsed[1],".ogg","",true)+" "+px+" "+y+" "+z+" "+map,3);
}
}
}
}
else if(parsed[0]=="updatezone" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].zone=string_replace(get_event_message(),"updatezone ","",true);
}
}
else if(parsed[0]=="vendingpress" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int vx=get_vending_index(players[index].x,players[index].y,players[index].z,players[index].map);
if(vx>-1)
{
string cmd=string_replace(get_event_message(),"vendingpress ","",false);
if(string_contains(cmd,"[cncel]",1)>-1)
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
vending_machines[vx].command(cmd,e.peer_id);
}
}
}
else if(parsed[0]=="lockcode" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
send_reliable(players[index].peer_id,"canceled",0);
return;
}
if(string_is_digits(parsed[1])==false)
{
send_reliable(players[index].peer_id,"error with input",0);
send_reliable(players[index].peer_id,"play_s lockererror.ogg",0);
return;
}
int c=stn(parsed[1]);
int l=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(l>-1)
{
if(lockers[l].code==c)
{
lockers[l].lockplay("dooropen");
string stuff="Press g to get something from the locker. Press S to store something in the locker. Make a selection";
send_serverbox(players[index].peer_id,0,-1,1,1,"lockcommand",stuff);
}
else
{
send_reliable(players[index].peer_id,"Incorrect code",0);
return;
}
}
}}
else if(parsed[0]=="lockcommand" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int l=get_locker_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(l>-1)
{
string cmd=string_replace(get_event_message(),"lockcommand ","",false);
lockers[l].command(cmd,players[index].peer_id);
}
}
}
else if(parsed[0]=="changelockcode" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
int l = get_locker_at(players[index].x, players[index].y, players[index].z, players[index].map);
if(string_is_digits(parsed[1]))
{
lockers[l].code=string_to_number(parsed[1]);
send_reliable(players[index].peer_id, "the code was changed successfully. New code is "+lockers[l].code, 2);
}
else
{
send_reliable(players[index].peer_id, "error", 2);
}
}
else if(parsed[0]=="shcommand" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(s>-1)
{
string command=string_replace(get_event_message(),"shcommand ","",false);
shelters[s].command(command,e.peer_id);
}
}
}
else if(parsed[0]=="shstoragecommand" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(s>-1)
{
string command=string_replace(get_event_message(),"shstoragecommand ","",false);
shelters[s].storage_command(command,e.peer_id);
}
}
}
else if(parsed[0]=="shmoneycommand" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(s>-1)
{
string command=string_replace(get_event_message(),"shmoneycommand ","",false);
shelters[s].sh_money_command(command,e.peer_id);
}
}
}
else if(parsed[0]=="shsendmoneyrequest" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(s<0)
{
send_reliable(players[index].peer_id,"An internal server error happened. Please try your request again",0);
return;
}
if(stn(parsed[1])==shelters[s].compcode)
{
string stuff="Enter shelter ID";
send_serverbox(players[index].peer_id,1,-1,0,-1,"shsendmoney",stuff);
return;
}
else
{
shelters[s].compplay("shelter_computererror");
string information="Incorrect code";
send_serverbox(e.peer_id,0,-1,1,1,"shmoneycommand",information+".\r\nwhat would you like to do");
}
}
}
else if(parsed[0]=="shmoneycashout" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
int s=in_shelter(players[index].name);
if(s<0)
{
send_reliable(players[index].peer_id,"An internal server error happened. Please try your request again",0);
return;
}
if(stn(parsed[1])==shelters[s].compcode)
{
string stuff="enter amount of dollars you want to take out. Amount of dollars in the computer: "+shelters[s].dollars;
send_serverbox(players[index].peer_id,2,-1,0,-1,"shcashid",stuff);
return;
}
else
{
shelters[s].compplay("shelter_computererror");
string information="Incorrect code";
send_serverbox(e.peer_id,0,-1,1,1,"shmoneycommand",information+".\r\nwhat would you like to do");
}
}
}
else if(parsed[0]=="shcashid" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
string stuff="canceled";
send_serverbox(e.peer_id,0,-1,1,1,"shmoneycommand",stuff+".\r\nwhat would you like to do");
return;
}
int s=in_shelter(players[index].name);
if(s<0)
{
send_reliable(players[index].peer_id,"Sorry, an internal error happened",0);
return;
}
double amount=stn(parsed[1]);
if(amount<0)
{
string stuff="Sorry, can't enter negative values";
send_serverbox(e.peer_id,0,-1,1,1,"shmoneycommand",stuff+".\r\nwhat would you like to do");
return;
}
if(shelters[s].dollars<amount)
{
string stuff="Error: this shelter does not have the required funds to do this operation";
send_serverbox(e.peer_id,0,-1,1,1,"shmoneycommand",stuff+".\r\nwhat would you like to do");
return;
}
string stuff="Success! Select an option";
send_serverbox(e.peer_id,0,-1,1,1,"shmoneycommand",stuff+".\r\nwhat would you like to do");
//spawn_timeitem(3,3,0,shelters[s].sheltername,"dollar",amount);
players[index].give("dollar", amount);
shelters[s].dollars-=amount;
}
}
else if(parsed[0]=="shsendmoney" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="[cncel]")
{
string information="canceled";
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+".\r\nwhat would you like to do");
return;
}
int sh=get_shelter_from_id(parsed[1]);
if(sh<0)
{
string information="Error! ID not valid";
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+".\r\nwhat would you like to do");
return;
}
else
{
send_serverbox(players[index].peer_id,1,2,0,-1,"shsendnow "+parsed[1],"Enter amount of dollars you want to send to this shelter");
}
}
}
else if(parsed[0]=="shsendnow" and parsed.length()>2)
{
if(get_player_index(e.peer_id)>-1)
{
int index=get_player_index(e.peer_id);
if(parsed[2]=="[cncel]")
{
string information="canceled.";
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+"\r\nwhat would you like to do");
return;
}
string id=parsed[1];
double amount=stn(parsed[2]);
int s=in_shelter(players[index].name);
if(s<0)
{
send_reliable(players[index].peer_id,"An internal error happened. Please try your request again",0);
return;
}
else
{
if(amount<0)
{
shelters[s].compplay("shelter_computererror");
string information="Can not send a negative amount!";
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+"\r\nwhat would you like to do");
return;
}
if(shelters[s].dollars<amount)
{
shelters[s].compplay("shelter_computererror");
string information="Sorry, this shelter does not have the amount requested";
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+".\r\nwhat would you like to do");
return;
}
int s2=get_shelter_from_id(id);
if(s2<0)
{
shelters[s].compplay("shelter_computererror");
string information="No matching shelters with ID "+id;
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+".\r\nwhat would you like to do");
return;
}
shelters[s].compplay("shelter_money_transfer_sent");
shelters[s2].compplay("shelter_money_transfer_receive");
string information="Transaction completed! Thank you for using SH pay 0.4.1!";
send_serverbox(players[index].peer_id,0,-1,1,1,"shmoneycommand",information+"\r\nwhat would you like to do");
shelters[s].dollars-=amount;
shelters[s2].dollars+=amount;
return;
}
}
}
else if(parsed[0]=="air")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
send_reliable(players[index].peer_id,"You have "+players[index].air+" air. This should last you about "+ms_to_readable_time(players[index].air*3500),0);
}
}
else if(parsed[0]=="sitstand")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].sitting=toggle(players[index].sitting);
if(players[index].sitting==1)
{
spawn_bodyfall(players[index].x,players[index].y,players[index].z,players[index].map,500,index);
players[index].playsound("sit");
}
else
{
if(players[index].drunk==true)
{
int r=random(-50, 100);
if(r>49)
{
send_reliable(players[index].peer_id,"you can't stand up!",0);
spawn_bodyfall(players[index].x,players[index].y,players[index].z,players[index].map,500,index);
}
}
players[index].playsound("stand");
spawn_timepacket(players[index].peer_id,"sitstop",0,1000);
}
}
}
else if(parsed[0]=="newlocker" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string a=parsed[1];
if(a=="n" or a=="[cncel]")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
else if(a=="y")
{
send_reliable(players[index].peer_id,"Done! You may now  build a locker with the locker pack that was just added to your inventory",2);
players[index].give("locker_pack",1);
}
else
{
send_reliable(players[index].peer_id,"Invalid input",0);
return;
}
}
}
else if(parsed[0]=="packsomething" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="back")
{
send_reliable(players[index].peer_id,"Canceled",0);
return;
}
string item=parsed[1];
players[index].give(item,-10);
players[index].give("pack_of_10_"+item,1);
players[index].give("empty_pack", -1);
players[index].playsound("pack");
send_reliable(players[index].peer_id,"You put 10 "+item+"s in a box and close it",0);
}
}
else if(parsed[0]=="restartserver")
{
for(uint i=0; i<players.length; i++)
{
scd(i);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_corpses();
writedata();
save_shipments();
writedata();
save_lockers();
send_reliable(0,"notify Server rebooting",0);
send_reliable(0,"reboot",0);
wait(5);
run(get_script_path(),"",false,false);
exit();
}
else if(parsed[0]=="fallstart")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].falling=true;
}
}
else if(parsed[0]=="fallstop")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].falling=false;
}
}
else if(parsed[0]=="lchannel")
{
server_menu menu;
menu.intro="Select a new language channel";
menu.initial_packet="lchannelset";
string[] lc=string_split(file_get_contents("prefs/language_channels.svr"),"\r\n",false);
for(uint i=0; i<lc.length(); i+=1)
{
menu.add(lc[i],lc[i]);
}
menu.send(e.peer_id);
}
else if(parsed[0]=="gender")
{
server_menu menu;
menu.intro="Select your gender";
menu.initial_packet="genderset";
string[] gn=string_split(file_get_contents("prefs/gender.svr"),"\r\n",false);
for(uint i=0; i<gn.length(); i+=1)
{
menu.add(gn[i],gn[i]);
}
menu.send(e.peer_id);
}
else if(parsed[0]=="genderset" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="back")
{
players[index].sendpacket("canceled", 0);
return;
}
players[index].gender=parsed[1];
players[index].sendpacket("gender changed, your gender:  "+players[index].gender+" ",0);
}
}
else if(parsed[0]=="lchannelset" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="back")
{
players[index].sendpacket("canceled", 0);
return;
}
players[index].langchan=parsed[1];
players[index].sendpacket("Using "+players[index].langchan+" as the new language channel",0);
}
}
else if(parsed[0]=="remgunidset" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(parsed[1]=="back")
{
players[index].sendpacket("Canceled",0);
return;
}
if(remgun_index(stn(parsed[1]))<0)
{
players[index].sendpacket("speak could not connect to this remgun. It may have been destroyed.",0);
return;
}
players[index].remgunid=stn(parsed[1]);
players[index].playsound("remgun_connect");
send_serverbox(players[index].peer_id,0,-1,1,1,"remguncommand","Connected! What would you like to do? Press H for help");
}
}
else if(parsed[0]=="remguncommand" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].remgunid==-1) return;
int rindex=remgun_index(players[index].remgunid);
if(rindex<0)
{
players[index].sendpacket("speak Could not send command to this remgun. It may have been destroyed.",0);
players[index].remgunid=-1;
return;
}
remguns[rindex].command(parsed[1],e.peer_id);
}
}
else if(parsed[0]=="adminlogcopy" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index<0) return;
if(players[index].adminable()==false) return;
if(parsed[1]=="back")
{
players[index].sendpacket("Canceled",0);
return;
}
if(parsed[1]=="copyall")
{
players[index].sendpacket("Log written to clipboard",0);
players[index].sendpacket("clip "+adminlog,0);
return;
}
string s=string_replace(get_event_message(),parsed[0]+" ","",false);
players[index].sendpacket("copyed",0);
players[index].sendpacket("clip "+s,0);
}
else if(parsed[0]=="movedir" and parsed.length() > 1)
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
if(players[index].stunned||in_vehicle(players[index].name)>-1||players[index].warping||(players[index].is_dead&&players[index].hidden==0)) return;
players[index].pmove(parsed[1],index);
}
}
else if(parsed[0]=="giveitem" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string item=parsed[1];
int itemamount=players[index].get_item_count(item);
if(itemamount<=0)
{
players[index].sendpacket("You dont' have any "+item+"s",0);
return;
}
string[] names;
for(uint px=0; px<players.length(); px+=1)
{
if(index==px) continue;
if(players[px].distancecheck(players[index].x,players[index].y,players[index].z)<=5 and players[px].map==players[index].map) names.insert_last(players[px].name);
}
if(names.length()<=0)
{
players[index].sendpacket("There are no players near you",0);
return;
}
server_menu m;
m.initial_packet="playergive/"+item;
m.intro="players menu";
for(uint i=0; i<names.length(); i++)
{
m.add(names[i],names[i]);
}
m.send(players[index].peer_id);
}
}
else if(string_left(parsed[0],11)=="playergive/" and parsed.length()>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
parsed.insert_last(parsed[1]);
parsed[1]=string_trim_left(parsed[0],11);
string n=parsed[2];
if(n=="back") return;
int index2=get_player_index_from(parsed[2]);
if(index2<0)
{
players[index].sendpacket("Player not found",0);
return;
}
int dist=players[index2].distancecheck(players[index].x,players[index].y,players[index].z);
if(dist>5 or players[index2].map!=players[index].map)
{
players[index].sendpacket("This player is too far away",0);
return;
}
send_serverbox(players[index].peer_id,2,-1,1,-1,"transferinv/"+n+"/"+parsed[1],"How many "+parsed[1]+"s would you like to give to "+n+"?");
}
}
else if(parsed[0]=="auctionitem" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
if(players[index].paid==1) send_reliable(e.peer_id,"speak this is only available to paid accounts",0);
else if(auction==true) send_reliable(e.peer_id,"speak there is already an auction in progress",0);
else if(parsed[1]=="bitcoin" or parsed[1]=="dollar" or parsed[1]=="dollar_pack" or parsed[1]=="gold_pack") send_reliable(e.peer_id,"speak You cannot auction money for money, sir.",0);
else send_serverbox(players[index].peer_id,2,-1,1,-1,"auctioning/"+parsed[1],"How many "+parsed[1]+"s would you like to auction?");
return;
}
}
else if(string_left(parsed[0],11)=="auctioning/" and parsed.length>1)
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
string[] inp=string_split(parsed[0],"/",false);
inp.insert_last(parsed[1]);
if(inp.length==3)
{
if(inp[2]=="[cncel]") send_reliable(e.peer_id,"speak canceled",0);
else if(stn(inp[2])<=0) send_reliable(e.peer_id,"speak you must auction at least 1 of an item!",0);
else if(players[index].get_item_count(inp[1])<stn(inp[2])) send_reliable(e.peer_id,"speak You don't have enough. You wanted to auction "+stn(inp[2])+" "+inp[1]+"s and you only have "+players[index].get_item_count(inp[1]),0);
else
{
string jerk;
for(uint i=0; i<inp.length; i++)
{
jerk+=inp[i]+"/";
}
jerk=string_trim_right(jerk,1);
if(jerk<=0)
{
send_reliable(e.peer_id,"You cannot auction negative amounts!",2);
return;
}
send_serverbox(e.peer_id,2,-1,1,-1,jerk,"Minimum bid for this auction?");
}
}
else if(inp.length==4)
{
if(inp[3]=="[cncel]") send_reliable(e.peer_id,"speak canceled",0);
else if(stn(inp[2])<=0) send_reliable(e.peer_id,"speak bid must be greator than 0!",0);
else if(auction) send_reliable(e.peer_id,"speak there is already an auction in progress",0);
else
{
string what=inp[1];
int amount=stn(inp[2]);
int minbid=stn(inp[3]);
if (inv_item_exists(players[index].get_inv(),what))
{
if (players[index].get_item_count(what)>=amount)
{
auctionitem=what;
auctionbid=minbid;
auctionamount=amount;
auctionwho=players[index].name;
send_reliable(0,"New auction from "+players[index].nickname+"! "+amount+" "+auctionitem+", minimum bid "+minbid+" dollars.",2);
send_reliable(0,"play_s auction.ogg",0);
auctiontimer.restart();
auction=true;
auctionbidder=false;
}
else
{
send_reliable(e.peer_id,"You don't have this many.",2);
}
}
else
{
send_reliable(e.peer_id,"You don't have this item.",2);
}
}
}
}
}
else if(parsed[0]=="reginfo")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
write_to(players[index].name,"reginfo.usr",string_replace(get_event_message(),"reginfo ","",false));
}
}
else if(parsed[0]=="regstatus")
{
int index=get_player_index(e.peer_id);
if(index>-1)
{
players[index].registered=stn(parsed[1]);
if(players[index].registered>0)
{
//send_reliable(0,players[index].name+" is a registered user",0);
//if(players[index].dev==false) players[index].title="*";
}
}
}
else if(parsed[0]=="bmove_to" and parsed.length() > 3)
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
if(players[index].stunned||in_vehicle(players[index].name)>-1||players[index].warping||(players[index].is_dead&&players[index].hidden==0)) return;
string name=players[index].name;
players[index].x=string_to_number(parsed[1]);
players[index].y=string_to_number(parsed[2]);
players[index].z=string_to_number(parsed[3]);
players[index].activitytimer.restart();
if(players[index].active==false) players[index].active=true;
if(players[index].bleedsound!=""||players[index].lowhealth||players[index].bleeding) update_moving_sound(players[index].bleedsound,players[index].x,players[index].y,players[index].z);
string gpt=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
if(players[index].dmoving==false and players[index].hidden==0 and gpt!="")
{
play(gpt+"step"+random(10,15),players[index].x,players[index].y,players[index].z,players[index].map,index,true,false);
}
}
}
else if(parsed[0]=="move_to" and parsed.length() > 3)
{
int index=get_player_index(e.peer_id);
if(index > -1)
{
if(players[index].stunned||in_vehicle(players[index].name)>-1||players[index].warping||(players[index].is_dead&&players[index].hidden==0)) return;
string name=players[index].name;
players[index].x=string_to_number(parsed[1]);
players[index].y=string_to_number(parsed[2]);
players[index].z=string_to_number(parsed[3]);
players[index].activitytimer.restart();
if(players[index].active==false) players[index].active=true;
if(players[index].bleedsound!=""||players[index].lowhealth||players[index].bleeding) update_moving_sound(players[index].bleedsound,players[index].x,players[index].y,players[index].z);
int v=in_vehicle(players[index].name);
if(v>-1)
{
vs.remove_at(v);
send_reliable(players[index].peer_id,"veunspawn",0);
}
string gpt=get_tile_at(players[index].x,players[index].y,players[index].z,players[index].map);
int a=string_contains(gpt,"suicide",1);
int isair=string_contains(gpt,"underwater",1);
int stunt=string_contains(gpt,"stungrenade",1);
int meow=string_contains(gpt,"icef",1);
int move=string_contains(gpt,"teleport",1);
int fire=string_contains(gpt,"fi",1);
if(isair>-1 and players[index].dmoving==false and players[index].is_dead==false)
{
if(players[index].underwater==false) { players[index].airwarntimer.restart();players[index].airlifetimer.restart();
players[index].underwater=true;
}
}
if(isair<0 and players[index].dmoving==false)
{
if(players[index].underwater==true) players[index].underwater=false;
}
if(a>-1and players[index].dmoving==false and players[index].is_dead==false)
{
placesuicide_bomb(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
players[index].hitby="suicide_bomb_tile";
}
if(stunt>-1and players[index].dmoving==false and players[index].is_dead==false)
{
placestun_grenade(players[index].x,players[index].y,players[index].z,players[index].map,players[index].name);
players[index].hitby="stun_grenade_tile";
}
if(meow>-1and players[index].dmoving==false and players[index].is_dead==false)
{
players[index].health-=10000000;
players[index].hitby="freezing";
}
if(fire>-1and players[index].dmoving==false and players[index].is_dead==false)
{
players[index].health-=10000000;
players[index].hitby="fire of hell";
}
if(move>-1and players[index].dmoving==false and players[index].is_dead==false)
{
move_player(players[index],players[index].map,random(0,0),random(0,0),0);
play("notify_swoosh",players[index].x,players[index].y,players[index].z,players[index].map);
}
 /*
if(gpt!="" and players[index].dmoving==false and in_vehicle(players[index].name)<0)
players[index].playobjs();
*/
if(players[index].dmoving==false and players[index].hidden==0 and gpt!="")
{
int sh=in_shelter(players[index].name);
if(sh>-1)
play("carpet2"+random(1,5),players[index].x,players[index].y,players[index].z,players[index].map,index,true,false);
else
play(gpt+"step"+random(1,5),players[index].x,players[index].y,players[index].z,players[index].map,index,true,false);
}
}
}
}
}
}
void arenaloop() {
if(fighting==true) {
if(fighiters==1) {
for(int i2=0; i2<players.length(); i2++) {
if(players[i2].map=="arena") {
int a=random(20000, 50000);
players[i2].give("coin",a);
players[i2].give("death_free_card",-10);
send_reliable(players[i2].peer_id,"you have gained "+a+" coins. Nice job!",2);
move_player(players[i2],players[i2].oldmap,players[i2].oldx,players[i2].oldy,players[i2].oldz);
fighting=false;
send_reliable(0,"We congratulate the winner! And the winner is "+players[i2].name+"!",2);
send_reliable(0,"play_s notify_bell.ogg",0);
fighiters=0;
opend=false;
return;
}
}
}
for(uint i4=0; i4<players.length(); i4++) {
if(players[i4].map=="arena" and players[i4].x==50 and players[i4].y==50 and players[i4].z==10) {
move_player(players[i4],players[i4].oldmap,players[i4].oldx,players[i4].oldy,players[i4].oldz);
send_reliable(players[i4].peer_id,"startmoving",0);
return;
}
}
}
if(opend==true) {
fightstarted=true;
if(fighttimer.elapsed>60000) {
fighttimer.restart();
fighting=true;
if (fighting==true) {
if(fighiters==1) {
for(uint i3=0; i3<players.length(); i3++) {
if(players[i3].map=="arena_wait") {
move_player(players[i3],players[i3].oldmap,players[i3].oldx,players[i3].oldy,players[i3].oldz);
send_reliable(players[i3].peer_id,"startmoving",0);
fighting=false;
fightstarted=false;
opend=false;
fighiters=0;
send_reliable(0,"not enough players to fight",2);
send_reliable(0,"play_s notify2.ogg",0);
return;
}
}
}
if(fighiters==0) {
fighting=false;
fightstarted=false;
opend=false;
send_reliable(0,"not enough players to fight",2);
send_reliable(0,"play_s notify2.ogg",0);
return;
}
else
{
fightstarted=false;
arenatimer.restart();
send_reliable(0,"The arena battles have begun! We wish good luck to our fighters!",2);
send_reliable(0,"play_s bell1.ogg",0);
for(uint i=0; i<players.length(); i++) {
if(players[i].map=="arena_wait") {
move_player(players[i],"arena",random(0,100),random(0,100),0);
players[i].give("death_free_card",10);
send_reliable(players[i].peer_id,"startmoving",0);
opend=false;
}
}
}
}
}
}
}
void send_unreliable_x(uint peer, string mess, uint channel, int tx, int ty, int tz, string tmap)
{
mess=string_encrypt(mess, "dSbcDkaFlkGiehGuj%jJjijTikR32E37E$E6789WEW4#87QW897dREuijnYhTj@yUYuiojTjkngTbytjTfhdRksdiDueyC32V78882V7777@BduwhuNhudhsMudhsGujukiHkiihHiuijiHmi##$E#@IO#$IP#JiUjHJIGHJKIUSIYWJINI#@KMIHU#HU$HU#IK@IYUHUSHhgfdsdfg432@$#");
for(uint i=0; i<players.length(); i++)
{
if(players[i].x > tx-50 and players[i].x < tx+50 and players[i].y > ty-50 and players[i].y < ty+50 and players[i].z > tz-50 and players[i].z < tz+50 and players[i].map==tmap)
{
n.send_unreliable(players[i].peer_id, mess, channel);
}
}
}
void send_reliable_x(uint peer, string mess, uint channel, int tx, int ty, int tz,string tmap,int range=50)
{
mess=string_encrypt(mess, "dSbcDkaFlkGiehGuj%jJjijTikR32E37E$E6789WEW4#87QW897dREuijnYhTj@yUYuiojTjkngTbytjTfhdRksdiDueyC32V78882V7777@BduwhuNhudhsMudhsGujukiHkiihHiuijiHmi##$E#@IO#$IP#JiUjHJIGHJKIUSIYWJINI#@KMIHU#HU$HU#IK@IYUHUSHhgfdsdfg432@$#");
for(uint i=0; i<players.length(); i++)
{
if(players[i].x > tx-range and players[i].x < tx+range and players[i].y > ty-range and players[i].y < ty+range and players[i].z > tz-range and players[i].z < tz+range and players[i].map==tmap)
{
n.send_reliable(players[i].peer_id, mess, channel);
}
}
}
void send_reliable(uint peer, string mess, uint channel, int index=-1)
{
mess=string_encrypt(mess, "dSbcDkaFlkGiehGuj%jJjijTikR32E37E$E6789WEW4#87QW897dREuijnYhTj@yUYuiojTjkngTbytjTfhdRksdiDueyC32V78882V7777@BduwhuNhudhsMudhsGujukiHkiihHiuijiHmi##$E#@IO#$IP#JiUjHJIGHJKIUSIYWJINI#@KMIHU#HU$HU#IK@IYUHUSHhgfdsdfg432@$#");
if(index>-1)
{
int x=players[index].x;
int y=players[index].y;
int z=players[index].z;
for(uint i=0; i<players.length(); i++)
{
if(players[i].x > x-50 and players[i].x < x+50 and players[i].y > y-50 and players[i].y < y+50 and players[i].z > z-50 and players[i].z < z+50 and players[i].map==players[index].map and i!=index)
{
n.send_reliable(players[i].peer_id, mess, channel);
}
}
}
else
{
n.send_reliable(peer, mess, channel);
}
}
void send_unreliable(uint peer, string mess, uint channel, int index=-1)
{
mess=string_encrypt(mess, "dSbcDkaFlkGiehGuj%jJjijTikR32E37E$E6789WEW4#87QW897dREuijnYhTj@yUYuiojTjkngTbytjTfhdRksdiDueyC32V78882V7777@BduwhuNhudhsMudhsGujukiHkiihHiuijiHmi##$E#@IO#$IP#JiUjHJIGHJKIUSIYWJINI#@KMIHU#HU$HU#IK@IYUHUSHhgfdsdfg432@$#");
if(index>-1)
{
int x=players[index].x;
int y=players[index].y;
int z=players[index].z;
for(uint i=0; i<players.length(); i++)
{
if(players[i].x > x-50 and players[i].x < x+50 and players[i].y > y-50 and players[i].y < y+50 and players[i].z > z-50 and players[i].z < z+50 and players[i].map==players[index].map and i!=index)
{
n.send_unreliable(players[i].peer_id, mess, channel);
}
}
}
else
{
n.send_unreliable(peer, mess, channel);
}
}
string get_event_message()
{
string r=e.message;
if(r=="")
{
return "";
}
r=string_decrypt(r, "dSbcDkaFlkGiehGuj%jJjijTikR32E37E$E6789WEW4#87QW897dREuijnYhTj@yUYuiojTjkngTbytjTfhdRksdiDueyC32V78882V7777@BduwhuNhudhsMudhsGujukiHkiihHiuijiHmi##$E#@IO#$IP#JiUjHJIGHJKIUSIYWJINI#@KMIHU#HU$HU#IK@IYUHUSHhgfdsdfg432@$#");
return r;
}
void mapupdate(string map)
{
init_mapsystem();
int mi=get_map_index(map);
if(mi<0) return;
string mdata=maps[mi].rawdata;
string ite;
for(uint i=0; i<sources.length(); i++)
{
if(sources[i].map==map)
ite+="src:"+sources[i].lx+":"+sources[i].rx+":"+sources[i].miny+":"+sources[i].maxy+":"+sources[i].minz+":"+sources[i].maxz+":"+sources[i].soundfile+":"+sources[i].id+"\r\n";
}
for(uint i=0; i<robots.length(); i++)
{
if(robots[i].map==mi) {
destroy_moving_sound(robots[i].voice);
robots.remove_at(i);
}
}
maps[mi].currobots=0;

for(uint i=0; i<players.length(); i++)
{
if(players[i].map==map)
{
players[i].map=map;
send_reliable(players[i].peer_id, "m_data "+mdata+"\r\n"+ite+"\r\nx:"+players[i].x+"\r\ny:"+players[i].y+"\r\nz:"+players[i].z+"\r\n", 0);
}
}
}
void playermapupdate(string map, int x, int y, int z, player@ p)
{
string mdata=get_map_text(map);
string ite;
for(uint i=0; i<sources.length(); i++)
{
if(sources[i].map==map)
ite+="src:"+sources[i].lx+":"+sources[i].rx+":"+sources[i].miny+":"+sources[i].maxy+":"+sources[i].minz+":"+sources[i].maxz+":"+sources[i].soundfile+":"+sources[i].id+"\r\n";
}
p.x=0;
p.y=0;
p.z=0;
send_reliable(p.peer_id,"mapname "+map,0);
p.map=map;
send_reliable(p.peer_id, "m_data "+mdata+"\r\n"+ite+"\r\nx:"+x+"\r\ny:"+y+"\r\nz:"+z+"\r\n", 0);
}
string motd()
{
string fmotd=file_get_contents("prefs/motd.svr");
if(fmotd=="")
fmotd="No server message";
return fmotd;
}
void login(string u, string p, string yv, uint id, string compid)
{
bool can_login=true;
if(login_disabled==1)
{
send_reliable(id,"Error: Login feature is currently disabled on the server! please contact the developers!",0);
can_login=false;
}
string ip=n.get_peer_address(id);
if(is_compbanned(compid,u) or is_ipbanned(ip,u))
{
send_reliable(id,"banned",0);
can_login=false;
}
if(tempbancheck(u))
{
int t=get_tempban_index(u);
can_login=false;
send_reliable(id,"block Your account is currently disabled. Please try again in "+ms_to_readable_time(tempbans[t].ms-tempbans[t].tempbantimer.elapsed),0);
}
multiversion yver(yv);
multiversion minver(minverstring);
if(yver<minver)
{
send_reliable(id,"block your client is out of date. Please download latest version of the game from, check for updates option, in, options menu! Your version: "+yv+". Minimum required version is "+minverstring,0);
can_login=false;
}
if(can_login==true)
{
if(!compid_handlercheck(compid))
{
add_compid(compid,u);
}
string charfolder="chars/"+u;
file f, chardata;
if(directory_exists("chars/"+u)==false)
{
send_reliable(id,"nochar",0);
}
else
{
file charfile;
charfile.open("chars/"+u+"/password.usr","rb");
string charpass=charfile.read();
charfile.close();
if(charpass!=string_hash(p,2,false))
{
send_reliable(id,"wrongpass",0);
}
else
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].name==u)
{
 if(players[i].hidden==0) send_reliable(0,u+" has been overwritten",2);
remove_player(u);
}
}
if(file_get_contents(charfolder+"/map.usr")=="")
{
file_put_contents(charfolder+"/map.usr","main",FILE_WRITE);
}
f.open(charfolder+"/map.usr","rb");
string m=f.read();
f.close();
send_reliable(id,"mapname "+m,0);
if(file_get_contents(charfolder+"/facing.usr")=="") file_put_contents(charfolder+"/facing.usr","0",FILE_WRITE);
if(file_get_contents(charfolder+"/x.usr")=="") file_put_contents(charfolder+"/x.usr",""+random(0,0),FILE_WRITE);
if(file_get_contents(charfolder+"/y.usr")=="") file_put_contents(charfolder+"/y.usr",""+random(0,0),FILE_WRITE);
if(file_get_contents(charfolder+"/z.usr")=="") file_put_contents(charfolder+"/z.usr","0",FILE_WRITE);
f.open(charfolder+"/facing.usr","rb");
send_reliable(id,"facing "+f.read(),0);
f.close();
f.open(charfolder+"/gender.usr","rb");
send_reliable(id,"gender"+f.read(),0);
f.close();
f.open(charfolder+"/super.usr","rb");
send_reliable(id,"super"+f.read(),0);
f.close();
f.open(charfolder+"/x.usr","rb");
send_reliable(id,"x "+f.read(),0);
f.close();
f.open(charfolder+"/y.usr","rb");
send_reliable(id,"y "+f.read(),0);
f.close();
f.open(charfolder+"/z.usr","rb");
send_reliable(id,"z "+f.read(),0);
f.close();
send_reliable(id, "motd "+motd(), 0);
log("connections",u+" logged in.",true,true);
send_reliable(id, "loggedin", 0);
}
}
}
}
int get_player_index(uint id)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].peer_id==id)
{
return i;
}
}
return -1;
}
int get_player_index_from(string name, bool evenhidden=true)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].name==name)
{
if(!evenhidden&&players[i].hidden>0) continue;
 return i;
}
}
return -1;
}
int get_item_index(string name)
{
string[] items;
for(int i=0; i<stores.length; i++)
{
for(int i2=0; i2<stores[i].item_names.length(); i2++)
{
items.insert_last(stores[i].item_names[i2]);
}
}
for(int i=0; i<items.length(); i++)
{
if(items[i]==name) return i;
}
return -1;
}
void create_char(string username, string password, string email,uint id, string compid)
{
if(filter(username))
{
send_reliable(id,"Error: this username contains eloquence crash codes",0);
return;
}
if(filterchar(username,true))
{
send_reliable(id,"Error: this username contains invalid characters",0);
return;
}
if(disable_account_creation==1)
{
send_reliable(id,"Error: account creation is currently disabled on the server, please contact the developers!",0);
return;
}
{
int cindex=get_compid_handler_index(compid);
if(cindex>-1)
{
send_reliable(id,"Error: it seems as though you have created an other account ("+comphandles[cindex].playername+") if you get this message and you have not created an account, contact the developers",0);
return;
}
}
string ip=n.get_peer_address(id);
if(is_compbanned(compid,"") or is_ipbanned(ip,""))
{
send_reliable(id,"Error: This client is banned",0);
return;
}
string charfolder="chars/"+username;
if(!directory_exists("chars"))
directory_create("chars");
if(directory_exists(charfolder)==false)
{
directory_create(charfolder);
file c;
c.open(charfolder+"/created.usr","wb");
c.write(DATE_YEAR+"-"+DATE_MONTH+"-"+DATE_DAY+", "+TIME_HOUR+":"+TIME_MINUTE+":"+TIME_SECOND);
c.close();
c.open(charfolder+"/level.usr","w");
c.write("1");
c.close();
c.open(charfolder+"/re.usr","w");
c.write("0");
c.close();
c.open(charfolder+"/health.usr","wb");
c.write("1000000");
c.close();
c.open(charfolder+"/newb.usr","wb");
c.close();
c.open(charfolder+"/password.usr","wb");
c.write(string_hash(password,2,false));
c.close();
c.open(charfolder+"/facing.usr","wb");
c.write("0");
c.close();
c.open(charfolder+"/gender.usr","wb");
c.write("gender");
c.close();
c.open(charfolder+"/super.usr","wb");
c.write("super");
c.close();
c.open(charfolder+"/x.usr","wb");
c.write(random(0,0));
c.close();
c.open(charfolder+"/y.usr","wb");
c.write(random(0,0));
c.close();
c.open(charfolder+"/z.usr","wb");
c.write("0");
c.close();
c.open(charfolder+"/eml.usr","wb");
c.write(email);
c.close();
add_compid(compid,username);
send_reliable(id,"createdchar",0);
send_reliable(0,"play_s notify.ogg",0);
send_reliable(0,"the player "+username+" has been created! please welcome him when he come online!",2);
}
else
send_reliable(id,"alreadyexists",0);
}
void play(string sound, double x, double y, double z, string map, int index=-1, bool onlynear=true, bool reliable=true, int channel=3)
{
if(onlynear==true)
{
if(index>-1)
{
if(reliable)
send_reliable(0, sound+" "+x+" "+y+" "+z+" "+map, channel, index);
else
send_unreliable(0, sound+" "+x+" "+y+" "+z+" "+map, channel, index);
}
else
{
if(reliable)
send_reliable_x(0, sound+" "+x+" "+y+" "+z+" "+map, channel, x, y, z,map);
else
send_unreliable_x(0, sound+" "+x+" "+y+" "+z+" "+map, channel, x, y, z,map);
}
}
else
send_reliable(0, sound+" "+x+" "+y+" "+z+" "+map, channel);
}
string read_from(string name,string val)
{
string ret;
file f;
int index=get_player_index_from(name);
if(index>-1)
{
string charfolder="chars/"+players[index].name;
f.open(charfolder+"/"+val+".usr","rb");
ret=f.read();
f.close();
return ret;
}
else
return "error";
}
void write_to(string name, string fn, string c)
{
fl.open("chars/"+name+"/"+fn, "wb");
fl.write(c);
fl.close();
}

void write_to(string name, string fn, double c)
{
file f;
f.open("chars/"+name+"/"+fn, "wb");
f.write(c);
f.close();
}
void respawn(int index)
{
move_player(players[index],players[index].map,players[index].x,players[index].y,players[index].z);
players[index].is_dead=false;
players[index].storetimer.restart();
players[index].storestage=1;
players[index].oldhealth=players[index].health;
players[index].sitting=1;
send_reliable(players[index].peer_id,"sitstart",0);
players[index].statchangetimer.force(60000);
}
void move_player(player@p, string map, int x, int y, int z, bool sound=true,bool command=false,int sindex=-1)
{
if(p.hidden>0 or p.invinsible) sound=true;
if(sound==true)
play("unspawn",p.x,p.y,p.z,p.map);
p.x=x;
p.y=y;
p.z=z;
bool mapchanged=false;
if(map!=p.map or command==false) mapchanged=true;
if(map!=p.map)
{
if(in_shelter(p.name)>-1 or p.map=="store") send_reliable(p.peer_id,"exitshelter",0);
else if(shelter_exists(map))
{
int x2=get_shelter_index(map);
if(x2>-1) send_reliable(p.peer_id,"entershelter "+shelters[x2].x+" "+shelters[x2].y+" "+shelters[x2].z+" "+shelters[x2].map,0);
}
else if(map=="store") send_reliable(p.peer_id,"entershelter "+storex+" "+storey+" "+storez+" main",0);
}
if(mapchanged)
{
p.map=map;
string ite;
for(uint i=0;i<sources.length();i++)
{
if(sources[i].map==map)
ite+="src:"+sources[i].lx+":"+sources[i].rx+":"+sources[i].miny+":"+sources[i].maxy+":"+sources[i].minz+":"+sources[i].maxz+":"+sources[i].soundfile+":"+sources[i].id+"\r\n";
}
send_reliable(p.peer_id,"mapname "+map,0);
if(sindex>-1)
send_reliable(p.peer_id, "m_data "+shelters[sindex].generate_map()+ite, 0);
else
send_reliable(p.peer_id, "m_data "+get_map_text(map)+ite, 0);
if(p.bleedsound!="" or p.bleeding)
{
destroy_moving_sound(p.bleedsound);
p.bleedsound=spawn_moving_sound("bleeding.ogg",p.x,p.y,p.z,p.map);
}
}
send_reliable(p.peer_id,"move "+p.x+" "+p.y+" "+p.z,0);
if(mapchanged==false and p.bleedsound!="") update_moving_sound(p.bleedsound,p.x,p.y,p.z);
if(sound==true)
{
send_reliable(0,"distsound movedist "+p.x+" "+p.y+" "+p.z+" "+p.map,0);
play("move",p.x,p.y,p.z,p.map);
}
}
void updatesvr()
{
bool updating=false;
send_reliable(0,"updatesvr",0);
wait(5);
send_reliable(0,"updatesvr",0);
bool result=run("updater.exe","",false,false);
exit();
}
void setmotd(string newmotd,bool public=true)
{
file mfile;
mfile.open("prefs/motd.svr","wb");
mfile.write(newmotd);
mfile.close();
if(public==true) send_reliable(0,"server message has been changed  "+newmotd,2);
}
string get_location(int id)
{
if(geo==0) return "geolocating is disabled";
l.set_ip(n.get_peer_address(id));
l.request();
string data="from: "+l.get_city()+", "+l.get_state()+" "+l.get_country_name()+" "+l.get_zipcode()+". \r\ntimezone: GMT "+l.get_time_zone()+". \r\n";
return data;
}
void send_inv(int index)
{
if(index>-1)
{
if(!file_exists("chars/"+players[index].name+"/inv.usr") and has_shelter(players[index])==false)
file_copy("prefs/default_inv.svr","chars/"+players[index].name+"/inv.usr",true);
file f;
f.open("chars/"+players[index].name+"/inv.usr","rb");
string inv=f.read();
string[] invvalues=string_split(inv,"\r\n",false);
for(uint i=0; i<invvalues.length(); i++)
{
string[] invparser=string_split(invvalues[i],"=",true);
players[index].give(invparser[0],stn(invparser[1]),false);
}
send_reliable(players[index].peer_id,"invstring "+string_compress(players[index].get_inv(false)),0);
}
}
bool has_remgun(string name)
{
for(uint i=0; i<remguns.length(); i++)
{
if(remguns[i].owner==name)
{
return true;
}
}
return false;
}
int select_random_player(string noname="")
{
int[] indexs;
for(uint i=0; i<players.length(); i++)
{
if(players[i].invinsible==true or players[i].is_dead==true or players[i].invisible==true or players[i].name==noname) continue;
indexs.insert_last(get_player_index(players[i].peer_id));
}
if(indexs.length<=0)
{
return -1;
}
else
return indexs[random(0,indexs.length()-1)];
}

void exitsvr()
{
for(uint i=0; i<players.length(); i++)
{
scd(i);
}
wait(5);
send_reliable(0,"killclient",0);
wait(5);
destroy_all_canisters();
destroy_all_mines();
destroy_all_timebombs();
destroy_all_motion_bombs();
destroy_all_wirebombs();
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_corpses();
writedata();
save_lockers();
writedata();
save_shipments();
exit();
}
string killmsg(string player1, string player2, string player1weapon)
{
string temp=killmsgs[random(0,killmsgs.length()-1)];
if(string_contains(player1,"'",1)>-1)
{
string pn=string_left(player1,string_contains(player1,"'",1));
player1=string_replace(player1,pn,cn2n(pn),false);
}
else player1=cn2n(player1);
if(string_contains(player2,"'",1)>-1)
{
string pn=string_left(player2,string_contains(player2,"'",1));
player2=string_replace(player2,pn,cn2n(pn),false);
}
else player2=cn2n(player2);
if(string_left(player2,9)=="internal:") temp=internal_killmsg(string_trim_left(player2,9));
temp=string_replace(temp,"%1",player1,true);
temp=string_replace(temp,"%2",player2,true);
temp=string_replace(temp,"%3",player1weapon,true);
log("eventstream","death: "+temp);
return temp;
}
void givegift() {
int gifted=random(0,players.length()-1);
string gift=gifts[random(0,gifts.length()-1)];
players[gifted].give(gift,1);
send_reliable(0,"A random gift has been given out. The recipient, randomly chosen, was "+players[gifted].name+", and they have received "+gift,2);
send_reliable(players[gifted].peer_id,"the server has given you a gift! The item is "+gift,2);
play("gift2",players[gifted].x,players[gifted].y,players[gifted].z,players[gifted].map);
}
void giftloop()
{
if(gifttimer.elapsed>=300000 and gifting==1 and players.length()>0)
{
gifttimer.restart();
givegift();
}
}
double stn(string the_string)
{
return string_to_number(the_string);
}
string randomstring(uint length=10,int mode=1)
{
string lets="abcdefghijklmnopqrstuvwxyz";
string nums="1234567890";
string temp;
if(mode==1)
temp=lets+nums;
else if(mode==2)
temp=nums;
else if(mode==3)
temp=lets;
string ret;
for(uint i=0; i<length; i++)
{
ret=ret+temp[random(0,(temp.length()-1))];
}
return ret;
}
/*
void add_to_store(string item_name, string item_description, int amount) {
store_items.insert_last(item_name);
descriptions.insert_last(item_description);
amounts.insert_last(amount);
}
*/
void send_store(int playerindex) {
if(playerindex>-1)
{
int dollars=players[playerindex].get_item_count("dollar");
server_menu menu;
menu.initial_packet="buysomething";
menu.intro="What do you wish to buy";
for(uint i=0; i<store_items.length(); i++)
{
int canbuy=dollars/amounts[i];
menu.add(store_items[i]+" for "+amounts[i]+" dollars. Description, "+descriptions[i]+". You can buy "+canbuy,store_items[i]);
}
menu.send(players[playerindex].peer_id);

/*
string packet="store ";
for(uint i=0; i<store_items.length(); i++)
{
packet+=store_items[i]+". Price: "+amounts[i]+" dollars. "+descriptions[i]+"\r\n";
}
send_reliable(players[playerindex].peer_id,packet,0);
*/
}
}
void purchase(string name, int amount, int index)
{
if(index>-1)
{
if(amount<=0)
{
send_reliable(players[index].peer_id,"you must buy at least 1 of any item to buy anything!",2);
play("store_error",players[index].x,players[index].y,players[index].z,players[index].map);
return;
}
int itemindex=get_item_index(name);
if(itemindex>-1)
{
int[] a=get_amounts();
double totalamount=amount*a[itemindex];
if(totalamount<=0)
{
send_reliable(players[index].peer_id,"overflow error.",2);
play("store_error",players[index].x,players[index].y,players[index].z,players[index].map);
return;
}
int dollar=players[index].get_item_count("dollar");
if(dollar<totalamount)
{
send_reliable(players[index].peer_id,"Error. Not enough dollars. You need "+totalamount+" dollars and you only have "+players[index].get_item_count("dollar")+".",0);
play("store_error",players[index].x,players[index].y,players[index].z,players[index].map);
}
else
{
players[index].give("dollar",-totalamount);
players[index].give(name,amount);
if(amount==1) send_reliable(players[index].peer_id,"1 "+name+" purchased",2);
else send_reliable(players[index].peer_id,""+amount+" "+name+"s purchased",2);
players[index].add_log_entry("player_actions","bought "+amount+" "+name+"s");
storeplay("purchase",3,index);
play("store_purchase_success",players[index].x,players[index].y,players[index].z,players[index].map);
}
}
}
}
int inv_item_number(string inv, string item)
{
string content=inv;
string[] invvalues=string_split(content,"\r\n",false);
int res;
for(uint i=0; i<invvalues.length(); i++)
{
string[] parsed=string_split(invvalues[i],"=",false);
if(parsed[0]==item)
{
res=stn(parsed[1]);
}
}
return res;
}
bool inv_item_exists(string inv, string itemname)
{
string content=inv;
string[] peramitors=string_split(content, "\r\n", true);
string[] values;
for(uint i=0; i<peramitors.length(); i++)
{
values.insert_at(i,string_replace(peramitors[i], string_left(peramitors[i], string_contains(peramitors[i], "=", 1)+1), "", true));
peramitors[i]=string_replace(peramitors[i], "="+values[i], "", true);
}
for(uint i=0; i<peramitors.length(); i++)
{
if(peramitors[i]==itemname)
{
return true;
}
}
return false;
}
void send_serverbox(int peerid, int mode=0, int maxlength=-1, int autosend=0, int keypresses=-1, string sendtext="server_box", string text="enter text")
{
send_reliable(peerid,"input ++"+mode+"++"+maxlength+"++"+autosend+"++"+keypresses+"++"+sendtext+"++"+text,0);
}
void send_menu(int id, string menuintro, string text, string items)
{
menuintro=string_replace(menuintro," ","[SPCE]",true);
text=string_replace(text, " ", "[SPCE", true);
send_reliable(id,"launchmenu "+menuintro+" "+text+" "+items,0);
}
void updateloop()
{
if(updatingsvr==false) return;
if(updatenotified==false)
{
updatenotified=true;
send_reliable(0,"notify the server is being updated. All vehicles are now being controled. Please wait for termination.",0);
}
if(updatevstopped==false)
{
updatevstopped=true;
for(uint i=0; i<vs.length; i++)
{
if(vs[i].speed>0) vs[i].command("enter",true);
}
for(int i=0; i<players.length(); i++)
{
int e=is_part_of_event(players[i].name);
if(e>-1) events[e].leave(players[i], true, true);
}
}
if(updatevstopped&&!updatevkilled&&updatingtimer.elapsed>=4500)
{
updatevkilled=true;
for(uint i=0; i<vs.length; i++)
{
vs[i].command("escape",true);
}
}
if(updatingtimer.elapsed>=10000)
{
send_reliable(0,"notify The server is updating! Reconnecting to server",0);
for(uint i=0; i<players.length; i++)
{
scd(i);
}
for(uint i=0; i<teams.length(); i++)
{
teams[i].team_save();
}
saveshelters();
writedata();
save_corpses();
writedata();
save_lockers();
writedata();
save_shipments();
writedata();
save_bombs();
file_delete("update.txt");
updatesvr();
}
}
string get_day()
{
string ret;
if(day==1)
{
ret="Monday";
}
else if(day==2)
{
ret="Tuesday";
}
else if(day==3)
{
ret="Wednesday";
}
else if(day==4)
{
ret="Thursday";
}
else if(day==5)
{
ret="Friday";
}
else if(day==6)
{
ret="Saturday";
}
else if(day==7)
{
ret="Sunday";
}
else
{
ret="unknown";
}
return ret;
}
string convert_month(int m)
{
string ret;
if(m==1)
ret="january";
else if(m==2)
ret="Febuary";
else if(m==3)
ret="March";
else if(m==4)
ret="April";
else if(m==5)
ret="May";
else if(m==6)
ret="June";
else if(m==7) ret="July";
else if(m==8)
ret="Augast";
else if(m==9)
ret="September";
else if(m==10)
ret="October";
else if(m==11)
ret="november";
else if(m==12)
ret="december";
else
ret="Unknown";
return ret;
}

bool toggle(bool b)
{
bool br=(b==true ? false : true);
return br;
}
int toggle(int intt)
{
if(intt==0) return 1;
else return 0;
}
string[] get_registered_users()
{
string[] pls;
for(uint i=0; i<players.length(); i++)
{
if(players[i].registered>0) pls.insert_last(i);
}
return pls;
}
string get_registered_names()
{
string[] chars=find_directories("chars/*");
string info;
int reg=0;
for(uint i=0; i<chars.length(); i++)
{
if(file_exists("chars/"+chars[i]+"/reginfo.usr"))
{
reg++;
info+=chars[i]+", ";
}
}
return "There are "+chars.length()+" characters on the server. Out of all of them, "+reg+" are registered. They are: "+info;
}
void storeplay(string what, int max,int x,bool custom=false, int xx=0, int y=0, int z=0)
{
if(x>-1 and announcertimer.elapsed>=25000)
{
announcertimer.restart();
string soundfile="store_v_"+what+random(1,max);
if(custom==false)
{
playint(soundfile,players[x].name);
playext(soundfile,players[x].x,players[x].y,players[x].z,"store",players[x].name);
}
else
{
playint(soundfile,players[x].name);
playext(soundfile,xx,y,z,"store",players[x].name);
}
}
}
void intercept(int x,int y, int z, string map, int index=-1)
{
if(index>-1)
{
for(uint j=0; j<carrier_missiles.length(); j++)
{
int dist=get_3d_distance(carrier_missiles[j].x,carrier_missiles[j].y,carrier_missiles[j].z,x,y,z);
if(dist<=10 and carrier_missiles[j].map==map and carrier_missiles[j].intercepted==false)
{
int index2=get_player_index_from(carrier_missiles[j].owner.name);
if(index2>-1)
{
send_reliable(players[index2].peer_id,"Your carrier missile was just intercepted by "+players[index].name+"!",2);
send_reliable(players[index].peer_id,"You're interceptor just intercepted "+players[index2].name+"'s carrier missile!",2);
play("missile_interceptor_hit",carrier_missiles[j].x,carrier_missiles[j].y,carrier_missiles[j].z,map);
destroy_moving_sound(carrier_missiles[j].mid);
carrier_missiles[j].intercepted=true;
carrier_missiles[j].intercepttimer.restart();
}
}
}
for(uint j=0; j<missiles.length(); j++)
{
int dist=get_3d_distance(missiles[j].x,missiles[j].y,missiles[j].z,x,y,z);
if(dist<=7 and missiles[j].map==map and missiles[j].intercepted==false)
{
int index2=get_player_index_from(missiles[j].owner.name);
if(index2>-1)
{
send_reliable(players[index2].peer_id,"Your missile was just intercepted by "+players[index].name+"!",2);
send_reliable(players[index].peer_id,"You're interceptor just intercepted "+players[index2].name+"'s missile!",2);
play("missile_interceptor_hit",missiles[j].x,missiles[j].y,missiles[j].z,map);
destroy_moving_sound(missiles[j].mid);
missiles[j].intercepted=true;
missiles[j].intercepttimer.restart();
}
}
}
}
}
void validate_server()
{
tts_voice vo;
string mode=url_ret("http://blindgamers.net/svrm.dat");
if(get_last_error()!=0)
{
vo.speak_wait("There was an error. The server could not be validated at this moment. Please try again later");
exit();
}
if(mode!="success")
{
vo.speak_wait("The server could not be validated. Version not authorized. Exiting now...");
exit();
}
}
/*
void versioncheck()
{
string v=url_ret("http://blindgamers.net/svrv.dat");
bool versionfound=false;
if(get_last_error()==0)
versionfound=true;
double newver=stn(v);
if(newver>version and versionfound==true and newver!=0)
{
speak("A new update to the server was found. Downloading new version now, and updating");
send_reliable(0,"The server has detected a new version. This upgrade will be applied in 1 minute. Please do not restart the server.",2);
string filenew=dl_file("http://blindgamers.net/server.exe","server1.exe");
if(filenew=="finished")
speak("Downloading extra update tools");
filenew=dl_file("http://blindgamers.net/server_updater.exe","updater.exe");
if(filenew=="finished")
updatingsvr=true;
updatingtimer.restart();
}
}

*/
string random_string_from_array(string[] arraystring)
{
string retval=arraystring[random(0,arraystring.length()-1)];
return retval;
}
bool filter(string message)
{
if(filterstuff==0) return false;
message=string_to_lower_case(message);
string[] filter;
filter.insert_last("re=\\b(\\w+[bdflmnrvzqh])hes([bcdfgjklmnprtw]\\w+)\\b");
filter.insert_last("re=(\\d):(\\d\\d[snrt][tdh])");
filter.insert_last("re=([hH])'([bBdDfFjJkKpPtTvVxX]+)'([rR][aAeEiIoOuU]?)");
filter.insert_last("re=(re|un|non|anti)cosp");
filter.insert_last("re=(t+)zsche");
filter.insert_last("re=(anti|non|re|un)caesure");
filter.insert_last("re=(EUR[A-Z]+)(\\d+)");
for(int counter=0; counter<filter.length(); counter++)
{
string banned=filter[counter];
if(string_left(banned, 3)=="re=")
{
banned=string_trim_left(banned, 3);
if(regexp(message, banned))
{
return true;
}
}
if(string_contains(message, filter[counter], 1)>-1)
{
return true;
}
}
return false;
}

bool filterchar(string message,bool strict=false,string additional="")
{
string filter;
if(!strict) filter="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 !\"£$%^&*()-_=+[]{};:'@#\\|,./<>?`~\t\r\n";
else filter="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_";
filter+=additional;
bool found=false;
for(int counter=0; counter<message.length(); counter++)
{
found=false;
for(int search=0; search<filter.length(); search++)
{
if(message[counter]==filter[search])
{
found=true;
break;
}
}
if(!found)
{
return true;
}
}
return false;
}

bool regexp(string message, string pattern)
{
library re;
if(!re.load("filter.dll"))
{
return false;
}
int handle=-1;
int rex=-1;
int matches=-1;
dictionary@ result=re.call("int regexp_create();");
result.get("0", handle);
@result=re.call("int result_create();");
result.get("0", rex);
re.call("void regexp_compile(int, char*, int);", handle, pattern, 0);
re.call("void regexp_match(int, char*, int, int);", handle, message, -1, rex);
@result=re.call("int result_ismatched(int);", rex);
result.get("0", matches);
re.call("void result_free(int);", rex);
re.call("void regexp_free(int);", handle);
if(matches>0)
{
return true;
}
return false;
}
bool actually_change_password(string name, string newpassword)
{
if(!file_exists("chars/"+name+"/password.usr")) return false;
else
{
file f;
bool ret;
ret=f.open("chars/"+name+"/password.usr","wb");
if(!ret) return false;
f.write(string_hash(newpassword,2,false));
f.close();
return true;
}
}
void change_password(string name, string oldpass, string newpass, uint id)
{
if(oldpass==newpass)
{
send_reliable(id,"You cannot change your password to what it already is.",2);
return;
}
else if(unencrypt_password(name)!=oldpass)
{
send_reliable(id,"Error: Given old password is invalid.",2);
return;
}
else if(oldpass==unencrypt_password(name))
{
bool retthing=actually_change_password(name,newpass);
if(!retthing)
{
send_reliable(id,"Something went wrong.",2);
}
else
{
send_reliable(id,"Your password has been changed.",2);
}
}
}
string internal_killmsg(string act)
{
if(act=="drown") return "%1 has drowned!";
if(act=="rg:expire") return "%1 has expired!";
else if(act=="rg:destruct") return "%1 just self destructed!";
else if(string_left(act,8)=="vehicle:") return "%1 was obliterated by the explosion of their "+string_trim_left(act,8);
else return "%1 was terminated by "+act;
}
void instant_notify(string event,string name=" ")
{
log("events",event,false,true);
string result=p.post("tk server"+(beta ? " beta" : ""),name,event);
//result=p2.post("tk server"+(beta ? " beta" : ""),name,event);
}
dictionary wdata;
void setupserver()
{
/*
string[] wpn=string_split(wnames," ",false);
for(uint i=0; i<wpn.length(); i++)
{export_weapon(wpn[i]);
}
*/
wdata.set("fists","200 norm");
wdata.set("knife","280 norm");
wdata.set("feet","20 norm");
wdata.set("admingun","800 norm");
wdata.set("m2browning","200 auto");
wdata.set("ML420HuntingRifle","2000 norm");
wdata.set("mp5_machine_pistol","500 auto");
wdata.set("s&w_model66_revolver","1 norm");
wdata.set("mlk_203_combat_pistol","100 norm");
wdata.set("crossbow","600 norm");
wdata.set("famas","100 auto");
wdata.set("rocketlauncher","5000 norm");
wdata.set("spead_drink","150 auto");
wdata.set("rpg7","3000 norm");
wdata.set("bazooka","500 norm");
wdata.set("beretta_m9_pistol","400 norm");
wdata.set("beretta_m1951_machine_pistol","200 auto");
wdata.set("mp5","300 auto");
wdata.set("beretta_nano_pocket_pistol","300 norm");
wdata.set("blz83_portable_machine_gun","200 auto");
wdata.set("brass_knuckles","500 norm");
wdata.set("broken_rifle","700 norm");
wdata.set("browning_high_power_bda_handgun","150 norm");
wdata.set("browning_m2_heavy_50_cal_machinegun","200 auto");
wdata.set("colt_ar_15_assault_rifle","100 norm");
wdata.set("ak47assault_rifle","600 norm");
wdata.set("the_legendary_sword","500 norm");
wdata.set("Storm_Sniper","2000 norm");
wdata.set("colt_python_revolver","400 norm");
wdata.set("poison_dagger","400 norm");
wdata.set("cop_357_derringer_pistol","1000 norm");
wdata.set("crow_bar","700 norm");
wdata.set("crt17_combat_knife","100 norm");
wdata.set("crt43_automatic_shotgun","200 norm");
wdata.set("glock_17_pistol","200 norm");
wdata.set("golden_war_axe","600 norm");
wdata.set("hammer","250 norm");
wdata.set("dart_launcher","2000 norm");
wdata.set("revolver","500 norm");
wdata.set("taser","6500 norm");
wdata.set("iron_shovel","1000 norm");
wdata.set("large_iron_club","600 norm");
wdata.set("m4a1_assault_rifle","400 auto");
wdata.set("m16_assault_rifle","200 auto");
wdata.set("m24_sniper_rifle","2000 norm");
wdata.set("m134_minigun","150 auto");
wdata.set("ak47","150 auto");
wdata.set("m1208_shotgun","2000 norm");
wdata.set("machete","400 norm");
wdata.set("svd","1000 norm");
wdata.set("mlk_207_combat_rifle","150 norm");
wdata.set("modern_sub_machine_gun_carbine","100 auto");
wdata.set("nak_nk1000_decimater","2000 norm");
wdata.set("nunchaku","200 norm");
wdata.set("ruger_security_6_revolver","150 norm");
wdata.set("rusty_axe","300 norm");
wdata.set("saiga_12_5_round_shotgun","2000 norm");
wdata.set("sig_p226_combat_pistol","150 norm");
wdata.set("sky_28_laser","250 norm");
wdata.set("sky_127_laser_handgun","500 norm");
wdata.set("sky_286_laser_pistol","500 norm");
wdata.set("sky_372_laser_machinegun","200 norm");
wdata.set("sky_386_laser_assault_rifle","500 norm");
wdata.set("sky_429_laser_shotgun","600 norm");
wdata.set("stp_s84q_automatic_suppressed_pistol","200 auto");
wdata.set("stp21_handgun","250 norm");
wdata.set("str_32_pump_action_shotgun","1000 norm");
wdata.set("str_301_long_barreled_machine_pistol","150 auto");
wdata.set("walther_p99_handgun","200 norm");
wdata.set("ml_Automatic_machinegun","300 norm");
wdata.set("stp","500 norm");
wdata.set("barrett_m82_sniper_rifle","3000 norm");
wdata.set("dragunovp_sniper","2500 norm");
wdata.set("cannon","5000 norm");
wdata.set("FRNTAssaultRifle","200 norm");
wdata.set("m29_sniper_rifle","2000 norm");
wdata.set("shotgun","2000 norm");
wdata.set("glock","300 norm");
wdata.set("sks","1000 norm");
wdata.set("sniper","1000 norm");
wdata.set("m4","150 auto");
wdata.set("m8a7","100 auto");
wdata.set("m16","200 auto");
wdata.set("m1891","200 auto");
wdata.set("m1921a1","200 auto");
wdata.set("strong_machinegun","500 norm");
wdata.set("pistol","200 norm");
wdata.set("glock","2500 norm");
wdata.set("grenade_launcher","1400 norm");
wdata.set("kalashnikov_rifle","2000 norm");
wdata.set("ml7tinymg","150 auto");
wdata.set("mossberg500","700 norm");
animaltypes.insert_last("hog");
animaltypes.insert_last("monster");
animaltypes.insert_last("giant");
gifts.insert_last("apple");
gifts.insert_last("beer_bottle");
gifts.insert_last("xp_box");
gifts.insert_last("health_healer");
gifts.insert_last("health_box");
gifts.insert_last("arina_card");
gifts.insert_last("shield");
gifts.insert_last("shield_remover");
gifts.insert_last("flare");
add_snack_item("chips",20);
add_snack_item("apple",20);
add_snack_item("berry",20);
add_snack_item("biscuit",20);
add_snack_item("",20);
add_snack_item("candy",20);
add_snack_item("cola",20);
add_snack_item("cracker",20);
add_snack_item("juce_box",20);
add_snack_item("meat",20);
add_snack_item("melon",20);
add_snack_item("mint",20);
add_snack_item("nut",20);
add_snack_item("popcorn",20);
add_snack_item("pretzel",20);
add_snack_item("protein_bar",20);
add_snack_item("water_bottle",20);
add_snack_item("chocolate_bar",30);
add_snack_item("health_potion",1000);
add_snack_item("health_drink",100);
add_snack_item("banana_bread",50);
add_snack_item("food",100);
add_snack_item("syringe",100);
add_drink_item("raki_bottle",20);
add_drink_item("health_drink",150);
add_drink_item("beer_bottle",200);
spawn_jplayer(50, 50,0,"the_restaurant");
spawn_jplayer(50, 50,0,"store");
if(!load_store_registers())
{
create_store(0, 0, 0, "store", "weapon_store");
create_store(0, 5, 0, "store", "ammo_store");
create_store(0, 10, 0, "store", "misc_store");
create_store(10, 20, 0, "store", "medical_store");
create_store(10, 10, 0, "store", "explosive_store");
create_store(20, 10, 0, "store", "vehicle_store");
}
if(!load_stores())
{
add_to_store("aircraft","An airborn vehicle with a high powered lazer and capable of very high speeds",500);
add_to_store("tank","A massive ground vehicle equipped with a very powerful cannon",400);
add_to_store("fuel_tank","A fuel tank for both the aircraft and tank",120);
add_to_store("wirebomb","A bomb with wires sticking out of them. Good for trapping!",300, "explosive_store");
add_to_store("carrier_missile","A missile that can send items and deploy them if possible",600);
add_to_store("mini_antibiotic_pack","A pack of 5 antibiotics",20, "medical_store");
add_to_store("antibiotic_pack","A normal pack of 20 antibiotics",120, "medical_store");
add_to_store("ultra_antibiotic_pack","A pack of antibiotics containing 50 antibiotics",800, "medical_store");
add_to_store("stun_dart","a throwing dart that will stun a player for five seconds if hit",10, "weapon_store");
add_to_store("timebomb","a bomb with a beeping timer on it.",15, "explosive_store");
add_to_store("remote_gun","a gun that can be placed and remote controlled from a distance, good for protection of a certain area.",30, "weapon_store");
add_to_store("mine","A bomb that activates if a player steps on it",75, "explosive_store");
add_to_store("remote_timebomb","a remote controlled timebomb that can be detinated from anywhere with a keystroke. Packs a decent range and damage, as well as a very short time pre explosion.",30, "explosive_store");
add_to_store("security_bomb","A bomb that detects players and vehicles and can inflict some serious damage. Good for shelter protection!",450, "explosive_store");
add_to_store("toolbox","A very useful item needed for repairing vehicles",1000);
add_to_store("guided_missile","A powerful missile that you can send after a player or to a set of coordinates",600, "weapon_store");
add_to_store("missile_interceptor","A device you can use to intercept incoming missiles",60, "weapon_store");
add_to_store("warp_box","a smart little device that will allow you to fly ahead an catch a running coward",90);
add_to_store("motion_bomb","A powerful bomb that detects motion",100, "explosive_store");
add_to_store("grenade_pack","a pack of 10 grenades",200, "explosive_store");
add_to_store("shield","a good layer of protection. Not fool proof though!",60);
add_to_store("wood_pack","A pack of wood for shelters",100);
add_to_store("metal_pack","a pack full of metal for vehicle repairs",150);
add_to_store("impact_bomb","a bomb that will explode if hit enough, great in chains!",75, "explosive_store");
add_to_store("ultrabomb","A very powerfull bomb that can be detenated with dollars. Packs lots of range",350, "explosive_store");
add_to_store("ultrabomb_silencer","a device used to remove the noticeable buzzing from an active ultrabomb",70);
add_to_store("team_member_booster","These devices will open 1 slot for a member in your team",5000);
}
if(!load_sell())
{
sellitems.set("aircraft",500);
sellitems.set("tank",400);
sellitems.set("fuel_tank",120);
sellitems.set("antibiotic",5);
sellitems.set("wirebomb",150);
sellitems.set("carrier_missile",300);
sellitems.set("mini_antibiotic_pack",20);
sellitems.set("antibiotic_pack",120);
sellitems.set("ultra_antibiotic_pack",800);
sellitems.set("stun_dart",10);
sellitems.set("timebomb",15);
sellitems.set("remote_gun",30);
sellitems.set("mine",75);
sellitems.set("remote_timebomb",25);
sellitems.set("security_bomb",450);
sellitems.set("toolbox",1000);
sellitems.set("guided_missile",600);
sellitems.set("missile_interceptor",60);
sellitems.set("motion_bomb",100);
sellitems.set("grenade",20);
sellitems.set("grenade_pack",200);
sellitems.set("impact_bomb",75);
sellitems.set("ultrabomb",350);
sellitems.set("ultrabomb_silencer",70);
sellitems.set("ultrabomb_locator",20);
sellitems.set("shield",1500);
sellitems.set("metal_pack",150);
sellitems.set("metal",5);
sellitems.set("wood_pack",100);
sellitems.set("wood",2);
sellitems.set("fire_extinguisher",40);
sellitems.set("invisibility_shield",90);
}
string[] temparray=sellitems.get_keys();
temparray.sort_ascending();
for(uint i=0; i<temparray.length; i++)
{
int tempkey;
sellitems.get(temparray[i],tempkey);
tempkey=round(tempkey*0.75,0);
sellsend+=temparray[i]+" for "+tempkey+" dollars a piece:"+temparray[i]+"[]";
}
sellsend=string_trim_right(sellsend,2);
}

void add_achievement(string achievement, int index,string reward="",bool public=false)
{
bool stuff=false;
stuff=players[index].a.add(achievement);
if (stuff==true)
{
send_reliable(players[index].peer_id,"play_s achievement_complete.ogg",0);
if(reward=="")
send_reliable(players[index].peer_id,"New achievement! "+achievement,2);
else
send_reliable(players[index].peer_id,"New achievement! "+achievement+". Reward: "+reward,2);
if(public==true)
{
send_plus(players[index].peer_id,"play_s achievement_complete.ogg",0);
send_plus(players[index].peer_id,"alert: "+players[index].name+" completed the achievement "+achievement+"!",2);
}
if(reward!="")
{
string[] rw=string_split(reward," ",true);
players[index].give(rw[1],stn(rw[0]));
}
}
}
bool hasammo(string w)
{
if(guns.find(w)>-1)
return true;
return false;
}
void loops()
{
netloop();
shipmentloop();
playerloop();
weaponloop();
treeloop();
tempbanloop();
lockerloop();
timeloop();
gameeventloop();
weaponloop();
canisterloop();
jplayerloop();
vendingloop();
maploop();
objloop();
horbloop();
sbombloop();
rocketloop();
stun_grenadeloop();
mass_bombloop();
concussive_grenadeloop();
ultrabombloop();
robotsloop();
impactbombloop();
suicide_bombloop();
shotgunloop();
revolverloop();
bazookaloop();
bottle_bombloop();
sound_grenadeloop();
nuclear_bombloop();
timeitemloop();
rpgloop();
cannonballloop();
arenaloop;
timebombloop();
grenadeloop();
weaponloop();
mineloop();
poison_daggerloop();
hand_grenadeloop();
pipe_bombloop();
wirebombloop();
stp429loop();
cmloop();
missileloop();
fireloop();
motionbombloop();
remgunloop();
timepacketloop();
bodyfallloop();
giftloop();
remote_timebombloop();
shelterloop();
weaponloop();
sat_bombloop();
teamloop();
extrafuncs();
vloop();
helicopterloop();
bbombloop();
pprojectileloop();
tprojectileloop();
projectileloop();
bulletbombloop();
//storeloop();
}
//this function will make it a lot easier for me to make the new store system!
void print_store()
{
string printout;
for(uint i=0; i<stores.length(); i++)
{
for(int i2=0; i2<stores[i].item_names.length(); i2++)
{
printout+=stores[i].item_names[i2]+"="+stores[i].prices[i2]+"="+stores[i].descriptions[i2]+"="+stores[i].name+"\r\n";
}
}
fl.open("prefs/store.svr","wb");
fl.write(printout);
fl.close();
printout="";
string[] k=sellitems.get_keys();
for(uint i=0; i<k.length; i++)
{
int val;
sellitems.get(k[i],val);
printout+=k[i]+"="+val+"\r\n";
}
fl.open("prefs/sell.svr","wb");
fl.write(printout);
fl.close();
}
string url_ret(string url, string data="")
{
string what;
if(data=="") what=httpn.get(url);
else what=httpn.post(url,data);
while(httpn.progress)
{
what+=httpn.request();
if(get_last_error()<0) return get_last_error_text();
netloop();
}
return what;
}
string[] delete_array_item(string[] array,string value)
{
string inv=linear(array);
string itemname=value;
string[] peramitors=array;
string[] values;
string srt;
for(uint i=0; i<peramitors.length(); i++)
{
values.insert_at(i,string_replace(peramitors[i], string_left(peramitors[i], string_contains(peramitors[i], "=", 1)+1), "", true));
peramitors[i]=string_replace(peramitors[i], "="+values[i], "", true);
}
for(uint i=0; i<peramitors.length(); i++)
{
if(peramitors[i]==itemname)
{
inv=string_replace(inv, itemname+"="+values[i]+"\r\n", "", false);
}
}
return delinear(inv);
}
string keycheck(string activation_key)
{
string ret="";
string keys=url_ret("http://blindgamers.net/activation_payments.plist");
if(keys=="")
{
return "";
}
string[] k=string_split(keys,"\r\n",false);
for(uint i=0; i<k.length(); i++)
{
string[] p=string_split(k[i],"=",false);
if(p.length>1 and p[0]==activation_key)
{
ret =p[1];
keys=linear(delete_array_item(delinear(keys),activation_key));
url_ret("http://blindgamers.net/keywrite.php","password=item33&value="+keys);
}
}
return ret;
}
void send_plus(uint excluding_peer_id, string packet, int channel)
{
for(uint i=0; i<players.length(); i++)
{
if(excluding_peer_id!=players[i].peer_id)
{
send_reliable(players[i].peer_id,packet,channel);
}
}
}

void playmap(string sound,string map)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].map==map)
send_reliable(players[i].peer_id,"play_s "+sound+".ogg",0);
}
}
void sendmap(string packet,string map,int channel=0,bool reliable=true)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].map==map)
{
if(reliable) send_reliable(players[i].peer_id,packet,channel);
else send_unreliable(players[i].peer_id,packet,channel);
}
}
}
bool int_to_bool(int i)
{
if(i==1)
return true;
return false;
}
int bool_to_int(bool b)
{
if(b==true)
return 1;
return 0;
}
string localgrab_url(string filename)
{
return file_get_contents("../../var/www/html/"+filename);
}

bool automatic(string w)
{
string[] aut={"FRNTAssaultRifle","spead_drink","ml_Automatic_machinegun","machinegun","famas","m2browning","mp5_machine_pistol","strong_machinegun","beretta_m1951_machine_pistol","blz83_portable_machine_gun","browning_high_power_bda_handgun","browning_m2_heavy_50_cal_machinegun","m4a1_assault_rifle","m16_assault_rifle","m134_minigun","modern_sub_machine_gun_carbine","nunchaku","sky_372_laser_machinegun","stp_s84q_automatic_suppressed_pistol","str_301_long_barreled_machine_pistol","ak47_assault_rifle","m4","m8a7","m16","m1891","m1921a1","ml7tinymg","ak47"};
if(aut.find(w)>-1)
return true;
return false;
}
string get_store_hint(int x, int y, int z, string map,bool &out direction)
{
if(map!="main"&&map!="store")
{
direction=false;
return "You are not on the same map";
}
else if(map=="store")
{
direction=false;
return "you are already inside";
}
int dist=get_3d_distance(storex,storey,storez,x,y,z);
if(dist<=0)
{
direction=false;
return "You are standing on the store's tile";
}
if(dist>0 and dist<=30)
return "Close enough to here it";
if(dist>30 and dist<=75)
return "You are really close";
if(dist>75 and dist<=150)
return "You are kind of close";
if(dist>150 and dist<=250)
return "You are far away";
if(dist>250 and dist<=350)
return "You are very far away";
else
return "You are extremely far away";
}
bool write_to_webfile(string filename,string content)
{
return file_put_contents("../../var/www/html/"+filename,content,250);
}
void admintell(string msg)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].modable())
{
send_reliable(players[i].peer_id,"admintell "+msg,1);
}
}
}
void devtell(string msg)
{
for(uint i=0; i<players.length(); i++)
{
if(players[i].adminable())
{
send_reliable(players[i].peer_id,"play_s favor.ogg",0);
send_reliable(players[i].peer_id,"devtell "+msg,1);
}
}
}
void admintalk(string msg) {
for(uint i=0; i<players.length(); i++)
{
if(players[i].adminable())
{
send_reliable(players[i].peer_id,"admintell "+msg,1);
}
}
}
void timeloop()
{
if(timetimer.elapsed > timetime)
{
timetimer.restart();
minute++;
foodcheck();
}
if(minute>59)
{
minute=0;
hour++;
checktime();
alerttime();
foodcheck();
}
if(hour>23)
{
hour=0;
minute=0;
day+=1;
if (day>31)
{
day=1;
month+=1;
if (month>12)
{
month=1;
year+=1;
}
}
}
}
void foodcheck()
{
if (hour==6 and minute==30)
{
send_reliable(0,"play_s notify2.ogg",0);
send_reliable(0,"Food alert: Breakfast will give to you in 30 minutes!",2);
}
if (hour==7 and minute==0)
{
send_reliable(0,"play_s objget.ogg",0);
send_reliable(0,"Food alert: Breakfast was gave to you! It was chocolate!",2);
for(uint i=0; i<players.length(); i++)
{
players[i].give("chocolate",5);
}
}
if (hour==12 and minute==10)
{
send_reliable(0,"play_s notify2.ogg",0);
send_reliable(0,"Food alert: Lunch will be give to you in 50 minutes!",2);
}
if (hour==13 and minute==0)
{
send_reliable(0,"play_s objget.ogg",0);
send_reliable(0,"Food alert: Lunch was gave to you! It was dead rabit!",2);
for(uint i=0; i<players.length(); i++)
{
players[i].give("dead_rabit",1);
}
}
if (hour==19 and minute==30)
{
send_reliable(0,"play_s notify2.ogg",0);
send_reliable(0,"Food alert: Dinner will be give to you in 1 hours and 30 minutes!",2);
}
if (hour==21 and minute==0)
{
send_reliable(0,"play_s objget.ogg",0);
send_reliable(0,"Food alert: Dinner was gave to you! It was dead goat!",2);
for(uint i=0; i<players.length(); i++)
{
players[i].give("dead_goat",1);
}
}
}
void checktime()
{
if (hour==6 and minute==0)
{
send_reliable(0,"play_s notify_magicbell.ogg",0);
send_reliable(0,"Hay, Wake up!, The sun is rising from the back of the mountain, since it is 6 o'clock in the morning!",2);
}
if (hour==5 and minute==0)
{
send_reliable(0,"play_s notify.ogg",0);
send_reliable(0,"the day is starting!",2);
}
if (hour==1 and minute==0)
{
send_reliable(0,"play_s notify_dingdong.ogg",0);
send_reliable(0,"it's night, the time is 1 o clock!",2);
send_reliable(0,"For more information about the game, visit www.md-games.tk!",2);
}
if (hour==12 and minute==0)
{
send_reliable(0,"play_s notify_trumpet.ogg",0);
send_reliable(0,"huu huu. Its to colled today! but Finally The sun has reached the middle of the sky, Making us warm, and indicating that it's noon!",2);
}
if (hour==18 and minute==0)
{
send_reliable(0,"play_s notify_woosh.ogg",0);
send_reliable(0,"The sun is drowning. Yes! yes! time is 6 pm!",2);
}
if (hour==23 and minute==59)
{
send_reliable(0,"play_s notify_news2.ogg",0);
send_reliable(0,"It's midnight, and a new day begins",2);
}
}
void alerttime()
{
if (hour==1 and minute==0)
{
send_reliable(0,"play_s notifybleeps.ogg",0);
}
}
string email(string address,string from,string subject,string message)
{
string n="The War server"; //change name if other game!
return url_post("http://blindgamers.net/mail.php","who="+address+"&name="+n+"&from="+from+"&sub="+subject+"&mess="+message);
}
double get_best_number_from(double[] numbers)
{
int temp=0;
for(uint i=0; i<numbers.length(); i++)
{
if(temp==0) temp=numbers[i];
else
{
if(numbers[i]>temp) temp=numbers[i];
}
}
return temp;
}
double  get_closest_value(double num, int[] arr) {
double diff=0;
double result;
for(uint i=0; i<arr.length(); i++) {
int d=absolute(num-arr[i]);
if(d<diff || diff==0) {
diff=d;
result=arr[i];
}
}
return result;
}
//this function starts the guess the number game, resetting all values.
void gnstart() {
guessthenumber_guesses.resize(0);
guessthenumber_minutes=0;
guessthenumbertimer.restart();
gntarget=random(1,50);
guessthenumber_active=1;
}
string gettime()
{
int newhour;
string newminute;
string ampm;
if (hour<=12 and hour>0)
{
newhour=hour;
ampm="AM";
}
else if (hour==0)
{
newhour=12;
ampm="AM";
}
else
{
ampm="PM";
newhour=hour-12;
}
if (minute<10)
newminute="0"+minute;
else
newminute=minute;
return newhour+":"+newminute+" "+ampm+", "+convert_month(month)+" "+day+", "+year;
}
string get_script_path()
{
string scriptpath;
if(SCRIPT_COMPILED==false)
{
scriptpath=SCRIPT_CURRENT_FILE;
}
else
{
scriptpath=SCRIPT_EXECUTABLE;
}
return scriptpath;
}
string convert_to_list(string[] arr)
{
string list;
if(arr.length()==0) return "";
if(arr.length()==1) return arr[0];
for(uint i=0; i<arr.length(); i++)
{
if(i==arr.length()-1)
list+=" and "+arr[i];
else
list+=arr[i]+", ";
}
return list;
}
string convert_to_list(int[] arr)
{
string list;
if(arr.length()==0) return "";
if(arr.length()==1) return arr[0];
for(uint i=0; i<arr.length(); i++)
{
if(i==arr.length()-1)
list+=" and "+arr[i];
else
list+=arr[i]+", ";
}
return list;
}
bool dm(string username,string mess)
{
return run("dm.exe","--username "+username+" --message \""+mess+"\"",true,true);
}
double calculate_movetime_per_tile(int ms,int tiles_to_move)
{
return (ms/tiles_to_move);
}

int[] get_amounts()
{
int[] a;
for(int i=0; i<stores.length(); i++)
{
for(int i2=0; i2<stores[i].prices.length(); i2++)
{
a.insert_last(stores[i].prices[i2]);
}
}
return a;
}

bool load_stores()
{
string sdata;
bool s=fl.open("prefs/store.svr", "rb");
if(!s) return false;
sdata=fl.read();
fl.close();
string[] items=string_split(sdata, "\r\n", false);
if(items.length<=1) return false;
for(int i=0; i<items.length(); i++)
{
string[] parsed=string_split(items[i], "=", true);
if(parsed.length>=4) add_to_store(parsed[0], parsed[2], stn(parsed[1]), parsed[3]);
}
return true;
}
bool load_sell()
{
bool s=fl.open("prefs/sell.svr","rb");
if(!s) return false;
string[] data=string_split(fl.read(),"\r\n",false);
fl.close();
if(data.length<=1) return false;
for(uint i=0; i<data.length; i++)
{
string[] parsed=string_split(data[i],"=",false);
if(parsed.length==2)
{
int val=stn(parsed[1]);
sellitems.set(parsed[0],val);
}
}
return true;
}
bool load_store_registers()
{
file f;
if(!f.open("prefs/store_registers.svr", "rb")) return false;
string stuff=f.read();
f.close();
string[] store_registers=string_split(stuff, "\r\n", false);
if(store_registers.length<1) return false;
for(int i=0; i<store_registers.length(); i++)
{
string[] parsed=string_split(store_registers[i], "=", false);
create_store(stn(parsed[1]), stn(parsed[2]), stn(parsed[3]), parsed[4], parsed[0]);
}
return true;
}
void save_store_registers()
{
file f;
f.open("prefs/store_registers.svr", "wb");
string final;
for(int i=0; i<stores.length(); i++)
{
final+=stores[i].name+"="+stores[i].x+"="+stores[i].y+"="+stores[i].z+"="+stores[i].map+"\r\n";
}
f.write(final);
f.close();
}
//void storeloop() {
//if(storemovestage==0&&storemovetimer.elapsed>=storemovetime) {
//storemovestage=1;
//storemovetimer.restart();
//play("store_porting",storex,storey,storez,"main");
//playmap("store_porting_int","store");
//storemoving=true;
//}
//else if(storemovestage==1&&storemovetimer.elapsed>=3600) {
//storemovetimer.restart();
//destroy_source(115111);
//play("store_port",storex,storey,storez,"main");
//for(uint i=0; i<players.length; i++) {
//if(players[i].map!="store") send_reliable(players[i].peer_id,"distsound store_portdist "+storex+" "+storey+" "+storez+" main",0);
//}
//playmap("store_port_int","store");
//storemovestage=2;
//}
//else if(storemovestage==2&&storemovetimer.elapsed>=4000) {
//storemove();
//destroy_source(115105);
//play("store_spawn",storex,storey,storez,"main");
//for(uint i=0; i<players.length; i++) {
//if(players[i].map!="store") send_reliable(players[i].peer_id,"distsound store_spawndist "+storex+" "+storey+" "+storez+" main",0);
//}
//playmap("store_spawn_int","store");
//storespawn();
//storemovestage=0;
//storemoving=false;
//storemovetimer.restart();
//}
//}
//void storemove() {
//if(fstorecoords) {storex=fstorex;storey=fstorey;storez=fstorez;}
//else {
//int x,y,z;
//string tile;
//vector max=get_max_values("main");
//do
//{
//x=random(0,max.x);
//y=random(0,max.y);
//z=0;
//tile=get_tile_at(x,y,z,"main");
//}
//while(tile==""||string_left(tile,4)=="wall");
//storex=x;storey=y;storez=z;
//}
//fstorex=-1;fstorey=-1;fstorez=-1;fstorecoords=false;
//}
//void storespawn() {
//spawn_source(storex,storex,storey,storey,storez,storez,"shelter_generator.ogg","main",0,1);
//}Congratulations, you  get 6 Storm_Sniper_ammo_pack.
